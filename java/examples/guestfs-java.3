.\" Automatically generated by Podwrapper::Man 1.30.3 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "guestfs-java 3"
.TH guestfs-java 3 "2015-10-26" "libguestfs-1.30.3" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
guestfs\-java \- How to use libguestfs from Java
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& import com.redhat.et.libguestfs.*;
\& 
\& GuestFS g = new GuestFS ();
\& g.add_drive ("disk.img",
\&              new HashMap<String,Object>() {
\&                {
\&                    put ("readonly", Boolean.TRUE);
\&                    put ("format", "raw");
\&                }
\&              });
\& g.launch ();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This manual page documents how to call libguestfs from the Java
programming language.  This page just documents the differences from
the C \s-1API\s0 and gives some examples.  If you are not familiar with using
libguestfs, you also need to read \fIguestfs\fR\|(3).
.SS "\s-1CLOSING\s0 \s-1THE\s0 \s-1HANDLE\s0"
.IX Subsection "CLOSING THE HANDLE"
The handle is closed when it is reaped by the garbage collector.
Because libguestfs handles include a lot of state, it is also
possible to close (and hence free) them explicitly by calling
the \f(CW\*(C`close\*(C'\fR method.
.SS "\s-1EXCEPTIONS\s0"
.IX Subsection "EXCEPTIONS"
Errors from libguestfs functions are mapped into the
\&\f(CW\*(C`LibGuestFSException\*(C'\fR exception.  This has a single parameter which
is the error message (a \f(CW\*(C`String\*(C'\fR).
.PP
Calling any method on a closed handle raises the same exception.
.SS "\s-1EVENTS\s0"
.IX Subsection "EVENTS"
The libguestfs event \s-1API\s0 is fully supported from
Java.  Create a class which implements the \f(CW\*(C`EventCallback\*(C'\fR interface,
create an instance of this class, and then call the \f(CW\*(C`GuestFS#set_event_callback\*(C'\fR
method to register this instance.  The \f(CW\*(C`event\*(C'\fR method of the class is
called when libguestfs generates an event.
.PP
For example, this will print all trace events:
.PP
.Vb 10
\& GuestFS g = new GuestFS ();
\& g.set_trace (true);
\& g.set_event_callback (
\&   new EventCallback () {
\&     public void event (long event, int eh,
\&                        String buffer, long[] array) {
\&       System.out.println (GuestFS.eventToString (event) +
\&                           ": " + buffer);
\&     }
\&   },
\&   GuestFS.EVENT_TRACE);
\& g.add_drive_ro ("disk.img");
\& // etc.
.Ve
.PP
The output looks similar to this:
.PP
.Vb 3
\& EVENT_TRACE: add_drive_ro "disk.img"
\& EVENT_TRACE: add_drive_ro = 0
\& // etc.
.Ve
.SS "\s-1OPTIONAL\s0 \s-1ARGUMENTS\s0"
.IX Subsection "OPTIONAL ARGUMENTS"
Some methods take an optional map of optional parameters.  An example
of this is \f(CW\*(C`g.add_drive\*(C'\fR which can be called in one of two ways:
.PP
.Vb 1
\& g.add_drive ("disk.img");
.Ve
.PP
or with optional arguments:
.PP
.Vb 8
\& Map<String, Object> optargs =
\&   new HashMap<String, Object>() {
\&   {
\&     put ("readonly", Boolean.TRUE);
\&     put ("format", "raw");
\&   }
\& };
\& g.add_drive ("disk.img", optargs);
.Ve
.PP
For more information on this topic, see
\&\*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
\fIOptional handle parameters\fR
.IX Subsection "Optional handle parameters"
.PP
When creating the handle you can also pass a map of optional
parameters:
.PP
.Vb 8
\& Map<String, Object> optargs =
\&   new HashMap<String, Object>() {
\&   {
\&     put ("close_on_exit", Boolean.FALSE);
\&     put ("environment", Boolean.TRUE);
\&   }
\& };
\& GuestFS g = new GuestFS (optargs);
.Ve
.PP
For more information, see \*(L"guestfs_create_flags\*(R" in \fIguestfs\fR\|(3).
.SH "COMPILING AND RUNNING"
.IX Header "COMPILING AND RUNNING"
Libguestfs for Java is a Java Native Interface (\s-1JNI\s0) extension,
supplied in three parts:
.IP "\fIlibguestfs.jar\fR" 4
.IX Item "libguestfs.jar"
.PD 0
.IP "\fIlibguestfs\-\fI\s-1VERSION\s0\fI.jar\fR" 4
.IX Item "libguestfs-VERSION.jar"
.PD
The pure Java \s-1JAR\s0 file which contains several classes, the primary one
being \f(CW\*(C`com.redhat.et.libguestfs.GuestFS\*(C'\fR.  Upstream, the \s-1JAR\s0 file
contains a version number in the filename, but some Linux distros may
rename it without the version number.
.IP "\fIlibguestfs_jni.so\fR" 4
.IX Item "libguestfs_jni.so"
The \s-1JNI\s0 code (written in C).  This contains private native functions
that interface between Java code and the regular libguestfs C library.
You should \fBnot\fR call these directly.
.IP "\fIlibguestfs.so\fR" 4
.IX Item "libguestfs.so"
The regular libguestfs C library.
.PP
To compile your Java program, you need to locate the \s-1JAR\s0 file and add
it to the class path.  For example:
.PP
.Vb 2
\& export CLASSPATH=/usr/share/java/libguestfs.jar
\& javac MyProgram.java
.Ve
.PP
To run your Java program, you also need to ensure that the \s-1JAR\s0 file is
on the class path, as well as the path of your program.  For example:
.PP
.Vb 2
\& export CLASSPATH=.:/usr/share/java/libguestfs.jar
\& java MyProgram
.Ve
.SH "EXAMPLE 1: CREATE A DISK IMAGE"
.IX Header "EXAMPLE 1: CREATE A DISK IMAGE"
.Vb 1
\& // Example showing how to create a disk image.
\& 
\& import java.io.*;
\& import java.util.Map;
\& import java.util.HashMap;
\& import com.redhat.et.libguestfs.*;
\& 
\& public class CreateDisk
\& {
\&     static String output = "disk.img";
\& 
\&     public static void main (String[] argv)
\&     {
\&         try {
\&             GuestFS g = new GuestFS ();
\& 
\&             // Create a raw\-format sparse disk image, 512 MB in size.
\&             RandomAccessFile f = new RandomAccessFile (output, "rw");
\&             f.setLength (512 * 1024 * 1024);
\&             f.close ();
\& 
\&             // Set the trace flag so that we can see each libguestfs call.
\&             g.set_trace (true);
\& 
\&             // Attach the disk image to libguestfs.
\&             @SuppressWarnings("serial") Map<String, Object> optargs =
\&                 new HashMap<String, Object>() {
\&                 {
\&                     put ("format", "raw");
\&                     put ("readonly", Boolean.FALSE);
\&                 }
\&             };
\&             g.add_drive_opts (output, optargs);
\& 
\&             // Run the libguestfs back\-end.
\&             g.launch ();
\& 
\&             // Get the list of devices.  Because we only added one drive
\&             // above, we expect that this list should contain a single
\&             // element.
\&             String[] devices = g.list_devices ();
\&             if (devices.length != 1)
\&                 throw new Error ("expected a single device from list\-devices");
\& 
\&             // Partition the disk as one single MBR partition.
\&             g.part_disk (devices[0], "mbr");
\& 
\&             // Get the list of partitions.  We expect a single element, which
\&             // is the partition we have just created.
\&             String[] partitions = g.list_partitions ();
\&             if (partitions.length != 1)
\&                 throw new Error ("expected a single partition from list\-partitions");
\& 
\&             // Create a filesystem on the partition.
\&             g.mkfs ("ext4", partitions[0]);
\& 
\&             // Now mount the filesystem so that we can add files.
\&             g.mount (partitions[0], "/");
\& 
\&             // Create some files and directories.
\&             g.touch ("/empty");
\&             String message = "Hello, world\en";
\&             g.write ("/hello", message.getBytes());
\&             g.mkdir ("/foo");
\& 
\&             // This one uploads the local file /etc/resolv.conf into
\&             // the disk image.
\&             g.upload ("/etc/resolv.conf", "/foo/resolv.conf");
\& 
\&             // Because we wrote to the disk and we want to detect write
\&             // errors, call g.shutdown.  You don\*(Aqt need to do this:
\&             // g.close will do it implicitly.
\&             g.shutdown ();
\& 
\&             // Note also that handles are automatically closed if they are
\&             // reaped by the garbage collector.  You only need to call close
\&             // if you want to close the handle right away.
\&             g.close ();
\&         }
\&         catch (Exception exn) {
\&             System.err.println (exn);
\&             System.exit (1);
\&         }
\&     }
\& }
.Ve
.SH "EXAMPLE 2: INSPECT A VIRTUAL MACHINE DISK IMAGE"
.IX Header "EXAMPLE 2: INSPECT A VIRTUAL MACHINE DISK IMAGE"
.Vb 1
\& // Example showing how to inspect a virtual machine disk.
\& 
\& import java.util.ArrayList;
\& import java.util.Collections;
\& import java.util.Comparator;
\& import java.util.HashMap;
\& import java.util.List;
\& import java.util.Map;
\& import com.redhat.et.libguestfs.*;
\& 
\& public class InspectVM
\& {
\&     static final Comparator<String> COMPARE_KEYS_LEN =
\&         new Comparator<String>() {
\&         public int compare (String k1, String k2) {
\&             return k1.length() \- k2.length();
\&         }
\&     };
\& 
\&     public static void main (String[] argv)
\&     {
\&         try {
\&             if (argv.length != 1)
\&                 throw new Error ("usage: InspectVM disk.img");
\& 
\&             String disk = argv[0];
\& 
\&             GuestFS g = new GuestFS ();
\& 
\&             // Attach the disk image read\-only to libguestfs.
\&             @SuppressWarnings("serial") Map<String, Object> optargs =
\&                 new HashMap<String, Object>() {
\&                 {
\&                     //put ("format", "raw");
\&                     put ("readonly", Boolean.TRUE);
\&                 }
\&             };
\& 
\&             g.add_drive_opts (disk, optargs);
\& 
\&             // Run the libguestfs back\-end.
\&             g.launch ();
\& 
\&             // Ask libguestfs to inspect for operating systems.
\&             String roots[] = g.inspect_os ();
\&             if (roots.length == 0)
\&                 throw new Error ("inspect_vm: no operating systems found");
\& 
\&             for (String root : roots) {
\&                 System.out.println ("Root device: " + root);
\& 
\&                 // Print basic information about the operating system.
\&                 System.out.println ("  Product name: " +
\&                                     g.inspect_get_product_name (root));
\&                 System.out.println ("  Version:      " +
\&                                     g.inspect_get_major_version (root) +
\&                                     "." +
\&                                     g.inspect_get_minor_version (root));
\&                 System.out.println ("  Type:         " +
\&                                     g.inspect_get_type (root));
\&                 System.out.println ("  Distro:       " +
\&                                     g.inspect_get_distro (root));
\& 
\&                 // Mount up the disks, like guestfish \-i.
\&                 //
\&                 // Sort keys by length, shortest first, so that we end up
\&                 // mounting the filesystems in the correct order.
\&                 Map<String,String> mps = g.inspect_get_mountpoints (root);
\&                 List<String> mps_keys = new ArrayList<String> (mps.keySet ());
\&                 Collections.sort (mps_keys, COMPARE_KEYS_LEN);
\& 
\&                 for (String mp : mps_keys) {
\&                     String dev = mps.get (mp);
\&                     try {
\&                         g.mount_ro (dev, mp);
\&                     }
\&                     catch (Exception exn) {
\&                         System.err.println (exn + " (ignored)");
\&                     }
\&                 }
\& 
\&                 // If /etc/issue.net file exists, print up to 3 lines.
\&                 String filename = "/etc/issue.net";
\&                 if (g.is_file (filename)) {
\&                     System.out.println ("\-\-\- " + filename + " \-\-\-");
\&                     String[] lines = g.head_n (3, filename);
\&                     for (String line : lines)
\&                         System.out.println (line);
\&                 }
\& 
\&                 // Unmount everything.
\&                 g.umount_all ();
\&             }
\&         }
\&         catch (Exception exn) {
\&             System.err.println (exn);
\&             System.exit (1);
\&         }
\&     }
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIguestfs\fR\|(3),
\&\fIguestfs\-examples\fR\|(3),
\&\fIguestfs\-erlang\fR\|(3),
\&\fIguestfs\-golang\fR\|(3),
\&\fIguestfs\-lua\fR\|(3),
\&\fIguestfs\-ocaml\fR\|(3),
\&\fIguestfs\-perl\fR\|(3),
\&\fIguestfs\-python\fR\|(3),
\&\fIguestfs\-recipes\fR\|(1),
\&\fIguestfs\-ruby\fR\|(3),
http://libguestfs.org/,
http://caml.inria.fr/.
.SH "AUTHORS"
.IX Header "AUTHORS"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2011\-2012 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
This manual page contains examples which we hope you will use in
your programs.  The examples may be freely copied, modified and
distributed for any purpose without any restrictions.
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
