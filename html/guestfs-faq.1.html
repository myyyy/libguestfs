
<html>
<head>
<title>guestfs-faq</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel='stylesheet' href='pod.css' type='text/css' />
</head>
<body>


<ul id="index">
  <li><a href="#name">NAME</a></li>
  <li><a href="#about-libguestfs">ABOUT LIBGUESTFS</a>
    <ul>
      <li><a href="#what-is-libguestfs-">What is libguestfs?</a></li>
      <li><a href="#what-are-the-virt-tools-">What are the virt tools?</a></li>
      <li><a href="#does-libguestfs-need-libvirt-kvm-red-hat-fedora-">Does libguestfs need { libvirt / KVM / Red Hat / Fedora }?</a></li>
      <li><a href="#how-does-libguestfs-compare-to-other-tools-">How does libguestfs compare to other tools?</a></li>
    </ul>
  </li>
  <li><a href="#getting-help-and-reporting-bugs">GETTING HELP AND REPORTING BUGS</a>
    <ul>
      <li><a href="#how-do-i-know-what-version-im-using-">How do I know what version I&#39;m using?</a></li>
      <li><a href="#how-can-i-get-help-">How can I get help?</a></li>
      <li><a href="#what-mailing-lists-or-chat-rooms-are-available-">What mailing lists or chat rooms are available?</a></li>
      <li><a href="#how-do-i-report-bugs-">How do I report bugs?</a></li>
    </ul>
  </li>
  <li><a href="#common-problems">COMMON PROBLEMS</a>
    <ul>
      <li><a href="#could-not-allocate-dynamic-translator-buffer">&quot;Could not allocate dynamic translator buffer&quot;</a></li>
      <li><a href="#child-process-died-unexpectedly">&quot;child process died unexpectedly&quot;</a></li>
      <li><a href="#libguestfs:-error:-cannot-find-any-suitable-libguestfs-supermin-fixed-or-old-style-appliance-on-libguestfs_path">libguestfs: error: cannot find any suitable libguestfs supermin, fixed or old-style appliance on LIBGUESTFS_PATH</a></li>
      <li><a href="#febootstrap-supermin-helper:-ext2:-parent-directory-not-found">febootstrap-supermin-helper: ext2: parent directory not found</a></li>
      <li><a href="#supermin-helper:-ext2:-parent-directory-not-found">supermin-helper: ext2: parent directory not found</a></li>
      <li><a href="#permission-denied-when-running-libguestfs-as-root">&quot;Permission denied&quot; when running libguestfs as root</a></li>
      <li><a href="#execl:-init:-permission-denied">execl: /init: Permission denied</a></li>
    </ul>
  </li>
  <li><a href="#downloading-installing-compiling-libguestfs">DOWNLOADING, INSTALLING, COMPILING LIBGUESTFS</a>
    <ul>
      <li><a href="#where-can-i-get-the-latest-binaries-for-...-">Where can I get the latest binaries for ...?</a></li>
      <li><a href="#how-can-i-compile-and-install-libguestfs-from-source-">How can I compile and install libguestfs from source?</a></li>
      <li><a href="#how-can-i-compile-and-install-libguestfs-if-my-distro-doesnt-have-new-enough-qemu-supermin-kernel-">How can I compile and install libguestfs if my distro doesn&#39;t have new enough qemu/supermin/kernel?</a></li>
      <li><a href="#how-can-i-compile-and-install-libguestfs-without-supermin-">How can I compile and install libguestfs without supermin?</a></li>
      <li><a href="#how-can-i-add-support-for-svirt-">How can I add support for sVirt?</a></li>
      <li><a href="#libguestfs-has-a-really-long-list-of-dependencies-">Libguestfs has a really long list of dependencies!</a></li>
      <li><a href="#errors-during-launch-on-fedora-18-rhel-7">Errors during launch on Fedora &ge; 18, RHEL &ge; 7</a></li>
      <li><a href="#how-can-i-switch-to-a-fixed-prebuilt-appliance-">How can I switch to a fixed / prebuilt appliance?</a></li>
      <li><a href="#how-can-i-speed-up-libguestfs-builds-">How can I speed up libguestfs builds?</a>
        <ul>
          <li><a href="#how-can-i-speed-up-libguestfs-builds-debian-">How can I speed up libguestfs builds (Debian)?</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#speed-disk-space-used-by-libguestfs">SPEED, DISK SPACE USED BY LIBGUESTFS</a>
    <ul>
      <li><a href="#upload-or-write-seem-very-slow.">Upload or write seem very slow.</a></li>
      <li><a href="#libguestfs-uses-too-much-disk-space-">Libguestfs uses too much disk space!</a></li>
      <li><a href="#virt-sparsify-seems-to-make-the-image-grow-to-the-full-size-of-the-virtual-disk">virt-sparsify seems to make the image grow to the full size of the virtual disk</a></li>
      <li><a href="#why-doesnt-virt-resize-work-on-the-disk-image-in-place-">Why doesn&#39;t virt-resize work on the disk image in-place?</a></li>
      <li><a href="#why-doesnt-virt-sparsify-work-on-the-disk-image-in-place-">Why doesn&#39;t virt-sparsify work on the disk image in-place?</a></li>
    </ul>
  </li>
  <li><a href="#problems-opening-disk-images">PROBLEMS OPENING DISK IMAGES</a>
    <ul>
      <li><a href="#remote-libvirt-guests-cannot-be-opened.">Remote libvirt guests cannot be opened.</a></li>
      <li><a href="#how-can-i-open-this-strange-disk-source-">How can I open this strange disk source?</a></li>
      <li><a href="#error-opening-vmdk-disks:-uses-a-vmdk-feature-which-is-not-supported-by-this-qemu-version:-vmdk-version-3">Error opening VMDK disks: &quot;uses a vmdk feature which is not supported by this qemu version: VMDK version 3&quot;</a></li>
      <li><a href="#ufs-disks-as-used-by-bsd-cannot-be-opened.">UFS disks (as used by BSD) cannot be opened.</a></li>
      <li><a href="#windows-refs">Windows ReFS</a></li>
      <li><a href="#non-ascii-characters-dont-appear-on-vfat-filesystems.">Non-ASCII characters don&#39;t appear on VFAT filesystems.</a></li>
      <li><a href="#non-ascii-characters-appear-as-underscore-_-on-iso9660-filesystems.">Non-ASCII characters appear as underscore (_) on ISO9660 filesystems.</a></li>
      <li><a href="#cannot-open-windows-guests-which-use-ntfs.">Cannot open Windows guests which use NTFS.</a></li>
      <li><a href="#cannot-open-or-inspect-rhel-7-guests.">Cannot open or inspect RHEL 7 guests.</a></li>
      <li><a href="#cannot-open-linux-guests-which-use-xfs.">Cannot open Linux guests which use XFS.</a></li>
    </ul>
  </li>
  <li><a href="#using-libguestfs-in-your-own-programs">USING LIBGUESTFS IN YOUR OWN PROGRAMS</a>
    <ul>
      <li><a href="#the-api-has-hundreds-of-methods-where-do-i-start-">The API has hundreds of methods, where do I start?</a></li>
      <li><a href="#can-i-use-libguestfs-in-my-proprietary-closed-source-commercial-program-">Can I use libguestfs in my proprietary / closed source / commercial program?</a></li>
    </ul>
  </li>
  <li><a href="#debugging-libguestfs">DEBUGGING LIBGUESTFS</a>
    <ul>
      <li><a href="#help-its-not-working-">Help, it&#39;s not working!</a></li>
      <li><a href="#how-do-i-debug-when-using-any-libguestfs-program-or-tool-eg.-virt-v2v-or-virt-df-">How do I debug when using any libguestfs program or tool (eg. virt-v2v or virt-df)?</a></li>
      <li><a href="#how-do-i-debug-when-using-guestfish-">How do I debug when using guestfish?</a></li>
      <li><a href="#how-do-i-debug-when-using-the-api-">How do I debug when using the API?</a></li>
      <li><a href="#how-do-i-capture-debug-output-and-put-it-into-my-logging-system-">How do I capture debug output and put it into my logging system?</a></li>
      <li><a href="#digging-deeper-into-the-appliance-boot-process.">Digging deeper into the appliance boot process.</a></li>
      <li><a href="#libguestfs-hangs-or-fails-during-run-launch.">libguestfs hangs or fails during run/launch.</a></li>
      <li><a href="#debugging-libvirt">Debugging libvirt</a></li>
    </ul>
  </li>
  <li><a href="#design-internals-of-libguestfs">DESIGN/INTERNALS OF LIBGUESTFS</a>
    <ul>
      <li><a href="#why-dont-you-do-everything-through-the-fuse-filesystem-interface-">Why don&#39;t you do everything through the FUSE / filesystem interface?</a></li>
      <li><a href="#why-dont-you-do-everything-through-gvfs-">Why don&#39;t you do everything through GVFS?</a></li>
      <li><a href="#why-can-i-write-to-the-disk-even-though-i-added-it-read-only-">Why can I write to the disk, even though I added it read-only?</a></li>
      <li><a href="#why-does---ro-appear-to-have-no-effect-">Why does <code>--ro</code> appear to have no effect?</a></li>
      <li><a href="#does---ro-make-all-disks-read-only-">Does <code>--ro</code> make all disks read-only?</a></li>
      <li><a href="#can-i-use-guestfish---ro-as-a-way-to-backup-my-virtual-machines-">Can I use <code>guestfish --ro</code> as a way to backup my virtual machines?</a></li>
      <li><a href="#why-cant-i-run-fsck-on-a-live-filesystem-using-guestfish---ro-">Why can&#39;t I run fsck on a live filesystem using <code>guestfish --ro</code>?</a></li>
      <li><a href="#whats-the-difference-between-guestfish-and-virt-rescue-">What&#39;s the difference between guestfish and virt-rescue?</a></li>
      <li><a href="#whats-the-deal-with-guestfish--i-">What&#39;s the deal with <code>guestfish -i</code>?</a></li>
      <li><a href="#why-does-virt-cat-only-work-on-a-real-vm-image-but-virt-df-works-on-any-disk-image-">Why does virt-cat only work on a real VM image, but virt-df works on any disk image?</a></li>
      <li><a href="#what-does-no-root-device-found-in-this-operating-system-image-mean-">What does &quot;no root device found in this operating system image&quot; mean?</a></li>
      <li><a href="#what-do-these-debug-and-internal--functions-do-">What do these <code>debug*</code> and <code>internal-*</code> functions do?</a></li>
    </ul>
  </li>
  <li><a href="#developers">DEVELOPERS</a>
    <ul>
      <li><a href="#where-do-i-send-patches-">Where do I send patches?</a></li>
      <li><a href="#how-do-i-propose-a-feature-">How do I propose a feature?</a></li>
      <li><a href="#who-can-commit-to-libguestfs-git-">Who can commit to libguestfs git?</a></li>
      <li><a href="#can-i-fork-libguestfs-">Can I fork libguestfs?</a></li>
    </ul>
  </li>
  <li><a href="#miscellaneous-questions">MISCELLANEOUS QUESTIONS</a>
    <ul>
      <li><a href="#can-i-monitor-the-live-disk-activity-of-a-virtual-machine-using-libguestfs-">Can I monitor the live disk activity of a virtual machine using libguestfs?</a></li>
    </ul>
  </li>
  <li><a href="#see-also">SEE ALSO</a></li>
  <li><a href="#authors">AUTHORS</a></li>
  <li><a href="#copyright">COPYRIGHT</a></li>
  <li><a href="#license">LICENSE</a></li>
  <li><a href="#bugs">BUGS</a></li>
</ul>

<h1 id="name">NAME</h1>

<p>guestfs-faq - libguestfs Frequently Asked Questions (FAQ)</p>

<h1 id="about-libguestfs">ABOUT LIBGUESTFS</h1>

<h2 id="what-is-libguestfs-">What is libguestfs?</h2>

<p>libguestfs is a way to create, access and modify disk images. You can look inside disk images, modify the files they contain, create them from scratch, resize them, and much more. It&#39;s especially useful from scripts and programs and from the command line.</p>

<p>libguestfs is a C library (hence &quot;lib-&quot;), and a set of tools built on this library, and bindings for many common programming languages.</p>

<p>For more information about what libguestfs can do read the introduction on the home page (<a href="http://libguestfs.org">http://libguestfs.org</a>).</p>

<h2 id="what-are-the-virt-tools-">What are the virt tools?</h2>

<p>Virt tools (website: <a href="http://virt-tools.org">http://virt-tools.org</a>) are a whole set of virtualization management tools aimed at system administrators. Some of them come from libguestfs, some from libvirt and many others from other open source projects. So virt tools is a superset of libguestfs. However libguestfs comes with many important tools. See <a href="http://libguestfs.org">http://libguestfs.org</a> for a full list.</p>

<h2 id="does-libguestfs-need-libvirt-kvm-red-hat-fedora-">Does libguestfs need { libvirt / KVM / Red Hat / Fedora }?</h2>

<p>No!</p>

<p>libvirt is not a requirement for libguestfs.</p>

<p>libguestfs works with any disk image, including ones created in VMware, KVM, qemu, VirtualBox, Xen, and many other hypervisors, and ones which you have created from scratch.</p>

<p><span style="white-space: nowrap;">Red Hat</span> sponsors (ie. pays for) development of libguestfs and a huge number of other open source projects. But you can run libguestfs and the virt tools on many different Linux distros and Mac OS X. We try our best to support all Linux distros as first-class citizens. Some virt tools have been ported to Windows.</p>

<h2 id="how-does-libguestfs-compare-to-other-tools-">How does libguestfs compare to other tools?</h2>

<dl>

<dt><i>vs. kpartx</i></dt>
<dd>

<p>Libguestfs takes a different approach from kpartx. kpartx needs root, and mounts filesystems on the host kernel (which can be insecure - see <a href="guestfs.3.html#security">&quot;SECURITY&quot; in guestfs(3)</a>). Libguestfs isolates your host kernel from guests, is more flexible, scriptable, supports LVM, doesn&#39;t require root, is isolated from other processes, and cleans up after itself. Libguestfs is more than just file access because you can use it to create images from scratch.</p>

</dd>
<dt><i>vs. vdfuse</i></dt>
<dd>

<p>vdfuse is like kpartx but for VirtualBox images. See the kpartx comparison above. You can use libguestfs on the partition files exposed by vdfuse, although it&#39;s not necessary since libguestfs can access VirtualBox images directly.</p>

</dd>
<dt><i>vs. qemu-nbd</i></dt>
<dd>

<p>NBD (Network Block Device) is a protocol for exporting block devices over the network. qemu-nbd is an NBD server which can handle any disk format supported by qemu (eg. raw, qcow2). You can use libguestfs and qemu-nbd or nbdkit together to access block devices over the network, for example: <code>guestfish -a nbd://remote</code></p>

</dd>
<dt><i>vs. mounting filesystems in the host</i></dt>
<dd>

<p>Mounting guest filesystems in the host is insecure and should be avoided completely for untrusted guests. Use libguestfs to provide a layer of protection against filesystem exploits. See also <a href="guestmount.1.html">guestmount(1)</a>.</p>

</dd>
<dt><i>vs. parted</i></dt>
<dd>

<p>Libguestfs supports LVM. Libguestfs uses parted and provides most parted features through the libguestfs API.</p>

</dd>
</dl>

<h1 id="getting-help-and-reporting-bugs">GETTING HELP AND REPORTING BUGS</h1>

<h2 id="how-do-i-know-what-version-im-using-">How do I know what version I&#39;m using?</h2>

<p>The simplest method is:</p>

<pre><code> guestfish --version</code></pre>

<p>Libguestfs development happens along an unstable branch and we periodically create a stable branch which we backport stable patches to. To find out more, read <a href="guestfs.3.html#libguestfs-version-numbers">&quot;LIBGUESTFS VERSION NUMBERS&quot; in guestfs(3)</a>.</p>

<h2 id="how-can-i-get-help-">How can I get help?</h2>

<h2 id="what-mailing-lists-or-chat-rooms-are-available-">What mailing lists or chat rooms are available?</h2>

<p>If you are a <span style="white-space: nowrap;">Red Hat</span> customer using Red Hat Enterprise Linux, please contact <span style="white-space: nowrap;">Red Hat Support</span>: <a href="http://redhat.com/support">http://redhat.com/support</a></p>

<p>There is a mailing list, mainly for development, but users are also welcome to ask questions about libguestfs and the virt tools: <a href="https://www.redhat.com/mailman/listinfo/libguestfs">https://www.redhat.com/mailman/listinfo/libguestfs</a></p>

<p>You can also talk to us on IRC channel <code>#libguestfs</code> on FreeNode. We&#39;re not always around, so please stay in the channel after asking your question and someone will get back to you.</p>

<p>For other virt tools (not ones supplied with libguestfs) there is a general virt tools mailing list: <a href="https://www.redhat.com/mailman/listinfo/virt-tools-list">https://www.redhat.com/mailman/listinfo/virt-tools-list</a></p>

<h2 id="how-do-i-report-bugs-">How do I report bugs?</h2>

<p>Please use the following link to enter a bug in Bugzilla:</p>

<p><a href="https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>Include as much detail as you can and a way to reproduce the problem.</p>

<p>Include the full output of <a href="libguestfs-test-tool.1.html">libguestfs-test-tool(1)</a>.</p>

<h1 id="common-problems">COMMON PROBLEMS</h1>

<p>See also <a href="guestfs.3.html#libguestfs-gotchas">&quot;LIBGUESTFS GOTCHAS&quot; in guestfs(3)</a> for some &quot;gotchas&quot; with using the libguestfs API.</p>

<h2 id="could-not-allocate-dynamic-translator-buffer">&quot;Could not allocate dynamic translator buffer&quot;</h2>

<p>This obscure error is in fact an SELinux failure. You have to enable the following SELinux boolean:</p>

<pre><code> setsebool -P virt_use_execmem=on</code></pre>

<p>For more information see <a href="https://bugzilla.redhat.com/show_bug.cgi?id=806106">https://bugzilla.redhat.com/show_bug.cgi?id=806106</a>.</p>

<h2 id="child-process-died-unexpectedly">&quot;child process died unexpectedly&quot;</h2>

<p>[This error message was changed in libguestfs 1.21.18 to something more explanatory.]</p>

<p>This error indicates that qemu failed or the host kernel could not boot. To get further information about the failure, you have to run:</p>

<pre><code> libguestfs-test-tool</code></pre>

<p>If, after using this, you still don&#39;t understand the failure, contact us (see previous section).</p>

<h2 id="libguestfs:-error:-cannot-find-any-suitable-libguestfs-supermin-fixed-or-old-style-appliance-on-libguestfs_path">libguestfs: error: cannot find any suitable libguestfs supermin, fixed or old-style appliance on LIBGUESTFS_PATH</h2>

<h2 id="febootstrap-supermin-helper:-ext2:-parent-directory-not-found">febootstrap-supermin-helper: ext2: parent directory not found</h2>

<h2 id="supermin-helper:-ext2:-parent-directory-not-found">supermin-helper: ext2: parent directory not found</h2>

<p>[This issue is fixed permanently in libguestfs &ge; 1.26.]</p>

<p>If you see any of these errors on Debian/Ubuntu, you need to run the following command:</p>

<pre><code> sudo update-guestfs-appliance</code></pre>

<h2 id="permission-denied-when-running-libguestfs-as-root">&quot;Permission denied&quot; when running libguestfs as root</h2>

<p>You get a permission denied error when opening a disk image, even though you are running libguestfs as root.</p>

<p>This is caused by libvirt, and so only happens when using the libvirt backend. When run as root, libvirt decides to run the qemu appliance as user <code>qemu.qemu</code>. Unfortunately this usually means that qemu cannot open disk images, especially if those disk images are owned by root, or are present in directories which require root access.</p>

<p>There is a bug open against libvirt to fix this: <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1045069">https://bugzilla.redhat.com/show_bug.cgi?id=1045069</a></p>

<p>You can work around this by one of the following methods:</p>

<ul>

<li><p>Switch to the direct backend:</p>

<pre><code> export LIBGUESTFS_BACKEND=direct</code></pre>

</li>
<li><p>Don&#39;t run libguestfs as root.</p>

</li>
<li><p>Chmod the disk image and any parent directories so that the qemu user can access them.</p>

</li>
<li><p>(Nasty) Edit <i>/etc/libvirt/qemu.conf</i> and change the <code>user</code> setting.</p>

</li>
</ul>

<h2 id="execl:-init:-permission-denied">execl: /init: Permission denied</h2>

<p><b>Note:</b> If this error happens when you are using a distro package of libguestfs (eg. from Fedora, Debian, etc) then file a bug against the distro. This is not an error which normal users should ever see if the distro package has been prepared correctly.</p>

<p>This error happens during the supermin boot phase of starting the appliance:</p>

<pre><code> supermin: mounting new root on /root
 supermin: chroot
 execl: /init: Permission denied
 supermin: debug: listing directory /
 [...followed by a lot of debug output...]</code></pre>

<p>This is a complicated bug related to <a href="supermin.1.html">supermin(1)</a> appliances. The appliance is constructed by copying files like <i>/bin/bash</i> and many libraries from the host. The file <code>hostfiles</code> lists the files that should be copied from the host into the appliance. If some files don&#39;t exist on the host then they are missed out, but if these files are needed in order to (eg) run <i>/bin/bash</i> then you&#39;ll see the above error.</p>

<p>Diagnosing the problem involves studying the libraries needed by <i>/bin/bash</i>, ie:</p>

<pre><code> ldd /bin/bash</code></pre>

<p>comparing that with <code>hostfiles</code>, with the files actually available in the host filesystem, and with the debug output printed in the error message. Once you&#39;ve worked out which file is missing, install that file using your package manager and try again.</p>

<p>You should also check that files like <i>/init</i> and <i>/bin/bash</i> (in the appliance) are executable. The debug output shows file modes.</p>

<h1 id="downloading-installing-compiling-libguestfs">DOWNLOADING, INSTALLING, COMPILING LIBGUESTFS</h1>



<!-- old anchor for the next section -->
<a name="binaries"/>

<h2 id="where-can-i-get-the-latest-binaries-for-...-">Where can I get the latest binaries for ...?</h2>

<dl>

<dt>Fedora &ge; 11</dt>
<dd>

<p>Use:</p>

<pre><code> yum install &#39;*guestf*&#39;</code></pre>

<p>For the latest builds, see: <a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=8391">http://koji.fedoraproject.org/koji/packageinfo?packageID=8391</a></p>

</dd>
<dt>Red Hat Enterprise Linux</dt>
<dd>

<dl>

<dt>RHEL 5</dt>
<dd>

<p>The version shipped in official RHEL 5 is very old and should not be used except in conjunction with virt-v2v. Use the up-to-date libguestfs 1.20 package in EPEL 5: <a href="https://fedoraproject.org/wiki/EPEL">https://fedoraproject.org/wiki/EPEL</a></p>

</dd>
<dt>RHEL 6</dt>
<dd>

</dd>
<dt>RHEL 7</dt>
<dd>

<p>It is part of the default install. On RHEL 6 and 7 (only) you have to install <code>libguestfs-winsupport</code> to get Windows guest support.</p>

</dd>
</dl>

</dd>
<dt>Debian and Ubuntu</dt>
<dd>

<p>For libguestfs &lt; 1.26, after installing libguestfs you need to do:</p>

<pre><code> sudo update-guestfs-appliance</code></pre>

<p>(This script has been removed on Debian/Ubuntu with libguestfs &ge; 1.26 and instead the appliance is built on demand.)</p>

<p>On Ubuntu only:</p>

<pre><code> sudo chmod 0644 /boot/vmlinuz*</code></pre>

<p>You may need to add yourself to the <code>kvm</code> group:</p>

<pre><code> sudo usermod -a -G kvm yourlogin</code></pre>

<dl>

<dt>Debian Squeeze (6)</dt>
<dd>

<p>Hilko Bengen has built libguestfs in squeeze backports: <a href="http://packages.debian.org/search?keywords=guestfs&amp;searchon=names&amp;section=all&amp;suite=squeeze-backports">http://packages.debian.org/search?keywords=guestfs&amp;searchon=names&amp;section=all&amp;suite=squeeze-backports</a></p>

</dd>
<dt>Debian Wheezy and later (7+)</dt>
<dd>

<p>Hilko Bengen supports libguestfs on Debian. Official Debian packages are available: <a href="http://packages.debian.org/search?keywords=libguestfs">http://packages.debian.org/search?keywords=libguestfs</a></p>

</dd>
<dt>Ubuntu</dt>
<dd>

<p>We don&#39;t have a full time Ubuntu maintainer, and the packages supplied by Canonical (which are outside our control) are sometimes broken.</p>

<p>Canonical decided to change the permissions on the kernel so that it&#39;s not readable except by root. This is completely stupid, but they won&#39;t change it (<a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/759725">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/759725</a>). So every user should do this:</p>

<pre><code> sudo chmod 0644 /boot/vmlinuz*</code></pre>

<dl>

<dt>Ubuntu 12.04</dt>
<dd>

<p>libguestfs in this version of Ubuntu works, but you need to update febootstrap and seabios to the latest versions.</p>

<p>You need febootstrap &ge; 3.14-2 from: <a href="http://packages.ubuntu.com/precise/febootstrap">http://packages.ubuntu.com/precise/febootstrap</a></p>

<p>After installing or updating febootstrap, rebuild the appliance:</p>

<pre><code> sudo update-guestfs-appliance</code></pre>

<p>You need seabios &ge; 0.6.2-0ubuntu2.1 or &ge; 0.6.2-0ubuntu3 from: <a href="http://packages.ubuntu.com/precise-updates/seabios">http://packages.ubuntu.com/precise-updates/seabios</a> or <a href="http://packages.ubuntu.com/quantal/seabios">http://packages.ubuntu.com/quantal/seabios</a></p>

<p>Also you need to do (see above):</p>

<pre><code> sudo chmod 0644 /boot/vmlinuz*</code></pre>

</dd>
</dl>

</dd>
</dl>

</dd>
<dt>Gentoo</dt>
<dd>

<p>Libguestfs was added to Gentoo in 2012-07 by Andreis Vinogradovs (libguestfs) and Maxim Koltsov (mainly hivex). Do:</p>

<pre><code> emerge libguestfs</code></pre>

</dd>
<dt>SuSE</dt>
<dd>

<p>Libguestfs was added to SuSE in 2012 by Olaf Hering.</p>

</dd>
<dt>ArchLinux</dt>
<dd>

<p>Libguestfs was added to the AUR in 2010.</p>

</dd>
<dt>Other Linux distro</dt>
<dd>

<p>Compile from source (next section).</p>

</dd>
<dt>Other non-Linux distro</dt>
<dd>

<p>You&#39;ll have to compile from source, and port it.</p>

</dd>
</dl>

<h2 id="how-can-i-compile-and-install-libguestfs-from-source-">How can I compile and install libguestfs from source?</h2>

<p>You can compile libguestfs from git or a source tarball. Read the README file before starting.</p>

<p>Git: <a href="https://github.com/libguestfs/libguestfs">https://github.com/libguestfs/libguestfs</a> Source tarballs: <a href="http://libguestfs.org/download">http://libguestfs.org/download</a></p>

<p>Don&#39;t run <code>make install</code>! Use the <code>./run</code> script instead (see README).</p>

<h2 id="how-can-i-compile-and-install-libguestfs-if-my-distro-doesnt-have-new-enough-qemu-supermin-kernel-">How can I compile and install libguestfs if my distro doesn&#39;t have new enough qemu/supermin/kernel?</h2>

<p>Libguestfs needs supermin 5. If supermin 5 hasn&#39;t been ported to your distro, then see the question below.</p>

<p>First compile qemu, supermin and/or the kernel from source. You do <i>not</i> need to <code>make install</code> them.</p>

<p>In the libguestfs source directory, create two files. <code>localconfigure</code> should contain:</p>

<pre><code> source localenv
 #export PATH=/tmp/qemu/x86_64-softmmu:$PATH
 ./autogen.sh --prefix /usr &quot;$@&quot;</code></pre>

<p>Make <code>localconfigure</code> executable.</p>

<p><code>localenv</code> should contain:</p>

<pre><code> #export SUPERMIN=/tmp/supermin/src/supermin
 #export LIBGUESTFS_HV=/tmp/qemu/x86_64-softmmu/qemu-system-x86_64
 #export SUPERMIN_KERNEL=/tmp/linux/arch/x86/boot/bzImage
 #export SUPERMIN_KERNEL_VERSION=4.XX.0
 #export SUPERMIN_MODULES=/tmp/lib/modules/4.XX.0</code></pre>

<p>Uncomment and adjust these lines as required to use the alternate programs you have compiled.</p>

<p>Use <code>./localconfigure</code> instead of <code>./configure</code>, but otherwise you compile libguestfs as usual.</p>

<p>Don&#39;t run <code>make install</code>! Use the <code>./run</code> script instead (see README).</p>

<h2 id="how-can-i-compile-and-install-libguestfs-without-supermin-">How can I compile and install libguestfs without supermin?</h2>

<p>If supermin 5 supports your distro, but you don&#39;t happen to have a new enough supermin installed, then see the previous question.</p>

<p>If supermin 5 doesn&#39;t support your distro at all, you will need to use the &quot;fixed appliance method&quot; where you use a pre-compiled binary appliance. To build libguestfs without supermin, you need to pass <code>--disable-appliance --disable-daemon</code> to either <i>./autogen.sh</i> or <i>./configure</i> (depending whether you are building respectively from git or from tarballs). Then, when using libguestfs, you <b>must</b> set the <code>LIBGUESTFS_PATH</code> environment variable to the directory of a pre-compiled appliance, as also described in <a href="guestfs.3.html#fixed-appliance">&quot;FIXED APPLIANCE&quot; in guestfs(3)</a>.</p>

<p>For pre-compiled appliances, see also: <a href="http://libguestfs.org/download/binaries/appliance/">http://libguestfs.org/download/binaries/appliance/</a>.</p>

<p>Patches to port supermin to more Linux distros are welcome.</p>

<h2 id="how-can-i-add-support-for-svirt-">How can I add support for sVirt?</h2>

<p><b>Note for Fedora/RHEL users:</b> This configuration is the default starting with <span style="white-space: nowrap;">Fedora 18</span> and <span style="white-space: nowrap;">RHEL 7</span>. If you find any problems, please let us know or file a bug.</p>

<p><a href="http://selinuxproject.org/page/SVirt">SVirt</a> provides a hardened appliance using SELinux, making it very hard for a rogue disk image to &quot;escape&quot; from the confinement of libguestfs and damage the host (it&#39;s fair to say that even in standard libguestfs this would be hard, but sVirt provides an extra layer of protection for the host and more importantly protects virtual machines on the same host from each other).</p>

<p>Currently to enable sVirt you will need libvirt &ge; 0.10.2 (1.0 or later preferred), libguestfs &ge; 1.20, and the SELinux policies from recent Fedora. If you are not running <span style="white-space: nowrap;">Fedora 18+</span>, you will need to make changes to your SELinux policy - contact us on the mailing list.</p>

<p>Once you have the requirements, do:</p>

<pre><code> ./configure --with-default-backend=libvirt       # libguestfs &gt;= 1.22
 ./configure --with-default-attach-method=libvirt # libguestfs &lt;= 1.20
 make</code></pre>

<p>Set SELinux to Enforcing mode, and sVirt should be used automatically.</p>

<p>All, or almost all, features of libguestfs should work under sVirt. There is one known shortcoming: <a href="virt-rescue.1.html">virt-rescue(1)</a> will not use libvirt (hence sVirt), but falls back to direct launch of qemu. So you won&#39;t currently get the benefit of sVirt protection when using virt-rescue.</p>

<p>You can check if sVirt is being used by enabling libvirtd logging (see <i>/etc/libvirt/libvirtd.log</i>), killing and restarting libvirtd, and checking the log files for <span style="white-space: nowrap;">&quot;Setting SELinux context on ...&quot;</span> messages.</p>

<p>In theory sVirt should support AppArmor, but we have not tried it. It will almost certainly require patching libvirt and writing an AppArmor policy.</p>

<h2 id="libguestfs-has-a-really-long-list-of-dependencies-">Libguestfs has a really long list of dependencies!</h2>

<p>The base library doesn&#39;t depend on very much, but there are three causes of the long list of other dependencies:</p>

<ol>

<li><p>Libguestfs has to be able to read and edit many different disk formats. For example, XFS support requires XFS tools.</p>

</li>
<li><p>There are language bindings for many different languages, all requiring their own development tools. All language bindings (except C) are optional.</p>

</li>
<li><p>There are some optional library features which can be disabled.</p>

</li>
</ol>

<p>Since libguestfs &ge; 1.26 it is possible to split up the appliance dependencies (item 1 in the list above) and thus have (eg) <code>libguestfs-xfs</code> as a separate subpackage for processing XFS disk images. We encourage downstream packagers to start splitting the base libguestfs package into smaller subpackages.</p>

<h2 id="errors-during-launch-on-fedora-18-rhel-7">Errors during launch on Fedora &ge; 18, RHEL &ge; 7</h2>

<p>In Fedora &ge; 18 and RHEL &ge; 7, libguestfs uses libvirt to manage the appliance. Previously (and upstream) libguestfs runs qemu directly:</p>

<pre><code> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
 &#x2502; libguestfs                       &#x2502;
 &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
 &#x2502; direct backend &#x2502; libvirt backend &#x2502;
 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
        &darr;                  &darr;
    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;         &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
    &#x2502; qemu  &#x2502;         &#x2502; libvirtd &#x2502;
    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;         &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
                           &darr;
                       &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
                       &#x2502; qemu  &#x2502;
                       &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
 
    upstream          Fedora 18+
    non-Fedora         RHEL 7+
    non-RHEL</code></pre>

<p>The libvirt backend is more sophisticated, supporting SELinux/sVirt (see above), hotplugging and more. It is, however, more complex and so less robust.</p>

<p>If you have permissions problems using the libvirt backend, you can switch to the direct backend by setting this environment variable:</p>

<pre><code> export LIBGUESTFS_BACKEND=direct</code></pre>

<p>before running any libguestfs program or virt tool.</p>

<h2 id="how-can-i-switch-to-a-fixed-prebuilt-appliance-">How can I switch to a fixed / prebuilt appliance?</h2>

<p>This may improve the stability and performance of libguestfs on Fedora and RHEL.</p>

<p>Any time after installing libguestfs, run the following commands as root:</p>

<pre><code> mkdir -p /usr/local/lib/guestfs/appliance
 libguestfs-make-fixed-appliance /usr/local/lib/guestfs/appliance
 ls -l /usr/local/lib/guestfs/appliance</code></pre>

<p>Now set the following environment variable before using libguestfs or any virt tool:</p>

<pre><code> export LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance</code></pre>

<p>Of course you can change the path to any directory you want. You can share the appliance across machines that have the same architecture (eg. all x86-64), but note that libvirt will prevent you from sharing the appliance across NFS because of permissions problems (so either switch to the direct backend or don&#39;t use NFS).</p>

<h2 id="how-can-i-speed-up-libguestfs-builds-">How can I speed up libguestfs builds?</h2>

<p>By far the most important thing you can do is to install and properly configure Squid. Note that the default configuration that ships with Squid is rubbish, so configuring it is not optional.</p>

<p>A very good place to start with Squid configuration is here: <a href="https://fedoraproject.org/wiki/Extras/MockTricks#Using_Squid_to_Speed_Up_Mock_package_downloads">https://fedoraproject.org/wiki/Extras/MockTricks#Using_Squid_to_Speed_Up_Mock_package_downloads</a></p>

<p>Make sure Squid is running, and that the environment variables <code>$http_proxy</code> and <code>$ftp_proxy</code> are pointing to it.</p>

<p>With Squid running and correctly configured, appliance builds should be reduced to a few minutes.</p>

<h3 id="how-can-i-speed-up-libguestfs-builds-debian-">How can I speed up libguestfs builds (Debian)?</h3>

<p>Hilko Bengen suggests using &quot;approx&quot; which is a Debian archive proxy (<a href="http://packages.debian.org/approx">http://packages.debian.org/approx</a>). This tool is documented on Debian in the approx(8) manual page.</p>

<h1 id="speed-disk-space-used-by-libguestfs">SPEED, DISK SPACE USED BY LIBGUESTFS</h1>

<p><b>Note:</b> Most of the information in this section has moved: <a href="guestfs-performance.1.html">guestfs-performance(1)</a>.</p>

<h2 id="upload-or-write-seem-very-slow.">Upload or write seem very slow.</h2>

<p>If the underlying disk is not fully allocated (eg. sparse raw or qcow2) then writes can be slow because the host operating system has to do costly disk allocations while you are writing. The solution is to use a fully allocated format instead, ie. non-sparse raw, or qcow2 with the <code>preallocation=metadata</code> option.</p>

<h2 id="libguestfs-uses-too-much-disk-space-">Libguestfs uses too much disk space!</h2>

<p>libguestfs caches a large-ish appliance in:</p>

<pre><code> /var/tmp/.guestfs-&lt;UID&gt;</code></pre>

<p>If the environment variable <code>TMPDIR</code> is defined, then <i>$TMPDIR/.guestfs-&lt;UID&gt;</i> is used instead.</p>

<p>It is safe to delete this directory when you are not using libguestfs.</p>

<h2 id="virt-sparsify-seems-to-make-the-image-grow-to-the-full-size-of-the-virtual-disk">virt-sparsify seems to make the image grow to the full size of the virtual disk</h2>

<p>If the input to <a href="virt-sparsify.1.html">virt-sparsify(1)</a> is raw, then the output will be raw sparse. Make sure you are measuring the output with a tool which understands sparseness such as <code>du -sh</code>. It can make a huge difference:</p>

<pre><code> $ ls -lh test1.img
 -rw-rw-r--. 1 rjones rjones 100M Aug  8 08:08 test1.img
 $ du -sh test1.img
 3.6M   test1.img</code></pre>

<p>(Compare the apparent size <b>100M</b> vs the actual size <b>3.6M</b>)</p>

<p>If all this confuses you, use a non-sparse output format by specifying the <i>--convert</i> option, eg:</p>

<pre><code> virt-sparsify --convert qcow2 disk.raw disk.qcow2</code></pre>

<h2 id="why-doesnt-virt-resize-work-on-the-disk-image-in-place-">Why doesn&#39;t virt-resize work on the disk image in-place?</h2>

<p>Resizing a disk image is very tricky -- especially making sure that you don&#39;t lose data or break the bootloader. The current method effectively creates a new disk image and copies the data plus bootloader from the old one. If something goes wrong, you can always go back to the original.</p>

<p>If we were to make virt-resize work in-place then there would have to be limitations: for example, you wouldn&#39;t be allowed to move existing partitions (because moving data across the same disk is most likely to corrupt data in the event of a power failure or crash), and LVM would be very difficult to support (because of the almost arbitrary mapping between LV content and underlying disk blocks).</p>

<p>Another method we have considered is to place a snapshot over the original disk image, so that the original data is untouched and only differences are recorded in the snapshot. You can do this today using <code>qemu-img create</code> + <code>virt-resize</code>, but qemu currently isn&#39;t smart enough to recognize when the same block is written back to the snapshot as already exists in the backing disk, so you will find that this doesn&#39;t save you any space or time.</p>

<p>In summary, this is a hard problem, and what we have now mostly works so we are reluctant to change it.</p>

<h2 id="why-doesnt-virt-sparsify-work-on-the-disk-image-in-place-">Why doesn&#39;t virt-sparsify work on the disk image in-place?</h2>

<p>In libguestfs &ge; 1.26, virt-sparsify can now work on disk images in place. Use:</p>

<pre><code> virt-sparsify --in-place disk.img</code></pre>

<p>But first you should read <a href="virt-sparsify.1.html#in-place-sparsification">&quot;IN-PLACE SPARSIFICATION&quot; in virt-sparsify(1)</a>.</p>

<h1 id="problems-opening-disk-images">PROBLEMS OPENING DISK IMAGES</h1>

<h2 id="remote-libvirt-guests-cannot-be-opened.">Remote libvirt guests cannot be opened.</h2>

<p>Opening remote libvirt guests is not supported at this time. For example this won&#39;t work:</p>

<pre><code> guestfish -c qemu://remote/system -d Guest</code></pre>

<p>To open remote disks you have to export them somehow, then connect to the export. For example if you decided to use NBD:</p>

<pre><code> remote$ qemu-nbd -t -p 10809 guest.img
  local$ guestfish -a nbd://remote:10809 -i</code></pre>

<p>Other possibilities include ssh (if qemu is recent enough), NFS or iSCSI. See <a href="guestfs.3.html#remote-storage">&quot;REMOTE STORAGE&quot; in guestfs(3)</a>.</p>

<h2 id="how-can-i-open-this-strange-disk-source-">How can I open this strange disk source?</h2>

<p>You have a disk image located inside another system that requires access via a library / HTTP / REST / proprietary API, or is compressed or archived in some way. (One example would be remote access to OpenStack glance images without actually downloading them.)</p>

<p>We have a sister project called nbdkit (<a href="https://github.com/libguestfs/nbdkit">https://github.com/libguestfs/nbdkit</a>). This project lets you turn any disk source into an NBD server. Libguestfs can access NBD servers directly, eg:</p>

<pre><code> guestfish -a nbd://remote</code></pre>

<p>nbdkit is liberally licensed, so you can link it to or include it in proprietary libraries and code. It also has a simple, stable plugin API so you can easily write plugins against the API which will continue to work in future.</p>

<h2 id="error-opening-vmdk-disks:-uses-a-vmdk-feature-which-is-not-supported-by-this-qemu-version:-vmdk-version-3">Error opening VMDK disks: &quot;uses a vmdk feature which is not supported by this qemu version: VMDK version 3&quot;</h2>

<p>Qemu (and hence libguestfs) only supports certain VMDK disk images. Others won&#39;t work, giving this or similar errors.</p>

<p>Ideally someone would fix qemu to support the latest VMDK features, but in the meantime you have three options:</p>

<ol>

<li><p>If the guest is hosted on a live, reachable ESX server, then locate and download the disk image called <i><i>somename</i>-flat.vmdk</i>. Despite the name, this is a raw disk image, and can be opened by anything.</p>

<p>If you have a recent enough version of qemu and libguestfs, then you may be able to access this disk image remotely using either HTTPS or ssh. See <a href="guestfs.3.html#remote-storage">&quot;REMOTE STORAGE&quot; in guestfs(3)</a>.</p>

</li>
<li><p>Use VMware&#39;s proprietary vdiskmanager tool to convert the image to raw format.</p>

</li>
<li><p>Use nbdkit with the proprietary VDDK plugin to live export the disk image as an NBD source. This should allow you to read and write the VMDK file.</p>

</li>
</ol>

<h2 id="ufs-disks-as-used-by-bsd-cannot-be-opened.">UFS disks (as used by BSD) cannot be opened.</h2>

<p>The UFS filesystem format has many variants, and these are not self-identifying. The Linux kernel has to be told which variant of UFS it has to use, which libguestfs cannot know.</p>

<p>You have to pass the right <code>ufstype</code> mount option when mounting these filesystems.</p>

<p>See <a href="https://www.kernel.org/doc/Documentation/filesystems/ufs.txt">https://www.kernel.org/doc/Documentation/filesystems/ufs.txt</a></p>

<h2 id="windows-refs">Windows ReFS</h2>

<p>Windows ReFS is Microsoft&#39;s ZFS/Btrfs copy. This filesystem has not yet been reverse engineered and implemented in the Linux kernel, and therefore libguestfs doesn&#39;t support it. At the moment it seems to be very rare &quot;in the wild&quot;.</p>

<h2 id="non-ascii-characters-dont-appear-on-vfat-filesystems.">Non-ASCII characters don&#39;t appear on VFAT filesystems.</h2>

<p>Typical symptoms of this problem:</p>

<ul>

<li><p>You get an error when you create a file where the filename contains non-ASCII characters, particularly non 8-bit characters from Asian languages (Chinese, Japanese, etc). The filesystem is VFAT.</p>

</li>
<li><p>When you list a directory from a VFAT filesystem, filenames appear as question marks.</p>

</li>
</ul>

<p>This is a design flaw of the GNU/Linux system.</p>

<p>VFAT stores long filenames as UTF-16 characters. When opening or returning filenames, the Linux kernel has to translate these to some form of 8 bit string. UTF-8 would be the obvious choice, except for Linux users who persist in using non-UTF-8 locales (the user&#39;s locale is not known to the kernel because it&#39;s a function of libc).</p>

<p>Therefore you have to tell the kernel what translation you want done when you mount the filesystem. The two methods are the <code>iocharset</code> parameter (which is not relevant to libguestfs) and the <code>utf8</code> flag.</p>

<p>So to use a VFAT filesystem you must add the <code>utf8</code> flag when mounting. From guestfish, use:</p>

<pre><code> &gt;&lt;fs&gt; mount-options utf8 /dev/sda1 /</code></pre>

<p>or on the guestfish command line:</p>

<pre><code> guestfish [...] -m /dev/sda1:/:utf8</code></pre>

<p>or from the API:</p>

<pre><code> guestfs_mount_options (g, &quot;utf8&quot;, &quot;/dev/sda1&quot;, &quot;/&quot;);</code></pre>

<p>The kernel will then translate filenames to and from UTF-8 strings.</p>

<p>We considered adding this mount option transparently, but unfortunately there are several problems with doing that:</p>

<ul>

<li><p>On some Linux systems, the <code>utf8</code> mount option doesn&#39;t work. We don&#39;t precisely understand what systems or why, but this was reliably reported by one user.</p>

</li>
<li><p>It would prevent you from using the <code>iocharset</code> parameter because it is incompatible with <code>utf8</code>. It is probably not a good idea to use this parameter, but we don&#39;t want to prevent it.</p>

</li>
</ul>

<h2 id="non-ascii-characters-appear-as-underscore-_-on-iso9660-filesystems.">Non-ASCII characters appear as underscore (_) on ISO9660 filesystems.</h2>

<p>The filesystem was not prepared correctly with mkisofs or genisoimage. Make sure the filesystem was created using Joliet and/or Rock Ridge extensions. libguestfs does not require any special mount options to handle the filesystem.</p>

<h2 id="cannot-open-windows-guests-which-use-ntfs.">Cannot open Windows guests which use NTFS.</h2>

<p>You see errors like:</p>

<pre><code> mount: unknown filesystem type &#39;ntfs&#39;</code></pre>

<p>On Red Hat Enterprise Linux or CentOS, you have to install the <a href="https://people.redhat.com/~rjones/libguestfs-winsupport/">libguestfs-winsupport</a> package.</p>

<h2 id="cannot-open-or-inspect-rhel-7-guests.">Cannot open or inspect RHEL 7 guests.</h2>

<h2 id="cannot-open-linux-guests-which-use-xfs.">Cannot open Linux guests which use XFS.</h2>

<p>RHEL 7 guests, and any other guests that use XFS, can be opened by libguestfs, but you have to install the <code>libguestfs-xfs</code> package.</p>

<h1 id="using-libguestfs-in-your-own-programs">USING LIBGUESTFS IN YOUR OWN PROGRAMS</h1>

<h2 id="the-api-has-hundreds-of-methods-where-do-i-start-">The API has hundreds of methods, where do I start?</h2>

<p>We recommend you start by reading the API overview: <a href="guestfs.3.html#api-overview">&quot;API OVERVIEW&quot; in guestfs(3)</a>.</p>

<p>Although the API overview covers the C API, it is still worth reading even if you are going to use another programming language, because the API is the same, just with simple logical changes to the names of the calls:</p>

<pre><code>                  C  guestfs_ln_sf (g, target, linkname);
             Python  g.ln_sf (target, linkname);
              OCaml  g#ln_sf target linkname;
               Perl  $g-&gt;ln_sf (target, linkname);
  Shell (guestfish)  ln-sf target linkname
                PHP  guestfs_ln_sf ($g, $target, $linkname);</code></pre>

<p>Once you&#39;re familiar with the API overview, you should look at this list of starting points for other language bindings: <a href="guestfs.3.html#using-libguestfs-with-other-programming-languages">&quot;USING LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES&quot; in guestfs(3)</a>.</p>

<h2 id="can-i-use-libguestfs-in-my-proprietary-closed-source-commercial-program-">Can I use libguestfs in my proprietary / closed source / commercial program?</h2>

<p>In general, yes. However this is not legal advice - read the license that comes with libguestfs, and if you have specific questions contact a lawyer.</p>

<p>In the source tree the license is in the file <code>COPYING.LIB</code> (LGPLv2+ for the library and bindings) and <code>COPYING</code> (GPLv2+ for the standalone programs).</p>



<!-- old anchor for the next section -->
<a name="debug"/>

<h1 id="debugging-libguestfs">DEBUGGING LIBGUESTFS</h1>

<h2 id="help-its-not-working-">Help, it&#39;s not working!</h2>

<p>If no libguestfs program seems to work at all, run the program below and paste the <b>complete, unedited</b> output into an email to <code>libguestfs</code> @ <code>redhat.com</code>:</p>

<pre><code> libguestfs-test-tool</code></pre>

<p>If a particular operation fails, supply all the information in this checklist, in an email to <code>libguestfs</code> @ <code>redhat.com</code>:</p>

<ol>

<li><p>What are you trying to do?</p>

</li>
<li><p>What exact command(s) did you run?</p>

</li>
<li><p>What was the precise error or output of these commands?</p>

</li>
<li><p>Enable debugging, run the commands again, and capture the <b>complete</b> output. <b>Do not edit the output.</b></p>

<pre><code> export LIBGUESTFS_DEBUG=1
 export LIBGUESTFS_TRACE=1</code></pre>

</li>
<li><p>Include the version of libguestfs, the operating system version, and how you installed libguestfs (eg. from source, <code>yum install</code>, etc.)</p>

</li>
</ol>

<h2 id="how-do-i-debug-when-using-any-libguestfs-program-or-tool-eg.-virt-v2v-or-virt-df-">How do I debug when using any libguestfs program or tool (eg. virt-v2v or virt-df)?</h2>

<p>There are two <code>LIBGUESTFS_*</code> environment variables you can set in order to get more information from libguestfs.</p>

<dl>

<dt><code>LIBGUESTFS_TRACE</code></dt>
<dd>

<p>Set this to 1 and libguestfs will print out each command / API call in a format which is similar to guestfish commands.</p>

</dd>
<dt><code>LIBGUESTFS_DEBUG</code></dt>
<dd>

<p>Set this to 1 in order to enable massive amounts of debug messages. If you think there is some problem inside the libguestfs appliance, then you should use this option.</p>

</dd>
</dl>

<p>To set these from the shell, do this before running the program:</p>

<pre><code> export LIBGUESTFS_TRACE=1
 export LIBGUESTFS_DEBUG=1</code></pre>

<p>For csh/tcsh the equivalent commands would be:</p>

<pre><code> setenv LIBGUESTFS_TRACE 1
 setenv LIBGUESTFS_DEBUG 1</code></pre>

<p>For further information, see: <a href="guestfs.3.html#environment-variables">&quot;ENVIRONMENT VARIABLES&quot; in guestfs(3)</a>.</p>

<h2 id="how-do-i-debug-when-using-guestfish-">How do I debug when using guestfish?</h2>

<p>You can use the same environment variables above. Alternatively use the guestfish options -x (to trace commands) or -v (to get the full debug output), or both.</p>

<p>For further information, see: <a href="guestfish.1.html">guestfish(1)</a>.</p>

<h2 id="how-do-i-debug-when-using-the-api-">How do I debug when using the API?</h2>

<p>Call <a href="guestfs.3.html#guestfs_set_trace">&quot;guestfs_set_trace&quot; in guestfs(3)</a> to enable command traces, and/or <a href="guestfs.3.html#guestfs_set_verbose">&quot;guestfs_set_verbose&quot; in guestfs(3)</a> to enable debug messages.</p>

<p>For best results, call these functions as early as possible, just after creating the guestfs handle if you can, and definitely before calling launch.</p>

<h2 id="how-do-i-capture-debug-output-and-put-it-into-my-logging-system-">How do I capture debug output and put it into my logging system?</h2>

<p>Use the event API. For examples, see: <a href="guestfs.3.html#setting-callbacks-to-handle-events">&quot;SETTING CALLBACKS TO HANDLE EVENTS&quot; in guestfs(3)</a> and the <i>examples/debug-logging.c</i> program in the libguestfs sources.</p>

<h2 id="digging-deeper-into-the-appliance-boot-process.">Digging deeper into the appliance boot process.</h2>

<p>Enable debugging and then read this documentation on the appliance boot process: <a href="guestfs.3.html#internals">&quot;INTERNALS&quot; in guestfs(3)</a>.</p>

<h2 id="libguestfs-hangs-or-fails-during-run-launch.">libguestfs hangs or fails during run/launch.</h2>

<p>Enable debugging and look at the full output. If you cannot work out what is going on, file a bug report, including the <i>complete</i> output of <a href="libguestfs-test-tool.1.html">libguestfs-test-tool(1)</a>.</p>

<h2 id="debugging-libvirt">Debugging libvirt</h2>

<p>If you are using the libvirt backend, and libvirt is failing, then you can enable debugging by editing <i>/etc/libvirt/libvirtd.conf</i>.</p>

<p>If you are running as non-root, then you have to edit a different file. Create <i>~/.config/libvirt/libvirtd.conf</i> containing:</p>

<pre><code> log_level=1
 log_outputs=&quot;1:file:/tmp/libvirtd.log&quot;</code></pre>

<p>Kill any session (non-root) libvirtd that is running, and next time you run the libguestfs command, you should see a large amount of useful debugging information from libvirtd in <i>/tmp/libvirtd.log</i></p>

<h1 id="design-internals-of-libguestfs">DESIGN/INTERNALS OF LIBGUESTFS</h1>

<h2 id="why-dont-you-do-everything-through-the-fuse-filesystem-interface-">Why don&#39;t you do everything through the FUSE / filesystem interface?</h2>

<p>We offer a command called <a href="guestmount.1.html">guestmount(1)</a> which lets you mount guest filesystems on the host. This is implemented as a FUSE module. Why don&#39;t we just implement the whole of libguestfs using this mechanism, instead of having the large and rather complicated API?</p>

<p>The reasons are twofold. Firstly, libguestfs offers API calls for doing things like creating and deleting partitions and logical volumes, which don&#39;t fit into a filesystem model very easily. Or rather, you could fit them in: for example, creating a partition could be mapped to <code>mkdir /fs/hda1</code> but then you&#39;d have to specify some method to choose the size of the partition (maybe <code>echo 100M &gt; /fs/hda1/.size</code>), and the partition type, start and end sectors etc., but once you&#39;ve done that the filesystem-based API starts to look more complicated than the call-based API we currently have.</p>

<p>The second reason is for efficiency. FUSE itself is reasonably efficient, but it does make lots of small, independent calls into the FUSE module. In guestmount these have to be translated into messages to the libguestfs appliance which has a big overhead (in time and round trips). For example, reading a file in 64 KB chunks is inefficient because each chunk would turn into a single round trip. In the libguestfs API it is much more efficient to download an entire file or directory through one of the streaming calls like <code>guestfs_download</code> or <code>guestfs_tar_out</code>.</p>

<h2 id="why-dont-you-do-everything-through-gvfs-">Why don&#39;t you do everything through GVFS?</h2>

<p>The problems are similar to the problems with FUSE.</p>

<p>GVFS is a better abstraction than POSIX/FUSE. There is an FTP backend for GVFS, which is encouraging because FTP is conceptually similar to the libguestfs API. However the GVFS FTP backend makes multiple simultaneous connections in order to keep interactivity, which we can&#39;t easily do with libguestfs.</p>



<!-- old anchor for the next section -->
<a name="backup"/>

<h2 id="why-can-i-write-to-the-disk-even-though-i-added-it-read-only-">Why can I write to the disk, even though I added it read-only?</h2>

<h2 id="why-does---ro-appear-to-have-no-effect-">Why does <code>--ro</code> appear to have no effect?</h2>

<p>When you add a disk read-only, libguestfs places a writable overlay on top of the underlying disk. Writes go into this overlay, and are discarded when the handle is closed (or <code>guestfish</code> etc. exits).</p>

<p>There are two reasons for doing it this way: Firstly read-only disks aren&#39;t possible in many cases (eg. IDE simply doesn&#39;t support them, so you couldn&#39;t have an IDE-emulated read-only disk, although this is not common in real libguestfs installations).</p>

<p>Secondly and more importantly, even if read-only disks were possible, you wouldn&#39;t want them. Mounting any filesystem that has a journal, even <code>mount -o ro</code>, causes writes to the filesystem because the journal has to be replayed and metadata updated. If the disk was truly read-only, you wouldn&#39;t be able to mount a dirty filesystem.</p>

<p>To make it usable, we create the overlay as a place to temporarily store these writes, and then we discard it afterwards. This ensures that the underlying disk is always untouched.</p>

<p>Note also that there is a regression test for this when building libguestfs (in <code>tests/qemu</code>). This is one reason why it&#39;s important for packagers to run the test suite.</p>

<h2 id="does---ro-make-all-disks-read-only-">Does <code>--ro</code> make all disks read-only?</h2>

<p><i>No!</i> The <code>--ro</code> option only affects disks added on the command line, ie. using <code>-a</code> and <code>-d</code> options.</p>

<p>In guestfish, if you use the <code>add</code> command, then disk is added read-write (unless you specify the <code>readonly:true</code> flag explicitly with the command).</p>

<h2 id="can-i-use-guestfish---ro-as-a-way-to-backup-my-virtual-machines-">Can I use <code>guestfish --ro</code> as a way to backup my virtual machines?</h2>

<p>Usually this is <i>not</i> a good idea. The question is answered in more detail in this mailing list posting: <a href="https://www.redhat.com/archives/libguestfs/2010-August/msg00024.html">https://www.redhat.com/archives/libguestfs/2010-August/msg00024.html</a></p>

<p>See also the next question.</p>

<h2 id="why-cant-i-run-fsck-on-a-live-filesystem-using-guestfish---ro-">Why can&#39;t I run fsck on a live filesystem using <code>guestfish --ro</code>?</h2>

<p>This command will usually <i>not</i> work:</p>

<pre><code> guestfish --ro -a /dev/vg/my_root_fs run : fsck /dev/sda</code></pre>

<p>The reason for this is that qemu creates a snapshot over the original filesystem, but it doesn&#39;t create a strict point-in-time snapshot. Blocks of data on the underlying filesystem are read by qemu at different times as the fsck operation progresses, with host writes in between. The result is that fsck sees massive corruption (imaginary, not real!) and fails.</p>

<p>What you have to do is to create a point-in-time snapshot. If it&#39;s a logical volume, use an LVM2 snapshot. If the filesystem is located inside something like a btrfs/ZFS file, use a btrfs/ZFS snapshot, and then run the fsck on the snapshot. In practice you don&#39;t need to use libguestfs for this -- just run <i>/sbin/fsck</i> directly.</p>

<p>Creating point-in-time snapshots of host devices and files is outside the scope of libguestfs, although libguestfs can operate on them once they are created.</p>

<h2 id="whats-the-difference-between-guestfish-and-virt-rescue-">What&#39;s the difference between guestfish and virt-rescue?</h2>

<p>A lot of people are confused by the two superficially similar tools we provide:</p>

<pre><code> $ guestfish --ro -a guest.img
 &gt;&lt;fs&gt; run
 &gt;&lt;fs&gt; fsck /dev/sda1

 $ virt-rescue --ro guest.img
 &gt;&lt;rescue&gt; /sbin/fsck /dev/sda1</code></pre>

<p>And the related question which then arises is why you can&#39;t type in full shell commands with all the --options in guestfish (but you can in <a href="virt-rescue.1.html">virt-rescue(1)</a>).</p>

<p><a href="guestfish.1.html">guestfish(1)</a> is a program providing structured access to the <a href="guestfs.3.html">guestfs(3)</a> API. It happens to be a nice interactive shell too, but its primary purpose is structured access from shell scripts. Think of it more like a language binding, like Python and other bindings, but for shell. The key differentiating factor of guestfish (and the libguestfs API in general) is the ability to automate changes.</p>

<p><a href="virt-rescue.1.html">virt-rescue(1)</a> is a free-for-all freeform way to boot the libguestfs appliance and make arbitrary changes to your VM. It&#39;s not structured, you can&#39;t automate it, but for making quick ad-hoc fixes to your guests, it can be quite useful.</p>

<p>But, libguestfs also has a &quot;backdoor&quot; into the appliance allowing you to send arbitrary shell commands. It&#39;s not as flexible as virt-rescue, because you can&#39;t interact with the shell commands, but here it is anyway:</p>

<pre><code> &gt;&lt;fs&gt; debug sh &quot;cmd arg1 arg2 ...&quot;</code></pre>

<p>Note that you should <b>not</b> rely on this. It could be removed or changed in future. If your program needs some operation, please add it to the libguestfs API instead.</p>

<h2 id="whats-the-deal-with-guestfish--i-">What&#39;s the deal with <code>guestfish -i</code>?</h2>

<h2 id="why-does-virt-cat-only-work-on-a-real-vm-image-but-virt-df-works-on-any-disk-image-">Why does virt-cat only work on a real VM image, but virt-df works on any disk image?</h2>

<h2 id="what-does-no-root-device-found-in-this-operating-system-image-mean-">What does &quot;no root device found in this operating system image&quot; mean?</h2>

<p>These questions are all related at a fundamental level which may not be immediately obvious.</p>

<p>At the <a href="guestfs.3.html">guestfs(3)</a> API level, a &quot;disk image&quot; is just a pile of partitions and filesystems.</p>

<p>In contrast, when the virtual machine boots, it mounts those filesystems into a consistent hierarchy such as:</p>

<pre><code> /          (/dev/sda2)
 &#x2502;
 &#x251C;&#x2500;&#x2500; /boot  (/dev/sda1)
 &#x2502;
 &#x251C;&#x2500;&#x2500; /home  (/dev/vg_external/Homes)
 &#x2502;
 &#x251C;&#x2500;&#x2500; /usr   (/dev/vg_os/lv_usr)
 &#x2502;
 &#x2514;&#x2500;&#x2500; /var   (/dev/vg_os/lv_var)</code></pre>

<p>(or drive letters on Windows).</p>

<p>The API first of all sees the disk image at the &quot;pile of filesystems&quot; level. But it also has a way to inspect the disk image to see if it contains an operating system, and how the disks are mounted when the operating system boots: <a href="guestfs.3.html#inspection">&quot;INSPECTION&quot; in guestfs(3)</a>.</p>

<p>Users expect some tools (like <a href="virt-cat.1.html">virt-cat(1)</a>) to work with VM paths:</p>

<pre><code> virt-cat fedora.img /var/log/messages</code></pre>

<p>How does virt-cat know that <i>/var</i> is a separate partition? The trick is that virt-cat performs inspection on the disk image, and uses that to translate the path correctly.</p>

<p>Some tools (including <a href="virt-cat.1.html">virt-cat(1)</a>, <a href="virt-edit.1.html">virt-edit(1)</a>, <a href="virt-ls.1.html">virt-ls(1)</a>) use inspection to map VM paths. Other tools, such as <a href="virt-df.1.html">virt-df(1)</a> and <a href="virt-filesystems.1.html">virt-filesystems(1)</a> operate entirely at the raw &quot;big pile of filesystems&quot; level of the libguestfs API, and don&#39;t use inspection.</p>

<p><a href="guestfish.1.html">guestfish(1)</a> is in an interesting middle ground. If you use the <i>-a</i> and <i>-m</i> command line options, then you have to tell guestfish exactly how to add disk images and where to mount partitions. This is the raw API level.</p>

<p>If you use the <i>-i</i> option, libguestfs performs inspection and mounts the filesystems for you.</p>

<p>The error <code>no root device found in this operating system image</code> is related to this. It means inspection was unable to locate an operating system within the disk image you gave it. You might see this from programs like virt-cat if you try to run them on something which is just a disk image, not a virtual machine disk image.</p>

<h2 id="what-do-these-debug-and-internal--functions-do-">What do these <code>debug*</code> and <code>internal-*</code> functions do?</h2>

<p>There are some functions which are used for debugging and internal purposes which are <i>not</i> part of the stable API.</p>

<p>The <code>debug*</code> (or <code>guestfs_debug*</code>) functions, primarily <a href="guestfs.3.html#guestfs_debug">&quot;guestfs_debug&quot; in guestfs(3)</a> and a handful of others, are used for debugging libguestfs. Although they are not part of the stable API and thus may change or be removed at any time, some programs may want to call these while waiting for features to be added to libguestfs.</p>

<p>The <code>internal-*</code> (or <code>guestfs_internal_*</code>) functions are purely to be used by libguestfs itself. There is no reason for programs to call them, and programs should not try to use them. Using them will often cause bad things to happen, as well as not being part of the documented stable API.</p>

<h1 id="developers">DEVELOPERS</h1>

<h2 id="where-do-i-send-patches-">Where do I send patches?</h2>

<p>Please send patches to the libguestfs mailing list <a href="https://www.redhat.com/mailman/listinfo/libguestfs">https://www.redhat.com/mailman/listinfo/libguestfs</a>. You don&#39;t have to be subscribed, but there will be a delay until your posting is manually approved.</p>

<p><b>Please don&#39;t use github pull requests - they will be ignored</b>. The reasons are (a) we want to discuss and dissect patches on the mailing list, and (b) github pull requests turn into merge commits but we prefer to have a linear history.</p>

<h2 id="how-do-i-propose-a-feature-">How do I propose a feature?</h2>

<p>Large new features that you intend to contribute should be discussed on the mailing list first (<a href="https://www.redhat.com/mailman/listinfo/libguestfs">https://www.redhat.com/mailman/listinfo/libguestfs</a>). This avoids disappointment and wasted work if we don&#39;t think the feature would fit into the libguestfs project.</p>

<p>If you want to suggest a useful feature but don&#39;t want to write the code, you can file a bug (see <a href="#getting-help-and-reporting-bugs">&quot;GETTING HELP AND REPORTING BUGS&quot;</a>) with <code>&quot;RFE: &quot;</code> at the beginning of the Summary line.</p>

<h2 id="who-can-commit-to-libguestfs-git-">Who can commit to libguestfs git?</h2>

<p>About 5 people have commit access to github. Patches should be posted on the list first and ACKed. The policy for ACKing and pushing patches is outlined here:</p>

<p><a href="https://www.redhat.com/archives/libguestfs/2012-January/msg00023.html">https://www.redhat.com/archives/libguestfs/2012-January/msg00023.html</a></p>

<h2 id="can-i-fork-libguestfs-">Can I fork libguestfs?</h2>

<p>Of course you can. Git makes it easy to fork libguestfs. Github makes it even easier. It&#39;s nice if you tell us on the mailing list about forks and the reasons for them.</p>

<h1 id="miscellaneous-questions">MISCELLANEOUS QUESTIONS</h1>

<h2 id="can-i-monitor-the-live-disk-activity-of-a-virtual-machine-using-libguestfs-">Can I monitor the live disk activity of a virtual machine using libguestfs?</h2>

<p>A common request is to be able to use libguestfs to monitor the live disk activity of a guest, for example, to get notified every time a guest creates a new file. Libguestfs does <i>not</i> work in the way some people imagine, as you can see from this diagram:</p>

<pre><code>            &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
            &#x2502; monitoring program using libguestfs &#x2502;
            &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
                             &darr;
 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
 &#x2502; live VM   &#x2502;    &#x2502; libguestfs appliance &#x2502;
 &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
 &#x2502; kernel (1)&#x2502;    &#x2502; appliance kernel (2) &#x2502;
 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
      &darr;                      &darr; (r/o connection)
      &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
      |      disk image      |
      &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;</code></pre>

<p>This scenario is safe (as long as you set the <code>readonly</code> flag when adding the drive). However the libguestfs appliance kernel (2) does not see all the changes made to the disk image, for two reasons:</p>

<dl>

<dt>i.</dt>
<dd>

<p>The VM kernel (1) can cache data in memory, so it doesn&#39;t appear in the disk image.</p>

</dd>
<dt>ii.</dt>
<dd>

<p>The libguestfs appliance kernel (2) doesn&#39;t expect that the disk image is changing underneath it, so its own cache is not magically updated even when the VM kernel (1) does update the disk image.</p>

</dd>
</dl>

<p>The only supported solution is to restart the entire libguestfs appliance whenever you want to look at changes in the disk image. At the API level that corresponds to calling <code>guestfs_shutdown</code> followed by <code>guestfs_launch</code>, which is a heavyweight operation (see also <a href="guestfs-performance.3.html">guestfs-performance(3)</a>).</p>

<p>There are some unsupported hacks you can try if relaunching the appliance is really too costly:</p>

<ul>

<li><p>Call <code>guestfs_drop_caches (g, 3)</code>. This causes all cached data help by the libguestfs appliance kernel (2) to be discarded, so it goes back to the disk image.</p>

<p>However this on its own is not sufficient, because qemu also caches some data. You will also need to patch libguestfs to (re-)enable the <code>cache=unsafe</code> mode. See: <a href="https://rwmj.wordpress.com/2013/09/02/new-in-libguestfs-allow-cache-mode-to-be-selected/">https://rwmj.wordpress.com/2013/09/02/new-in-libguestfs-allow-cache-mode-to-be-selected/</a></p>

</li>
<li><p>Use a tool like <a href="http://git.annexia.org/?p=virt-bmap.git">virt-bmap</a> instead.</p>

</li>
<li><p>Run an agent inside the guest.</p>

</li>
</ul>

<p>Nothing helps if the guest is making more fundamental changes (eg. deleting filesystems). For those kinds of things you must relaunch the appliance.</p>

<p>(Note there is a third problem that you need to use consistent snapshots to really examine live disk images, but that&#39;s a general problem with using libguestfs against any live disk image.)</p>

<h1 id="see-also">SEE ALSO</h1>

<p><a href="guestfish.1.html">guestfish(1)</a>, <a href="guestfs.3.html">guestfs(3)</a>, <a href="http://libguestfs.org/">http://libguestfs.org/</a>.</p>

<h1 id="authors">AUTHORS</h1>

<p>Richard W.M. Jones (<code>rjones at redhat dot com</code>)</p>

<h1 id="copyright">COPYRIGHT</h1>

<p>Copyright (C) 2012-2015 Red Hat Inc.</p>

<h1 id="license">LICENSE</h1>

<p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</p>

<h1 id="bugs">BUGS</h1>

<p>To get a list of bugs against libguestfs, use this link: <a href="https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>To report a new bug against libguestfs, use this link: <a href="https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>When reporting a bug, please supply:</p>

<ul>

<li><p>The version of libguestfs.</p>

</li>
<li><p>Where you got libguestfs (eg. which Linux distro, compiled from source, etc)</p>

</li>
<li><p>Describe the bug accurately and give a way to reproduce it.</p>

</li>
<li><p>Run <a href="libguestfs-test-tool.1.html">libguestfs-test-tool(1)</a> and paste the <b>complete, unedited</b> output into the bug report.</p>

</li>
</ul>

</body>
</html>

