
<html>
<head>
<title>guestfs-ocaml</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel='stylesheet' href='pod.css' type='text/css' />
</head>
<body>


<ul id="index">
  <li><a href="#name">NAME</a></li>
  <li><a href="#synopsis">SYNOPSIS</a></li>
  <li><a href="#description">DESCRIPTION</a>
    <ul>
      <li><a href="#programming-styles">PROGRAMMING STYLES</a></li>
      <li><a href="#closing-the-handle">CLOSING THE HANDLE</a></li>
      <li><a href="#exceptions">EXCEPTIONS</a></li>
    </ul>
  </li>
  <li><a href="#example:-create-a-disk-image">EXAMPLE: CREATE A DISK IMAGE</a></li>
  <li><a href="#example:-inspect-a-virtual-machine-disk-image">EXAMPLE: INSPECT A VIRTUAL MACHINE DISK IMAGE</a></li>
  <li><a href="#example:-enable-debugging-and-logging">EXAMPLE: ENABLE DEBUGGING AND LOGGING</a></li>
  <li><a href="#see-also">SEE ALSO</a></li>
  <li><a href="#authors">AUTHORS</a></li>
  <li><a href="#copyright">COPYRIGHT</a></li>
  <li><a href="#license">LICENSE</a></li>
  <li><a href="#bugs">BUGS</a></li>
</ul>

<h1 id="name">NAME</h1>

<p>guestfs-ocaml - How to use libguestfs from OCaml</p>

<h1 id="synopsis">SYNOPSIS</h1>

<p>Module style:</p>

<pre><code> let g = Guestfs.create () in
 Guestfs.add_drive_opts g ~format:&quot;raw&quot; ~readonly:true &quot;disk.img&quot;;
 Guestfs.launch g;</code></pre>

<p>Object-oriented style:</p>

<pre><code> let g = new Guestfs.guestfs () in
 g#add_drive_opts ~format:&quot;raw&quot; ~readonly:true &quot;disk.img&quot;;
 g#launch ();

 ocamlfind opt prog.ml -package guestfs -linkpkg -o prog
or:
 ocamlopt -I +guestfs mlguestfs.cmxa prog.ml -o prog</code></pre>

<h1 id="description">DESCRIPTION</h1>

<p>This manual page documents how to call libguestfs from the OCaml programming language. This page just documents the differences from the C API and gives some examples. If you are not familiar with using libguestfs, you also need to read <a href="guestfs.3.html">guestfs(3)</a>.</p>

<h2 id="programming-styles">PROGRAMMING STYLES</h2>

<p>There are two different programming styles supported by the OCaml bindings. You can use a module style, with each C function mapped to an OCaml function:</p>

<pre><code> int guestfs_set_verbose (guestfs_h *g, int flag);</code></pre>

<p>becomes:</p>

<pre><code> val Guestfs.set_verbose : Guestfs.t -&gt; bool -&gt; unit</code></pre>

<p>Alternately you can use an object-oriented style, calling methods on the class <code>Guestfs.guestfs</code>:</p>

<pre><code> method set_verbose : bool -&gt; unit</code></pre>

<p>The object-oriented style is usually briefer, and the minor performance penalty isn&#39;t noticeable in the general overhead of performing libguestfs functions.</p>

<h2 id="closing-the-handle">CLOSING THE HANDLE</h2>

<p>The handle is closed when it is reaped by the garbage collector. Because libguestfs handles include a lot of state, it is also possible to close (and hence free) them explicitly by calling <code>Guestfs.close</code> or the <code>#close</code> method.</p>

<h2 id="exceptions">EXCEPTIONS</h2>

<p>Errors from libguestfs functions are mapped into the <code>Guestfs.Error</code> exception. This has a single parameter which is the error message (a string).</p>

<p>Calling any function/method on a closed handle raises <code>Guestfs.Handle_closed</code>. The single parameter is the name of the function that you called.</p>

<h1 id="example:-create-a-disk-image">EXAMPLE: CREATE A DISK IMAGE</h1>

<pre><code> (* Example showing how to create a disk image. *)
 
 open Unix
 open Printf
 
 let output = &quot;disk.img&quot;
 
 let () =
   let g = new Guestfs.guestfs () in
 
   (* Create a raw-format sparse disk image, 512 MB in size. *)
   g#disk_create output &quot;raw&quot; (Int64.of_int (512 * 1024 * 1024));
 
   (* Set the trace flag so that we can see each libguestfs call. *)
   g#set_trace true;
 
   (* Attach the disk image to libguestfs. *)
   g#add_drive_opts ~format:&quot;raw&quot; ~readonly:false output;
 
   (* Run the libguestfs back-end. *)
   g#launch ();
 
   (* Get the list of devices.  Because we only added one drive
    * above, we expect that this list should contain a single
    * element.
    *)
   let devices = g#list_devices () in
   if Array.length devices &lt;&gt; 1 then
     failwith &quot;error: expected a single device from list-devices&quot;;
 
   (* Partition the disk as one single MBR partition. *)
   g#part_disk devices.(0) &quot;mbr&quot;;
 
   (* Get the list of partitions.  We expect a single element, which
    * is the partition we have just created.
    *)
   let partitions = g#list_partitions () in
   if Array.length partitions &lt;&gt; 1 then
     failwith &quot;error: expected a single partition from list-partitions&quot;;
 
   (* Create a filesystem on the partition. *)
   g#mkfs &quot;ext4&quot; partitions.(0);
 
   (* Now mount the filesystem so that we can add files. *)
   g#mount partitions.(0) &quot;/&quot;;
 
   (* Create some files and directories. *)
   g#touch &quot;/empty&quot;;
   let message = &quot;Hello, world\n&quot; in
   g#write &quot;/hello&quot; message;
   g#mkdir &quot;/foo&quot;;
 
   (* This one uploads the local file /etc/resolv.conf into
    * the disk image.
    *)
   g#upload &quot;/etc/resolv.conf&quot; &quot;/foo/resolv.conf&quot;;
 
   (* Because we wrote to the disk and we want to detect write
    * errors, call g#shutdown.  You don&#39;t need to do this:
    * g#close will do it implicitly.
    *)
   g#shutdown ();
 
   (* Note also that handles are automatically closed if they are
    * reaped by the garbage collector.  You only need to call close
    * if you want to close the handle right away.
    *)
   g#close ()</code></pre>

<h1 id="example:-inspect-a-virtual-machine-disk-image">EXAMPLE: INSPECT A VIRTUAL MACHINE DISK IMAGE</h1>

<pre><code> (* Example showing how to inspect a virtual machine disk. *)
 
 open Printf
 
 let disk =
   if Array.length Sys.argv = 2 then
     Sys.argv.(1)
   else
     failwith &quot;usage: inspect_vm disk.img&quot;
 
 let () =
   let g = new Guestfs.guestfs () in
 
   (* Attach the disk image read-only to libguestfs. *)
   g#add_drive_opts (*~format:&quot;raw&quot;*) ~readonly:true disk;
 
   (* Run the libguestfs back-end. *)
   g#launch ();
 
   (* Ask libguestfs to inspect for operating systems. *)
   let roots = g#inspect_os () in
   if Array.length roots = 0 then
     failwith &quot;inspect_vm: no operating systems found&quot;;
 
   Array.iter (
     fun root -&gt;
       printf &quot;Root device: %s\n&quot; root;
 
       (* Print basic information about the operating system. *)
       printf &quot;  Product name: %s\n&quot; (g#inspect_get_product_name root);
       printf &quot;  Version:      %d.%d\n&quot;
         (g#inspect_get_major_version root)
         (g#inspect_get_minor_version root);
       printf &quot;  Type:         %s\n&quot; (g#inspect_get_type root);
       printf &quot;  Distro:       %s\n&quot; (g#inspect_get_distro root);
 
       (* Mount up the disks, like guestfish -i.
        *
        * Sort keys by length, shortest first, so that we end up
        * mounting the filesystems in the correct order.
        *)
       let mps = g#inspect_get_mountpoints root in
       let cmp (a,_) (b,_) =
         compare (String.length a) (String.length b) in
       let mps = List.sort cmp mps in
       List.iter (
         fun (mp, dev) -&gt;
           try g#mount_ro dev mp
           with Guestfs.Error msg -&gt; eprintf &quot;%s (ignored)\n&quot; msg
       ) mps;
 
       (* If /etc/issue.net file exists, print up to 3 lines. *)
       let filename = &quot;/etc/issue.net&quot; in
       if g#is_file filename then (
         printf &quot;--- %s ---\n&quot; filename;
         let lines = g#head_n 3 filename in
         Array.iter print_endline lines
       );
 
       (* Unmount everything. *)
       g#umount_all ()
   ) roots</code></pre>

<h1 id="example:-enable-debugging-and-logging">EXAMPLE: ENABLE DEBUGGING AND LOGGING</h1>

<pre><code> (* Example showing how to enable debugging, and capture it into any
  * custom logging system.
  *)
 
 (* Events we are interested in.  This bitmask covers all trace and
  * debug messages.
  *)
 let event_bitmask = [
   Guestfs.EVENT_LIBRARY;
   Guestfs.EVENT_WARNING;
   Guestfs.EVENT_APPLIANCE;
   Guestfs.EVENT_TRACE
 ]
 
 let rec main () =
   let g = new Guestfs.guestfs () in
 
   (* By default, debugging information is printed on stderr.  To
    * capture it somewhere else you have to set up an event handler
    * which will be called back as debug messages are generated.  To do
    * this use the event API.
    *
    * For more information see EVENTS in guestfs(3).
    *)
   ignore (g#set_event_callback message_callback event_bitmask);
 
   (* This is how debugging is enabled:
    *
    * Setting the &#39;trace&#39; flag in the handle means that each libguestfs
    * call is logged (name, parameters, return).  This flag is useful
    * to see how libguestfs is being used by a program.
    *
    * Setting the &#39;verbose&#39; flag enables a great deal of extra
    * debugging throughout the system.  This is useful if there is a
    * libguestfs error which you don&#39;t understand.
    *
    * Note that you should set the flags early on after creating the
    * handle.  In particular if you set the verbose flag after launch
    * then you won&#39;t see all messages.
    *
    * For more information see:
    * http://libguestfs.org/guestfs-faq.1.html#debugging-libguestfs
    *
    * Error messages raised by APIs are *not* debugging information,
    * and they are not affected by any of this.  You may have to log
    * them separately.
    *)
   g#set_trace true;
   g#set_verbose true;
 
   (* Do some operations which will generate plenty of trace and debug
    * messages.
    *)
   g#add_drive &quot;/dev/null&quot;;
   g#launch ();
   g#close ()
 
 (* This function is called back by libguestfs whenever a trace or
  * debug message is generated.
  *
  * For the classes of events we have registered above, &#39;array&#39; and
  * &#39;array_len&#39; will not be meaningful.  Only &#39;buf&#39; and &#39;buf_len&#39; will
  * be interesting and these will contain the trace or debug message.
  *
  * This example simply redirects these messages to syslog, but
  * obviously you could do something more advanced here.
  *)
 and message_callback g event event_handle buf array =
   if String.length buf &gt; 0 then (
     let event_name = Guestfs.event_to_string [event] in
     Printf.printf &quot;[%s] %S\n%!&quot; event_name buf
   )
 
 let () = main ()</code></pre>

<h1 id="see-also">SEE ALSO</h1>

<p><a href="guestfs.3.html">guestfs(3)</a>, <a href="guestfs-examples.3.html">guestfs-examples(3)</a>, <a href="guestfs-erlang.3.html">guestfs-erlang(3)</a>, <a href="guestfs-golang.3.html">guestfs-golang(3)</a>, <a href="guestfs-java.3.html">guestfs-java(3)</a>, <a href="guestfs-lua.3.html">guestfs-lua(3)</a>, <a href="guestfs-perl.3.html">guestfs-perl(3)</a>, <a href="guestfs-python.3.html">guestfs-python(3)</a>, <a href="guestfs-recipes.1.html">guestfs-recipes(1)</a>, <a href="guestfs-ruby.3.html">guestfs-ruby(3)</a>, <a href="http://libguestfs.org/">http://libguestfs.org/</a>, <a href="http://caml.inria.fr/">http://caml.inria.fr/</a>.</p>

<h1 id="authors">AUTHORS</h1>

<p>Richard W.M. Jones (<code>rjones at redhat dot com</code>)</p>

<h1 id="copyright">COPYRIGHT</h1>

<p>Copyright (C) 2010-2012 Red Hat Inc.</p>

<h1 id="license">LICENSE</h1>

<p>This manual page contains examples which we hope you will use in your programs. The examples may be freely copied, modified and distributed for any purpose without any restrictions.</p>

<h1 id="bugs">BUGS</h1>

<p>To get a list of bugs against libguestfs, use this link: <a href="https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>To report a new bug against libguestfs, use this link: <a href="https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>When reporting a bug, please supply:</p>

<ul>

<li><p>The version of libguestfs.</p>

</li>
<li><p>Where you got libguestfs (eg. which Linux distro, compiled from source, etc)</p>

</li>
<li><p>Describe the bug accurately and give a way to reproduce it.</p>

</li>
<li><p>Run <a href="libguestfs-test-tool.1.html">libguestfs-test-tool(1)</a> and paste the <b>complete, unedited</b> output into the bug report.</p>

</li>
</ul>

</body>
</html>

