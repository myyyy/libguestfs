.\" Automatically generated by Podwrapper::Man 1.30.3 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "guestfs-ocaml 3"
.TH guestfs-ocaml 3 "2015-10-26" "libguestfs-1.30.3" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
guestfs\-ocaml \- How to use libguestfs from OCaml
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Module style:
.PP
.Vb 3
\& let g = Guestfs.create () in
\& Guestfs.add_drive_opts g ~format:"raw" ~readonly:true "disk.img";
\& Guestfs.launch g;
.Ve
.PP
Object-oriented style:
.PP
.Vb 3
\& let g = new Guestfs.guestfs () in
\& g#add_drive_opts ~format:"raw" ~readonly:true "disk.img";
\& g#launch ();
\&
\& ocamlfind opt prog.ml \-package guestfs \-linkpkg \-o prog
\&or:
\& ocamlopt \-I +guestfs mlguestfs.cmxa prog.ml \-o prog
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This manual page documents how to call libguestfs from the OCaml
programming language.  This page just documents the differences from
the C \s-1API\s0 and gives some examples.  If you are not familiar with using
libguestfs, you also need to read \fIguestfs\fR\|(3).
.SS "\s-1PROGRAMMING\s0 \s-1STYLES\s0"
.IX Subsection "PROGRAMMING STYLES"
There are two different programming styles supported by the OCaml
bindings.  You can use a module style, with each C function mapped to
an OCaml function:
.PP
.Vb 1
\& int guestfs_set_verbose (guestfs_h *g, int flag);
.Ve
.PP
becomes:
.PP
.Vb 1
\& val Guestfs.set_verbose : Guestfs.t \-> bool \-> unit
.Ve
.PP
Alternately you can use an object-oriented style, calling methods
on the class \f(CW\*(C`Guestfs.guestfs\*(C'\fR:
.PP
.Vb 1
\& method set_verbose : bool \-> unit
.Ve
.PP
The object-oriented style is usually briefer, and the minor performance
penalty isn't noticeable in the general overhead of performing
libguestfs functions.
.SS "\s-1CLOSING\s0 \s-1THE\s0 \s-1HANDLE\s0"
.IX Subsection "CLOSING THE HANDLE"
The handle is closed when it is reaped by the garbage collector.
Because libguestfs handles include a lot of state, it is also
possible to close (and hence free) them explicitly by calling
\&\f(CW\*(C`Guestfs.close\*(C'\fR or the \f(CW\*(C`#close\*(C'\fR method.
.SS "\s-1EXCEPTIONS\s0"
.IX Subsection "EXCEPTIONS"
Errors from libguestfs functions are mapped into the \f(CW\*(C`Guestfs.Error\*(C'\fR
exception.  This has a single parameter which is the error message (a
string).
.PP
Calling any function/method on a closed handle raises
\&\f(CW\*(C`Guestfs.Handle_closed\*(C'\fR.  The single parameter is the name of the
function that you called.
.SH "EXAMPLE: CREATE A DISK IMAGE"
.IX Header "EXAMPLE: CREATE A DISK IMAGE"
.Vb 1
\& (* Example showing how to create a disk image. *)
\& 
\& open Unix
\& open Printf
\& 
\& let output = "disk.img"
\& 
\& let () =
\&   let g = new Guestfs.guestfs () in
\& 
\&   (* Create a raw\-format sparse disk image, 512 MB in size. *)
\&   g#disk_create output "raw" (Int64.of_int (512 * 1024 * 1024));
\& 
\&   (* Set the trace flag so that we can see each libguestfs call. *)
\&   g#set_trace true;
\& 
\&   (* Attach the disk image to libguestfs. *)
\&   g#add_drive_opts ~format:"raw" ~readonly:false output;
\& 
\&   (* Run the libguestfs back\-end. *)
\&   g#launch ();
\& 
\&   (* Get the list of devices.  Because we only added one drive
\&    * above, we expect that this list should contain a single
\&    * element.
\&    *)
\&   let devices = g#list_devices () in
\&   if Array.length devices <> 1 then
\&     failwith "error: expected a single device from list\-devices";
\& 
\&   (* Partition the disk as one single MBR partition. *)
\&   g#part_disk devices.(0) "mbr";
\& 
\&   (* Get the list of partitions.  We expect a single element, which
\&    * is the partition we have just created.
\&    *)
\&   let partitions = g#list_partitions () in
\&   if Array.length partitions <> 1 then
\&     failwith "error: expected a single partition from list\-partitions";
\& 
\&   (* Create a filesystem on the partition. *)
\&   g#mkfs "ext4" partitions.(0);
\& 
\&   (* Now mount the filesystem so that we can add files. *)
\&   g#mount partitions.(0) "/";
\& 
\&   (* Create some files and directories. *)
\&   g#touch "/empty";
\&   let message = "Hello, world\en" in
\&   g#write "/hello" message;
\&   g#mkdir "/foo";
\& 
\&   (* This one uploads the local file /etc/resolv.conf into
\&    * the disk image.
\&    *)
\&   g#upload "/etc/resolv.conf" "/foo/resolv.conf";
\& 
\&   (* Because we wrote to the disk and we want to detect write
\&    * errors, call g#shutdown.  You don\*(Aqt need to do this:
\&    * g#close will do it implicitly.
\&    *)
\&   g#shutdown ();
\& 
\&   (* Note also that handles are automatically closed if they are
\&    * reaped by the garbage collector.  You only need to call close
\&    * if you want to close the handle right away.
\&    *)
\&   g#close ()
.Ve
.SH "EXAMPLE: INSPECT A VIRTUAL MACHINE DISK IMAGE"
.IX Header "EXAMPLE: INSPECT A VIRTUAL MACHINE DISK IMAGE"
.Vb 1
\& (* Example showing how to inspect a virtual machine disk. *)
\& 
\& open Printf
\& 
\& let disk =
\&   if Array.length Sys.argv = 2 then
\&     Sys.argv.(1)
\&   else
\&     failwith "usage: inspect_vm disk.img"
\& 
\& let () =
\&   let g = new Guestfs.guestfs () in
\& 
\&   (* Attach the disk image read\-only to libguestfs. *)
\&   g#add_drive_opts (*~format:"raw"*) ~readonly:true disk;
\& 
\&   (* Run the libguestfs back\-end. *)
\&   g#launch ();
\& 
\&   (* Ask libguestfs to inspect for operating systems. *)
\&   let roots = g#inspect_os () in
\&   if Array.length roots = 0 then
\&     failwith "inspect_vm: no operating systems found";
\& 
\&   Array.iter (
\&     fun root \->
\&       printf "Root device: %s\en" root;
\& 
\&       (* Print basic information about the operating system. *)
\&       printf "  Product name: %s\en" (g#inspect_get_product_name root);
\&       printf "  Version:      %d.%d\en"
\&         (g#inspect_get_major_version root)
\&         (g#inspect_get_minor_version root);
\&       printf "  Type:         %s\en" (g#inspect_get_type root);
\&       printf "  Distro:       %s\en" (g#inspect_get_distro root);
\& 
\&       (* Mount up the disks, like guestfish \-i.
\&        *
\&        * Sort keys by length, shortest first, so that we end up
\&        * mounting the filesystems in the correct order.
\&        *)
\&       let mps = g#inspect_get_mountpoints root in
\&       let cmp (a,_) (b,_) =
\&         compare (String.length a) (String.length b) in
\&       let mps = List.sort cmp mps in
\&       List.iter (
\&         fun (mp, dev) \->
\&           try g#mount_ro dev mp
\&           with Guestfs.Error msg \-> eprintf "%s (ignored)\en" msg
\&       ) mps;
\& 
\&       (* If /etc/issue.net file exists, print up to 3 lines. *)
\&       let filename = "/etc/issue.net" in
\&       if g#is_file filename then (
\&         printf "\-\-\- %s \-\-\-\en" filename;
\&         let lines = g#head_n 3 filename in
\&         Array.iter print_endline lines
\&       );
\& 
\&       (* Unmount everything. *)
\&       g#umount_all ()
\&   ) roots
.Ve
.SH "EXAMPLE: ENABLE DEBUGGING AND LOGGING"
.IX Header "EXAMPLE: ENABLE DEBUGGING AND LOGGING"
.Vb 3
\& (* Example showing how to enable debugging, and capture it into any
\&  * custom logging system.
\&  *)
\& 
\& (* Events we are interested in.  This bitmask covers all trace and
\&  * debug messages.
\&  *)
\& let event_bitmask = [
\&   Guestfs.EVENT_LIBRARY;
\&   Guestfs.EVENT_WARNING;
\&   Guestfs.EVENT_APPLIANCE;
\&   Guestfs.EVENT_TRACE
\& ]
\& 
\& let rec main () =
\&   let g = new Guestfs.guestfs () in
\& 
\&   (* By default, debugging information is printed on stderr.  To
\&    * capture it somewhere else you have to set up an event handler
\&    * which will be called back as debug messages are generated.  To do
\&    * this use the event API.
\&    *
\&    * For more information see EVENTS in guestfs(3).
\&    *)
\&   ignore (g#set_event_callback message_callback event_bitmask);
\& 
\&   (* This is how debugging is enabled:
\&    *
\&    * Setting the \*(Aqtrace\*(Aq flag in the handle means that each libguestfs
\&    * call is logged (name, parameters, return).  This flag is useful
\&    * to see how libguestfs is being used by a program.
\&    *
\&    * Setting the \*(Aqverbose\*(Aq flag enables a great deal of extra
\&    * debugging throughout the system.  This is useful if there is a
\&    * libguestfs error which you don\*(Aqt understand.
\&    *
\&    * Note that you should set the flags early on after creating the
\&    * handle.  In particular if you set the verbose flag after launch
\&    * then you won\*(Aqt see all messages.
\&    *
\&    * For more information see:
\&    * http://libguestfs.org/guestfs\-faq.1.html#debugging\-libguestfs
\&    *
\&    * Error messages raised by APIs are *not* debugging information,
\&    * and they are not affected by any of this.  You may have to log
\&    * them separately.
\&    *)
\&   g#set_trace true;
\&   g#set_verbose true;
\& 
\&   (* Do some operations which will generate plenty of trace and debug
\&    * messages.
\&    *)
\&   g#add_drive "/dev/null";
\&   g#launch ();
\&   g#close ()
\& 
\& (* This function is called back by libguestfs whenever a trace or
\&  * debug message is generated.
\&  *
\&  * For the classes of events we have registered above, \*(Aqarray\*(Aq and
\&  * \*(Aqarray_len\*(Aq will not be meaningful.  Only \*(Aqbuf\*(Aq and \*(Aqbuf_len\*(Aq will
\&  * be interesting and these will contain the trace or debug message.
\&  *
\&  * This example simply redirects these messages to syslog, but
\&  * obviously you could do something more advanced here.
\&  *)
\& and message_callback g event event_handle buf array =
\&   if String.length buf > 0 then (
\&     let event_name = Guestfs.event_to_string [event] in
\&     Printf.printf "[%s] %S\en%!" event_name buf
\&   )
\& 
\& let () = main ()
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIguestfs\fR\|(3),
\&\fIguestfs\-examples\fR\|(3),
\&\fIguestfs\-erlang\fR\|(3),
\&\fIguestfs\-golang\fR\|(3),
\&\fIguestfs\-java\fR\|(3),
\&\fIguestfs\-lua\fR\|(3),
\&\fIguestfs\-perl\fR\|(3),
\&\fIguestfs\-python\fR\|(3),
\&\fIguestfs\-recipes\fR\|(1),
\&\fIguestfs\-ruby\fR\|(3),
http://libguestfs.org/,
http://caml.inria.fr/.
.SH "AUTHORS"
.IX Header "AUTHORS"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2010\-2012 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
This manual page contains examples which we hope you will use in
your programs.  The examples may be freely copied, modified and
distributed for any purpose without any restrictions.
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
