/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Guestfs.xs. Do not edit this file, edit Guestfs.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Guestfs.xs"
/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED FROM:
 *   generator/ *.ml
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009-2015 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <config.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <errno.h>

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* perl CORE/config.h defines '_' to something completely bonkers. */
#ifdef _
#undef _
#endif

#include <guestfs.h>
#include "guestfs-internal-frontend.h"

static SV *
my_newSVll(long long val) {
#ifdef USE_64_BIT_ALL
  return newSViv(val);
#else
  char buf[100];
  int len;
  len = snprintf(buf, 100, "%" PRId64, val);
  return newSVpv(buf, len);
#endif
}

static SV *
my_newSVull(unsigned long long val) {
#ifdef USE_64_BIT_ALL
  return newSVuv(val);
#else
  char buf[100];
  int len;
  len = snprintf(buf, 100, "%" PRIu64, val);
  return newSVpv(buf, len);
#endif
}

/* Convert a 64 bit int on input.  To cope with the case of having
 * a 32 bit Perl interpreter, we allow the user to pass a string
 * here which is scanned as a 64 bit integer.
 */
static int64_t
my_SvIV64 (SV *sv)
{
#ifdef USE_64_BIT_ALL
  return SvIV (sv);
#else
  if (SvTYPE (sv) == SVt_PV) {
    const char *str = SvPV_nolen (sv);
    int64_t r;

    sscanf (str, "%" SCNi64, &r);
    return r;
  }
  else
    return SvIV (sv);
#endif
}

/* http://www.perlmonks.org/?node_id=680842 */
static char **
XS_unpack_charPtrPtr (SV *arg) {
  char **ret;
  AV *av;
  I32 i;

  if (!arg || !SvOK (arg) || !SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
    croak ("array reference expected");

  av = (AV *)SvRV (arg);
  ret = malloc ((av_len (av) + 1 + 1) * sizeof (char *));
  if (!ret)
    croak ("malloc failed");

  for (i = 0; i <= av_len (av); i++) {
    SV **elem = av_fetch (av, i, 0);

    if (!elem || !*elem)
      croak ("missing element in list");

    ret[i] = SvPV_nolen (*elem);
  }

  ret[i] = NULL;

  return ret;
}

/* http://www.perlmonks.org/?node=338857 */
static void
_event_callback_wrapper (guestfs_h *g,
                         void *cb,
                         uint64_t event,
                         int event_handle,
                         int flags,
                         const char *buf, size_t buf_len,
                         const uint64_t *array, size_t array_len)
{
  dSP;
  ENTER;
  SAVETMPS;
  PUSHMARK (SP);
  XPUSHs (sv_2mortal (my_newSVull (event)));
  XPUSHs (sv_2mortal (newSViv (event_handle)));
  XPUSHs (sv_2mortal (newSVpvn (buf ? buf : "", buf_len)));
  AV *av = newAV ();
  size_t i;
  for (i = 0; i < array_len; ++i)
    av_push (av, my_newSVull (array[i]));
  XPUSHs (sv_2mortal (newRV ((SV *) av)));
  PUTBACK;
  call_sv ((SV *) cb, G_VOID | G_DISCARD | G_EVAL);
  FREETMPS;
  LEAVE;
}

static SV **
get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
{
  SV **r;
  size_t i;
  const char *key;
  SV *cb;

  /* Count the length of the array that will be needed. */
  *len_rtn = 0;
  cb = guestfs_first_private (g, &key);
  while (cb != NULL) {
    if (strncmp (key, "_perl_event_", strlen ("_perl_event_")) == 0)
      (*len_rtn)++;
    cb = guestfs_next_private (g, &key);
  }

  /* Copy them into the return array. */
  r = guestfs_int_safe_malloc (g, sizeof (SV *) * (*len_rtn));

  i = 0;
  cb = guestfs_first_private (g, &key);
  while (cb != NULL) {
    if (strncmp (key, "_perl_event_", strlen ("_perl_event_")) == 0) {
      r[i] = cb;
      i++;
    }
    cb = guestfs_next_private (g, &key);
  }

  return r;
}

static void
_close_handle (guestfs_h *g)
{
  size_t i, len;
  SV **cbs;

  assert (g != NULL);

  /* As in the OCaml bindings, there is a hard to solve case where the
   * caller can delete a callback from within the callback, resulting
   * in a double-free here.  XXX
   */
  cbs = get_all_event_callbacks (g, &len);

  guestfs_close (g);

  for (i = 0; i < len; ++i)
    SvREFCNT_dec (cbs[i]);
  free (cbs);
}

#line 210 "Guestfs.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 262 "Guestfs.c"

XS(XS_Sys__Guestfs__create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs__create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "flags");
    {
	unsigned	flags = (unsigned)SvUV(ST(0));
	guestfs_h *	RETVAL;
	dXSTARG;
#line 208 "Guestfs.xs"
      RETVAL = guestfs_create_flags (flags);
      if (!RETVAL)
        croak ("could not create guestfs handle");
      guestfs_set_error_handler (RETVAL, NULL, NULL);
#line 283 "Guestfs.c"
	XSprePUSH; PUSHi(PTR2IV (RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0);
#line 219 "Guestfs.xs"
      /* For the 'g' argument above we do the conversion explicitly and
       * don't rely on the typemap, because if the handle has been
       * explicitly closed we don't want the typemap conversion to
       * display an error.
       */
      HV *hv = (HV *) SvRV (sv);
      SV **svp = hv_fetch (hv, "_g", 2, 0);
      if (svp != NULL) {
        guestfs_h *g = (guestfs_h *) SvIV (*svp);
        _close_handle (g);
      }
#line 316 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::close(): g is not a blessed HV reference");
    };
#line 235 "Guestfs.xs"
      _close_handle (g);
      /* Avoid double-free in DESTROY method. */
      HV *hv = (HV *) SvRV (ST(0));
      (void) hv_delete (hv, "_g", 2, G_DISCARD);
#line 354 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_event_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_event_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, cb, event_bitmask");
    {
	guestfs_h *	g;
	SV *	cb = ST(1);
	int	event_bitmask = (int)SvIV(ST(2));
#line 246 "Guestfs.xs"
      int eh;
      char key[64];
#line 378 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_event_callback(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_event_callback(): g is not a blessed HV reference");
    };
#line 249 "Guestfs.xs"
      eh = guestfs_set_event_callback (g, _event_callback_wrapper,
                                       event_bitmask, 0, cb);
      if (eh == -1)
        croak ("%s", guestfs_last_error (g));

      /* Increase the refcount for this callback, since we are storing
       * it in the opaque C libguestfs handle.  We need to remember that
       * we did this, so we can decrease the refcount for all undeleted
       * callbacks left around at close time (see _close_handle).
       */
      SvREFCNT_inc (cb);

      snprintf (key, sizeof key, "_perl_event_%d", eh);
      guestfs_set_private (g, key, cb);

      RETVAL = newSViv (eh);
#line 409 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_delete_event_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_delete_event_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, event_handle");
    {
	guestfs_h *	g;
	int	event_handle = (int)SvIV(ST(1));
#line 273 "Guestfs.xs"
      char key[64];
      SV *cb;
#line 433 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::delete_event_callback(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::delete_event_callback(): g is not a blessed HV reference");
    };
#line 276 "Guestfs.xs"
      snprintf (key, sizeof key, "_perl_event_%d", event_handle);
      cb = guestfs_get_private (g, key);
      if (cb) {
        SvREFCNT_dec (cb);
        guestfs_set_private (g, key, NULL);
        guestfs_delete_event_callback (g, event_handle);
      }
#line 454 "Guestfs.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Sys__Guestfs_event_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_event_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "event_bitmask");
    {
	int	event_bitmask = (int)SvIV(ST(0));
#line 288 "Guestfs.xs"
      char *str;
#line 474 "Guestfs.c"
	SV *	RETVAL;
#line 290 "Guestfs.xs"
      str = guestfs_event_to_string (event_bitmask);
      if (str == NULL)
        croak ("%s", strerror (errno));
      RETVAL = newSVpv (str, 0);
      free (str);
#line 482 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_last_errno); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_last_errno)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 302 "Guestfs.xs"
      int errnum;
#line 504 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::last_errno(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::last_errno(): g is not a blessed HV reference");
    };
#line 304 "Guestfs.xs"
      errnum = guestfs_last_errno (g);
      RETVAL = newSViv (errnum);
#line 521 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_acl_delete_def_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_acl_delete_def_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
#line 314 "Guestfs.xs"
      int r;
#line 546 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::acl_delete_def_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::acl_delete_def_file(): g is not a blessed HV reference");
    };
#line 316 "Guestfs.xs"
      r = guestfs_acl_delete_def_file (g, dir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 563 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_acl_get_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_acl_get_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, acltype");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	acltype = (char *)SvPV_nolen(ST(2));
#line 326 "Guestfs.xs"
      char *r;
#line 586 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::acl_get_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::acl_get_file(): g is not a blessed HV reference");
    };
#line 328 "Guestfs.xs"
      r = guestfs_acl_get_file (g, path, acltype);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 606 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_acl_set_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_acl_set_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, acltype, acl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	acltype = (char *)SvPV_nolen(ST(2));
	char *	acl = (char *)SvPV_nolen(ST(3));
#line 343 "Guestfs.xs"
      int r;
#line 633 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::acl_set_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::acl_set_file(): g is not a blessed HV reference");
    };
#line 345 "Guestfs.xs"
      r = guestfs_acl_set_file (g, path, acltype, acl);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 650 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_cdrom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_cdrom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 354 "Guestfs.xs"
      int r;
#line 674 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_cdrom(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_cdrom(): g is not a blessed HV reference");
    };
#line 356 "Guestfs.xs"
      r = guestfs_add_cdrom (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 691 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_domain); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_domain)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, dom, ...");
    {
	guestfs_h *	g;
	char *	dom = (char *)SvPV_nolen(ST(1));
#line 365 "Guestfs.xs"
      int r;
      struct guestfs_add_domain_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_domain_argv *optargs = &optargs_s;
      size_t items_i;
#line 716 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_domain(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_domain(): g is not a blessed HV reference");
    };
#line 370 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "libvirturi")) {
          optargs_s.libvirturi = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_LIBVIRTURI_BITMASK;
        }
        else if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "iface")) {
          optargs_s.iface = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_IFACE_BITMASK;
        }
        else if (STREQ (this_arg, "live")) {
          optargs_s.live = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_LIVE_BITMASK;
        }
        else if (STREQ (this_arg, "allowuuid")) {
          optargs_s.allowuuid = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_ALLOWUUID_BITMASK;
        }
        else if (STREQ (this_arg, "readonlydisk")) {
          optargs_s.readonlydisk = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_READONLYDISK_BITMASK;
        }
        else if (STREQ (this_arg, "cachemode")) {
          optargs_s.cachemode = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_CACHEMODE_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "copyonread")) {
          optargs_s.copyonread = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_COPYONREAD_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_domain_argv (g, dom, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 785 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_add_drive); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, filename, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 432 "Guestfs.xs"
      int r;
      struct guestfs_add_drive_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_drive_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 813 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive(): g is not a blessed HV reference");
    };
#line 437 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "format")) {
          optargs_s.format = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK;
        }
        else if (STREQ (this_arg, "iface")) {
          optargs_s.iface = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_IFACE_BITMASK;
        }
        else if (STREQ (this_arg, "name")) {
          optargs_s.name = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_NAME_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "protocol")) {
          optargs_s.protocol = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_PROTOCOL_BITMASK;
        }
        else if (STREQ (this_arg, "server")) {
          size_t i, len;
          char **r;
          SV *arg;
          AV *av;
          SV **svp;

          arg = ST (items_i+1);
          if (!SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
            croak ("array reference expected for '%s' argument", "server");
          av = (AV *) SvRV (ST (items_i+1));

          /* Note av_len returns index of final element. */
          len = av_len (av) + 1;

          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));
          for (i = 0; i < len; ++i) {
            svp = av_fetch (av, i, 0);
            r[i] = SvPV_nolen (*svp);
          }
          r[i] = NULL;
          optargs_s.server = r;
          this_mask = GUESTFS_ADD_DRIVE_OPTS_SERVER_BITMASK;
        }
        else if (STREQ (this_arg, "username")) {
          optargs_s.username = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_USERNAME_BITMASK;
        }
        else if (STREQ (this_arg, "secret")) {
          optargs_s.secret = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_SECRET_BITMASK;
        }
        else if (STREQ (this_arg, "cachemode")) {
          optargs_s.cachemode = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_CACHEMODE_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "copyonread")) {
          optargs_s.copyonread = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_COPYONREAD_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_drive_opts_argv (g, filename, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 912 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_ro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_ro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 528 "Guestfs.xs"
      int r;
#line 936 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_ro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_ro(): g is not a blessed HV reference");
    };
#line 530 "Guestfs.xs"
      r = guestfs_add_drive_ro (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 953 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_ro_with_if); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_ro_with_if)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, iface");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	iface = (char *)SvPV_nolen(ST(2));
#line 540 "Guestfs.xs"
      int r;
#line 978 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_ro_with_if(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_ro_with_if(): g is not a blessed HV reference");
    };
#line 542 "Guestfs.xs"
      r = guestfs_add_drive_ro_with_if (g, filename, iface);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 995 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_scratch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_scratch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, size, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    size = my_SvIV64 (ST(1));
#line 551 "Guestfs.xs"
      int r;
      struct guestfs_add_drive_scratch_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_drive_scratch_argv *optargs = &optargs_s;
      size_t items_i;
#line 1022 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_scratch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_scratch(): g is not a blessed HV reference");
    };
#line 556 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "name")) {
          optargs_s.name = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_SCRATCH_NAME_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_SCRATCH_LABEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_drive_scratch_argv (g, size, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1061 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_with_if); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_with_if)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, iface");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	iface = (char *)SvPV_nolen(ST(2));
#line 588 "Guestfs.xs"
      int r;
#line 1086 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_with_if(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_with_if(): g is not a blessed HV reference");
    };
#line 590 "Guestfs.xs"
      r = guestfs_add_drive_with_if (g, filename, iface);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1103 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_libvirt_dom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_libvirt_dom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, dom, ...");
    {
	guestfs_h *	g;
	void * /* virDomainPtr */	dom;
#line 599 "Guestfs.xs"
      int r;
      struct guestfs_add_libvirt_dom_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_libvirt_dom_argv *optargs = &optargs_s;
      size_t items_i;
#line 1128 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_libvirt_dom(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_libvirt_dom(): g is not a blessed HV reference");
    };

    /* This is copied directly from the Sys::Virt typemap.  Dan has assured
     * me that he doesn't intend to change this implementation!
     */
    if (sv_isobject (ST(1)) && SvTYPE (SvRV (ST(1))) == SVt_PVMG)
        dom = INT2PTR (void *, SvIV ((SV*) SvRV (ST(1))));
    else {
        warn ("Sys::Guestfs::add_libvirt_dom() -- dom is not a blessed SV reference");
        XSRETURN_UNDEF;
    };
#line 604 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "iface")) {
          optargs_s.iface = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_IFACE_BITMASK;
        }
        else if (STREQ (this_arg, "live")) {
          optargs_s.live = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_LIVE_BITMASK;
        }
        else if (STREQ (this_arg, "readonlydisk")) {
          optargs_s.readonlydisk = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_READONLYDISK_BITMASK;
        }
        else if (STREQ (this_arg, "cachemode")) {
          optargs_s.cachemode = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_CACHEMODE_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "copyonread")) {
          optargs_s.copyonread = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_COPYONREAD_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_libvirt_dom_argv (g, dom, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1199 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_clear); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_clear)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 658 "Guestfs.xs"
      int r;
#line 1224 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_clear(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_clear(): g is not a blessed HV reference");
    };
#line 660 "Guestfs.xs"
      r = guestfs_aug_clear (g, augpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1241 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 668 "Guestfs.xs"
      int r;
#line 1264 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_close(): g is not a blessed HV reference");
    };
#line 670 "Guestfs.xs"
      r = guestfs_aug_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1281 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_defnode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_defnode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, name, expr, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char *	expr = (char *)SvPV_nolen(ST(2));
	char *	val = (char *)SvPV_nolen(ST(3));
#line 681 "Guestfs.xs"
      struct guestfs_int_bool *r;
#line 1307 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_defnode(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_defnode(): g is not a blessed HV reference");
    };
#line 683 "Guestfs.xs"
      r = guestfs_aug_defnode (g, name, expr, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 2);
      PUSHs (sv_2mortal (newSVpv ("i", 0)));
      PUSHs (sv_2mortal (newSVnv (r->i)));
      PUSHs (sv_2mortal (newSVpv ("b", 0)));
      PUSHs (sv_2mortal (newSVnv (r->b)));
      free (r);
#line 1330 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_defvar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_defvar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, name, expr");
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char *	expr = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
#line 699 "Guestfs.xs"
      int r;
#line 1353 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_defvar(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_defvar(): g is not a blessed HV reference");
    };
#line 701 "Guestfs.xs"
      r = guestfs_aug_defvar (g, name, expr);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1372 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 713 "Guestfs.xs"
      char *r;
#line 1395 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_get(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_get(): g is not a blessed HV reference");
    };
#line 715 "Guestfs.xs"
      r = guestfs_aug_get (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 1415 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, root, flags");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
	int	flags = (int)SvIV(ST(2));
#line 729 "Guestfs.xs"
      int r;
#line 1441 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_init(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_init(): g is not a blessed HV reference");
    };
#line 731 "Guestfs.xs"
      r = guestfs_aug_init (g, root, flags);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1458 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_insert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_insert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, augpath, label, before");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
	int	before = (int)SvIV(ST(3));
#line 742 "Guestfs.xs"
      int r;
#line 1484 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_insert(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_insert(): g is not a blessed HV reference");
    };
#line 744 "Guestfs.xs"
      r = guestfs_aug_insert (g, augpath, label, before);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1501 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 753 "Guestfs.xs"
      char *r;
#line 1523 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_label(): g is not a blessed HV reference");
    };
#line 755 "Guestfs.xs"
      r = guestfs_aug_label (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 1543 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_load); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_load)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 767 "Guestfs.xs"
      int r;
#line 1567 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_load(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_load(): g is not a blessed HV reference");
    };
#line 769 "Guestfs.xs"
      r = guestfs_aug_load (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1584 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_ls); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_ls)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 778 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 1609 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_ls(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_ls(): g is not a blessed HV reference");
    };
#line 781 "Guestfs.xs"
      r = guestfs_aug_ls (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 1633 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_match); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_match)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 797 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 1658 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_match(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_match(): g is not a blessed HV reference");
    };
#line 800 "Guestfs.xs"
      r = guestfs_aug_match (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 1682 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_mv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_mv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 817 "Guestfs.xs"
      int r;
#line 1707 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_mv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_mv(): g is not a blessed HV reference");
    };
#line 819 "Guestfs.xs"
      r = guestfs_aug_mv (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1724 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_rm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_rm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 828 "Guestfs.xs"
      int r;
#line 1746 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_rm(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_rm(): g is not a blessed HV reference");
    };
#line 830 "Guestfs.xs"
      r = guestfs_aug_rm (g, augpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1765 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_save); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_save)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 841 "Guestfs.xs"
      int r;
#line 1789 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_save(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_save(): g is not a blessed HV reference");
    };
#line 843 "Guestfs.xs"
      r = guestfs_aug_save (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1806 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, augpath, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
#line 853 "Guestfs.xs"
      int r;
#line 1831 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_set(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_set(): g is not a blessed HV reference");
    };
#line 855 "Guestfs.xs"
      r = guestfs_aug_set (g, augpath, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1848 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_setm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_setm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, base, sub, val");
    {
	guestfs_h *	g;
	char *	base = (char *)SvPV_nolen(ST(1));
	char *	sub = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
	char *	val = (char *)SvPV_nolen(ST(3));
#line 866 "Guestfs.xs"
      int r;
#line 1872 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_setm(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_setm(): g is not a blessed HV reference");
    };
#line 868 "Guestfs.xs"
      r = guestfs_aug_setm (g, base, sub, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1891 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_available); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_available)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, groups");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	groups = XS_unpack_charPtrPtr(ST(1));
#line 880 "Guestfs.xs"
      int r;
#line 1916 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::available(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::available(): g is not a blessed HV reference");
    };
#line 882 "Guestfs.xs"
      r = guestfs_available (g, groups);
      free (groups);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1934 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_available_all_groups); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_available_all_groups)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 891 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 1958 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::available_all_groups(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::available_all_groups(): g is not a blessed HV reference");
    };
#line 894 "Guestfs.xs"
      r = guestfs_available_all_groups (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 1982 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_base64_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_base64_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, base64file, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	base64file = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
#line 911 "Guestfs.xs"
      int r;
#line 2007 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::base64_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::base64_in(): g is not a blessed HV reference");
    };
#line 913 "Guestfs.xs"
      r = guestfs_base64_in (g, base64file, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2024 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_base64_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_base64_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, base64file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	base64file = (char *)SvPV_nolen(ST(2));
#line 923 "Guestfs.xs"
      int r;
#line 2049 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::base64_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::base64_out(): g is not a blessed HV reference");
    };
#line 925 "Guestfs.xs"
      r = guestfs_base64_out (g, filename, base64file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2066 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blkdiscard); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blkdiscard)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 934 "Guestfs.xs"
      int r;
#line 2090 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blkdiscard(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blkdiscard(): g is not a blessed HV reference");
    };
#line 936 "Guestfs.xs"
      r = guestfs_blkdiscard (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2107 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blkdiscardzeroes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blkdiscardzeroes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 945 "Guestfs.xs"
      int r;
#line 2129 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blkdiscardzeroes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blkdiscardzeroes(): g is not a blessed HV reference");
    };
#line 947 "Guestfs.xs"
      r = guestfs_blkdiscardzeroes (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2148 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blkid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blkid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 959 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 2174 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blkid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blkid(): g is not a blessed HV reference");
    };
#line 962 "Guestfs.xs"
      r = guestfs_blkid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 2198 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_flushbufs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_flushbufs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 978 "Guestfs.xs"
      int r;
#line 2222 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_flushbufs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_flushbufs(): g is not a blessed HV reference");
    };
#line 980 "Guestfs.xs"
      r = guestfs_blockdev_flushbufs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2239 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_getbsz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getbsz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 989 "Guestfs.xs"
      int r;
#line 2261 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getbsz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getbsz(): g is not a blessed HV reference");
    };
#line 991 "Guestfs.xs"
      r = guestfs_blockdev_getbsz (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2280 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1003 "Guestfs.xs"
      int r;
#line 2303 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getro(): g is not a blessed HV reference");
    };
#line 1005 "Guestfs.xs"
      r = guestfs_blockdev_getro (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2322 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getsize64); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getsize64)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1017 "Guestfs.xs"
      int64_t r;
#line 2345 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getsize64(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getsize64(): g is not a blessed HV reference");
    };
#line 1019 "Guestfs.xs"
      r = guestfs_blockdev_getsize64 (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 2364 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getss); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getss)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1031 "Guestfs.xs"
      int r;
#line 2387 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getss(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getss(): g is not a blessed HV reference");
    };
#line 1033 "Guestfs.xs"
      r = guestfs_blockdev_getss (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2406 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getsz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getsz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1045 "Guestfs.xs"
      int64_t r;
#line 2429 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getsz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getsz(): g is not a blessed HV reference");
    };
#line 1047 "Guestfs.xs"
      r = guestfs_blockdev_getsz (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 2448 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_rereadpt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_rereadpt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1059 "Guestfs.xs"
      int r;
#line 2473 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_rereadpt(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_rereadpt(): g is not a blessed HV reference");
    };
#line 1061 "Guestfs.xs"
      r = guestfs_blockdev_rereadpt (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2490 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setbsz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setbsz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, blocksize");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
#line 1071 "Guestfs.xs"
      int r;
#line 2515 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setbsz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setbsz(): g is not a blessed HV reference");
    };
#line 1073 "Guestfs.xs"
      r = guestfs_blockdev_setbsz (g, device, blocksize);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2532 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setra); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setra)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, sectors");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	sectors = (int)SvIV(ST(2));
#line 1083 "Guestfs.xs"
      int r;
#line 2557 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setra(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setra(): g is not a blessed HV reference");
    };
#line 1085 "Guestfs.xs"
      r = guestfs_blockdev_setra (g, device, sectors);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2574 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1094 "Guestfs.xs"
      int r;
#line 2598 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setro(): g is not a blessed HV reference");
    };
#line 1096 "Guestfs.xs"
      r = guestfs_blockdev_setro (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2615 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setrw); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setrw)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1105 "Guestfs.xs"
      int r;
#line 2639 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setrw(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setrw(): g is not a blessed HV reference");
    };
#line 1107 "Guestfs.xs"
      r = guestfs_blockdev_setrw (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2656 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1116 "Guestfs.xs"
      int r;
#line 2680 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_cancel(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_cancel(): g is not a blessed HV reference");
    };
#line 1118 "Guestfs.xs"
      r = guestfs_btrfs_balance_cancel (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2697 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_pause); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_pause)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1127 "Guestfs.xs"
      int r;
#line 2721 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_pause(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_pause(): g is not a blessed HV reference");
    };
#line 1129 "Guestfs.xs"
      r = guestfs_btrfs_balance_pause (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2738 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_resume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_resume)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1138 "Guestfs.xs"
      int r;
#line 2762 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_resume(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_resume(): g is not a blessed HV reference");
    };
#line 1140 "Guestfs.xs"
      r = guestfs_btrfs_balance_resume (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2779 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_status); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_status)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1149 "Guestfs.xs"
      struct guestfs_btrfsbalance *r;
#line 2803 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_status(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_status(): g is not a blessed HV reference");
    };
#line 1151 "Guestfs.xs"
      r = guestfs_btrfs_balance_status (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 5);
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_status", 0)));
      PUSHs (sv_2mortal (newSVpv (r->btrfsbalance_status, 0)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_total", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_total)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_balanced", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_balanced)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_considered", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_considered)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_left", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_left)));
      free (r);
#line 2832 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_device_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_device_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, devices, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
	char *	fs = (char *)SvPV_nolen(ST(2));
#line 1173 "Guestfs.xs"
      int r;
#line 2857 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_device_add(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_device_add(): g is not a blessed HV reference");
    };
#line 1175 "Guestfs.xs"
      r = guestfs_btrfs_device_add (g, devices, fs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2875 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_device_delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_device_delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, devices, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
	char *	fs = (char *)SvPV_nolen(ST(2));
#line 1186 "Guestfs.xs"
      int r;
#line 2900 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_device_delete(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_device_delete(): g is not a blessed HV reference");
    };
#line 1188 "Guestfs.xs"
      r = guestfs_btrfs_device_delete (g, devices, fs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2918 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_balance); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_balance)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1198 "Guestfs.xs"
      int r;
#line 2942 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_balance(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_balance(): g is not a blessed HV reference");
    };
#line 1200 "Guestfs.xs"
      r = guestfs_btrfs_filesystem_balance (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2959 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_defragment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_defragment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1209 "Guestfs.xs"
      int r;
      struct guestfs_btrfs_filesystem_defragment_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_filesystem_defragment_argv *optargs = &optargs_s;
      size_t items_i;
#line 2986 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_defragment(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_defragment(): g is not a blessed HV reference");
    };
#line 1214 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "flush")) {
          optargs_s.flush = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_FLUSH_BITMASK;
        }
        else if (STREQ (this_arg, "compress")) {
          optargs_s.compress = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_COMPRESS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_filesystem_defragment_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3025 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_resize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_resize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 1245 "Guestfs.xs"
      int r;
      struct guestfs_btrfs_filesystem_resize_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_filesystem_resize_argv *optargs = &optargs_s;
      size_t items_i;
#line 3052 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_resize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_resize(): g is not a blessed HV reference");
    };
#line 1250 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_filesystem_resize_argv (g, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3087 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_sync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_sync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1277 "Guestfs.xs"
      int r;
#line 3111 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_sync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_sync(): g is not a blessed HV reference");
    };
#line 1279 "Guestfs.xs"
      r = guestfs_btrfs_filesystem_sync (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3128 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_fsck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_fsck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1288 "Guestfs.xs"
      int r;
      struct guestfs_btrfs_fsck_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_fsck_argv *optargs = &optargs_s;
      size_t items_i;
#line 3155 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_fsck(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_fsck(): g is not a blessed HV reference");
    };
#line 1293 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "superblock")) {
          optargs_s.superblock = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FSCK_SUPERBLOCK_BITMASK;
        }
        else if (STREQ (this_arg, "repair")) {
          optargs_s.repair = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FSCK_REPAIR_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_fsck_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3194 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_image); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_image)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, source, image, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	source = XS_unpack_charPtrPtr(ST(1));
	char *	image = (char *)SvPV_nolen(ST(2));
#line 1325 "Guestfs.xs"
      int r;
      struct guestfs_btrfs_image_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_image_argv *optargs = &optargs_s;
      size_t items_i;
#line 3222 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_image(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_image(): g is not a blessed HV reference");
    };
#line 1330 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "compresslevel")) {
          optargs_s.compresslevel = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_IMAGE_COMPRESSLEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_image_argv (g, source, image, optargs);
      free (source);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3258 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_assign); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_assign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, src, dst, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dst = (char *)SvPV_nolen(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 1360 "Guestfs.xs"
      int r;
#line 3284 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_assign(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_assign(): g is not a blessed HV reference");
    };
#line 1362 "Guestfs.xs"
      r = guestfs_btrfs_qgroup_assign (g, src, dst, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3301 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, qgroupid, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	qgroupid = (char *)SvPV_nolen(ST(1));
	char *	subvolume = (char *)SvPV_nolen(ST(2));
#line 1372 "Guestfs.xs"
      int r;
#line 3326 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_create(): g is not a blessed HV reference");
    };
#line 1374 "Guestfs.xs"
      r = guestfs_btrfs_qgroup_create (g, qgroupid, subvolume);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3343 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, qgroupid, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	qgroupid = (char *)SvPV_nolen(ST(1));
	char *	subvolume = (char *)SvPV_nolen(ST(2));
#line 1384 "Guestfs.xs"
      int r;
#line 3368 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_destroy(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_destroy(): g is not a blessed HV reference");
    };
#line 1386 "Guestfs.xs"
      r = guestfs_btrfs_qgroup_destroy (g, qgroupid, subvolume);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3385 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_limit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_limit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, subvolume, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	subvolume = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 1396 "Guestfs.xs"
      int r;
#line 3410 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_limit(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_limit(): g is not a blessed HV reference");
    };
#line 1398 "Guestfs.xs"
      r = guestfs_btrfs_qgroup_limit (g, subvolume, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3427 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_remove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_remove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, src, dst, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dst = (char *)SvPV_nolen(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 1409 "Guestfs.xs"
      int r;
#line 3453 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_remove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_remove(): g is not a blessed HV reference");
    };
#line 1411 "Guestfs.xs"
      r = guestfs_btrfs_qgroup_remove (g, src, dst, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3470 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_show); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_show)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1420 "Guestfs.xs"
      struct guestfs_btrfsqgroup_list *r;
      size_t i;
      HV *hv;
#line 3496 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_show(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_show(): g is not a blessed HV reference");
    };
#line 1424 "Guestfs.xs"
      r = guestfs_btrfs_qgroup_show (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "btrfsqgroup_id", 14, newSVpv (r->val[i].btrfsqgroup_id, 0), 0);
        (void) hv_store (hv, "btrfsqgroup_rfer", 16, my_newSVull (r->val[i].btrfsqgroup_rfer), 0);
        (void) hv_store (hv, "btrfsqgroup_excl", 16, my_newSVull (r->val[i].btrfsqgroup_excl), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_btrfsqgroup_list (r);
#line 3522 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_quota_enable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_quota_enable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, fs, enable");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
	int	enable = (int)SvIV(ST(2));
#line 1443 "Guestfs.xs"
      int r;
#line 3547 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_quota_enable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_quota_enable(): g is not a blessed HV reference");
    };
#line 1445 "Guestfs.xs"
      r = guestfs_btrfs_quota_enable (g, fs, enable);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3564 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_quota_rescan); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_quota_rescan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1454 "Guestfs.xs"
      int r;
#line 3588 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_quota_rescan(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_quota_rescan(): g is not a blessed HV reference");
    };
#line 1456 "Guestfs.xs"
      r = guestfs_btrfs_quota_rescan (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3605 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_replace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_replace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, srcdev, targetdev, mntpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	srcdev = (char *)SvPV_nolen(ST(1));
	char *	targetdev = (char *)SvPV_nolen(ST(2));
	char *	mntpoint = (char *)SvPV_nolen(ST(3));
#line 1467 "Guestfs.xs"
      int r;
#line 3631 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_replace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_replace(): g is not a blessed HV reference");
    };
#line 1469 "Guestfs.xs"
      r = guestfs_btrfs_replace (g, srcdev, targetdev, mntpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3648 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_rescue_chunk_recover); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_rescue_chunk_recover)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1478 "Guestfs.xs"
      int r;
#line 3672 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_rescue_chunk_recover(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_rescue_chunk_recover(): g is not a blessed HV reference");
    };
#line 1480 "Guestfs.xs"
      r = guestfs_btrfs_rescue_chunk_recover (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3689 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_rescue_super_recover); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_rescue_super_recover)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1489 "Guestfs.xs"
      int r;
#line 3713 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_rescue_super_recover(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_rescue_super_recover(): g is not a blessed HV reference");
    };
#line 1491 "Guestfs.xs"
      r = guestfs_btrfs_rescue_super_recover (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3730 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1500 "Guestfs.xs"
      int r;
#line 3754 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_cancel(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_cancel(): g is not a blessed HV reference");
    };
#line 1502 "Guestfs.xs"
      r = guestfs_btrfs_scrub_cancel (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3771 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_resume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_resume)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1511 "Guestfs.xs"
      int r;
#line 3795 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_resume(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_resume(): g is not a blessed HV reference");
    };
#line 1513 "Guestfs.xs"
      r = guestfs_btrfs_scrub_resume (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3812 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_start)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1522 "Guestfs.xs"
      int r;
#line 3836 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_start(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_start(): g is not a blessed HV reference");
    };
#line 1524 "Guestfs.xs"
      r = guestfs_btrfs_scrub_start (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3853 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_status); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_status)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1533 "Guestfs.xs"
      struct guestfs_btrfsscrub *r;
#line 3877 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_status(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_status(): g is not a blessed HV reference");
    };
#line 1535 "Guestfs.xs"
      r = guestfs_btrfs_scrub_status (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 15);
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_data_extents_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_data_extents_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_tree_extents_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_tree_extents_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_data_bytes_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_data_bytes_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_tree_bytes_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_tree_bytes_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_read_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_read_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_csum_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_csum_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_verify_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_verify_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_no_csum", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_no_csum)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_csum_discards", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_csum_discards)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_super_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_super_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_malloc_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_malloc_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_uncorrectable_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_uncorrectable_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_unverified_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_unverified_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_corrected_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_corrected_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_last_physical", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_last_physical)));
      free (r);
#line 3926 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_set_seeding); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_set_seeding)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, seeding");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	seeding = (int)SvIV(ST(2));
#line 1577 "Guestfs.xs"
      int r;
#line 3951 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_set_seeding(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_set_seeding(): g is not a blessed HV reference");
    };
#line 1579 "Guestfs.xs"
      r = guestfs_btrfs_set_seeding (g, device, seeding);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3968 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dest = (char *)SvPV_nolen(ST(1));
#line 1588 "Guestfs.xs"
      int r;
      struct guestfs_btrfs_subvolume_create_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_subvolume_create_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 3995 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_create(): g is not a blessed HV reference");
    };
#line 1593 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "qgroupid")) {
          optargs_s.qgroupid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_SUBVOLUME_CREATE_OPTS_QGROUPID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_subvolume_create_opts_argv (g, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4030 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	subvolume = (char *)SvPV_nolen(ST(1));
#line 1620 "Guestfs.xs"
      int r;
#line 4054 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_delete(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_delete(): g is not a blessed HV reference");
    };
#line 1622 "Guestfs.xs"
      r = guestfs_btrfs_subvolume_delete (g, subvolume);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4071 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_get_default); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_get_default)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1631 "Guestfs.xs"
      int64_t r;
#line 4093 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_get_default(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_get_default(): g is not a blessed HV reference");
    };
#line 1633 "Guestfs.xs"
      r = guestfs_btrfs_subvolume_get_default (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 4112 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_btrfs_subvolume_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1645 "Guestfs.xs"
      struct guestfs_btrfssubvolume_list *r;
      size_t i;
      HV *hv;
#line 4139 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_list(): g is not a blessed HV reference");
    };
#line 1649 "Guestfs.xs"
      r = guestfs_btrfs_subvolume_list (g, fs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "btrfssubvolume_id", 17, my_newSVull (r->val[i].btrfssubvolume_id), 0);
        (void) hv_store (hv, "btrfssubvolume_top_level_id", 27, my_newSVull (r->val[i].btrfssubvolume_top_level_id), 0);
        (void) hv_store (hv, "btrfssubvolume_path", 19, newSVpv (r->val[i].btrfssubvolume_path, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_btrfssubvolume_list (r);
#line 4165 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_set_default); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_set_default)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, id, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    id = my_SvIV64 (ST(1));
	char *	fs = (char *)SvPV_nolen(ST(2));
#line 1668 "Guestfs.xs"
      int r;
#line 4190 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_set_default(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_set_default(): g is not a blessed HV reference");
    };
#line 1670 "Guestfs.xs"
      r = guestfs_btrfs_subvolume_set_default (g, id, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4207 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_show); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_show)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	subvolume = (char *)SvPV_nolen(ST(1));
#line 1679 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 4232 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_show(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_show(): g is not a blessed HV reference");
    };
#line 1682 "Guestfs.xs"
      r = guestfs_btrfs_subvolume_show (g, subvolume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 4256 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_snapshot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_snapshot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, source, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	source = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 1699 "Guestfs.xs"
      int r;
      struct guestfs_btrfs_subvolume_snapshot_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_subvolume_snapshot_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 4284 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_snapshot(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_snapshot(): g is not a blessed HV reference");
    };
#line 1704 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "ro")) {
          optargs_s.ro = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_RO_BITMASK;
        }
        else if (STREQ (this_arg, "qgroupid")) {
          optargs_s.qgroupid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_QGROUPID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_subvolume_snapshot_opts_argv (g, source, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4323 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfstune_enable_extended_inode_refs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfstune_enable_extended_inode_refs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1735 "Guestfs.xs"
      int r;
#line 4347 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfstune_enable_extended_inode_refs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfstune_enable_extended_inode_refs(): g is not a blessed HV reference");
    };
#line 1737 "Guestfs.xs"
      r = guestfs_btrfstune_enable_extended_inode_refs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4364 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfstune_enable_skinny_metadata_extent_refs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfstune_enable_skinny_metadata_extent_refs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1746 "Guestfs.xs"
      int r;
#line 4388 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfstune_enable_skinny_metadata_extent_refs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfstune_enable_skinny_metadata_extent_refs(): g is not a blessed HV reference");
    };
#line 1748 "Guestfs.xs"
      r = guestfs_btrfstune_enable_skinny_metadata_extent_refs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4405 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfstune_seeding); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfstune_seeding)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, seeding");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	seeding = (int)SvIV(ST(2));
#line 1758 "Guestfs.xs"
      int r;
#line 4430 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfstune_seeding(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfstune_seeding(): g is not a blessed HV reference");
    };
#line 1760 "Guestfs.xs"
      r = guestfs_btrfstune_seeding (g, device, seeding);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4447 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_c_pointer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_c_pointer)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 1768 "Guestfs.xs"
      int64_t r;
#line 4468 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::c_pointer(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::c_pointer(): g is not a blessed HV reference");
    };
#line 1770 "Guestfs.xs"
      r = guestfs_c_pointer (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 4487 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_canonical_device_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_canonical_device_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1782 "Guestfs.xs"
      char *r;
#line 4510 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::canonical_device_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::canonical_device_name(): g is not a blessed HV reference");
    };
#line 1784 "Guestfs.xs"
      r = guestfs_canonical_device_name (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4530 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_cap_get_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cap_get_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1797 "Guestfs.xs"
      char *r;
#line 4553 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cap_get_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cap_get_file(): g is not a blessed HV reference");
    };
#line 1799 "Guestfs.xs"
      r = guestfs_cap_get_file (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4573 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_cap_set_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cap_set_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, cap");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	cap = (char *)SvPV_nolen(ST(2));
#line 1813 "Guestfs.xs"
      int r;
#line 4599 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cap_set_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cap_set_file(): g is not a blessed HV reference");
    };
#line 1815 "Guestfs.xs"
      r = guestfs_cap_set_file (g, path, cap);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4616 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_case_sensitive_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_case_sensitive_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1824 "Guestfs.xs"
      char *r;
#line 4638 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::case_sensitive_path(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::case_sensitive_path(): g is not a blessed HV reference");
    };
#line 1826 "Guestfs.xs"
      r = guestfs_case_sensitive_path (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4658 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_cat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1839 "Guestfs.xs"
      char *r;
#line 4681 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cat(): g is not a blessed HV reference");
    };
#line 1841 "Guestfs.xs"
      r = guestfs_cat (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4701 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_checksum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_checksum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, csumtype, path");
    {
	guestfs_h *	g;
	char *	csumtype = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 1855 "Guestfs.xs"
      char *r;
#line 4725 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::checksum(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::checksum(): g is not a blessed HV reference");
    };
#line 1857 "Guestfs.xs"
      r = guestfs_checksum (g, csumtype, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4745 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_checksum_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_checksum_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, csumtype, device");
    {
	guestfs_h *	g;
	char *	csumtype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 1871 "Guestfs.xs"
      char *r;
#line 4769 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::checksum_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::checksum_device(): g is not a blessed HV reference");
    };
#line 1873 "Guestfs.xs"
      r = guestfs_checksum_device (g, csumtype, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4789 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_checksums_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_checksums_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, csumtype, directory, sumsfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	csumtype = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
	char *	sumsfile = (char *)SvPV_nolen(ST(3));
#line 1888 "Guestfs.xs"
      int r;
#line 4816 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::checksums_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::checksums_out(): g is not a blessed HV reference");
    };
#line 1890 "Guestfs.xs"
      r = guestfs_checksums_out (g, csumtype, directory, sumsfile);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4833 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_chmod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_chmod)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mode, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 1900 "Guestfs.xs"
      int r;
#line 4858 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::chmod(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::chmod(): g is not a blessed HV reference");
    };
#line 1902 "Guestfs.xs"
      r = guestfs_chmod (g, mode, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4875 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_chown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_chown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, owner, group, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	owner = (int)SvIV(ST(1));
	int	group = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 1913 "Guestfs.xs"
      int r;
#line 4901 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::chown(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::chown(): g is not a blessed HV reference");
    };
#line 1915 "Guestfs.xs"
      r = guestfs_chown (g, owner, group, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4918 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_clear_backend_setting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_clear_backend_setting)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, name");
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
#line 1924 "Guestfs.xs"
      int r;
#line 4940 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::clear_backend_setting(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::clear_backend_setting(): g is not a blessed HV reference");
    };
#line 1926 "Guestfs.xs"
      r = guestfs_clear_backend_setting (g, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 4959 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_command); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_command)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, arguments");
    {
	guestfs_h *	g;
	char **	arguments = XS_unpack_charPtrPtr(ST(1));
#line 1938 "Guestfs.xs"
      char *r;
#line 4982 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::command(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::command(): g is not a blessed HV reference");
    };
#line 1940 "Guestfs.xs"
      r = guestfs_command (g, arguments);
      free (arguments);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 5003 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_command_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_command_lines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, arguments");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	arguments = XS_unpack_charPtrPtr(ST(1));
#line 1954 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 5029 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::command_lines(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::command_lines(): g is not a blessed HV reference");
    };
#line 1957 "Guestfs.xs"
      r = guestfs_command_lines (g, arguments);
      free (arguments);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 5054 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_compress_device_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_compress_device_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4)
       croak_xs_usage(cv,  "g, ctype, device, zdevice, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	ctype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
	char *	zdevice = (char *)SvPV_nolen(ST(3));
#line 1976 "Guestfs.xs"
      int r;
      struct guestfs_compress_device_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_compress_device_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 5083 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::compress_device_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::compress_device_out(): g is not a blessed HV reference");
    };
#line 1981 "Guestfs.xs"
      if (((items - 4) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 4; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "level")) {
          optargs_s.level = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COMPRESS_DEVICE_OUT_LEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_compress_device_out_argv (g, ctype, device, zdevice, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5118 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_compress_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_compress_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4)
       croak_xs_usage(cv,  "g, ctype, file, zfile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	ctype = (char *)SvPV_nolen(ST(1));
	char *	file = (char *)SvPV_nolen(ST(2));
	char *	zfile = (char *)SvPV_nolen(ST(3));
#line 2010 "Guestfs.xs"
      int r;
      struct guestfs_compress_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_compress_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 5147 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::compress_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::compress_out(): g is not a blessed HV reference");
    };
#line 2015 "Guestfs.xs"
      if (((items - 4) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 4; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "level")) {
          optargs_s.level = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COMPRESS_OUT_LEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_compress_out_argv (g, ctype, file, zfile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5182 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_config); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_config)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, hvparam, hvvalue");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	hvparam = (char *)SvPV_nolen(ST(1));
	char *	hvvalue = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
#line 2043 "Guestfs.xs"
      int r;
#line 5207 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::config(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::config(): g is not a blessed HV reference");
    };
#line 2045 "Guestfs.xs"
      r = guestfs_config (g, hvparam, hvvalue);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5224 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_attributes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_attributes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2055 "Guestfs.xs"
      int r;
      struct guestfs_copy_attributes_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_attributes_argv *optargs = &optargs_s;
      size_t items_i;
#line 5252 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_attributes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_attributes(): g is not a blessed HV reference");
    };
#line 2060 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "all")) {
          optargs_s.all = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_ALL_BITMASK;
        }
        else if (STREQ (this_arg, "mode")) {
          optargs_s.mode = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_MODE_BITMASK;
        }
        else if (STREQ (this_arg, "xattributes")) {
          optargs_s.xattributes = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_XATTRIBUTES_BITMASK;
        }
        else if (STREQ (this_arg, "ownership")) {
          optargs_s.ownership = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_OWNERSHIP_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_attributes_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5299 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_device_to_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_device_to_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2100 "Guestfs.xs"
      int r;
      struct guestfs_copy_device_to_device_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_device_to_device_argv *optargs = &optargs_s;
      size_t items_i;
#line 5327 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_device_to_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_device_to_device(): g is not a blessed HV reference");
    };
#line 2105 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_device_to_device_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5378 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_device_to_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_device_to_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2149 "Guestfs.xs"
      int r;
      struct guestfs_copy_device_to_file_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_device_to_file_argv *optargs = &optargs_s;
      size_t items_i;
#line 5406 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_device_to_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_device_to_file(): g is not a blessed HV reference");
    };
#line 2154 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_device_to_file_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5457 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_file_to_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_file_to_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2198 "Guestfs.xs"
      int r;
      struct guestfs_copy_file_to_device_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_file_to_device_argv *optargs = &optargs_s;
      size_t items_i;
#line 5485 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_file_to_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_file_to_device(): g is not a blessed HV reference");
    };
#line 2203 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_file_to_device_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5536 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_file_to_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_file_to_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2247 "Guestfs.xs"
      int r;
      struct guestfs_copy_file_to_file_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_file_to_file_argv *optargs = &optargs_s;
      size_t items_i;
#line 5564 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_file_to_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_file_to_file(): g is not a blessed HV reference");
    };
#line 2252 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_file_to_file_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5615 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, localpath, remotedir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	localpath = (char *)SvPV_nolen(ST(1));
	char *	remotedir = (char *)SvPV_nolen(ST(2));
#line 2296 "Guestfs.xs"
      int r;
#line 5640 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_in(): g is not a blessed HV reference");
    };
#line 2298 "Guestfs.xs"
      r = guestfs_copy_in (g, localpath, remotedir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5657 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, remotepath, localdir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remotepath = (char *)SvPV_nolen(ST(1));
	char *	localdir = (char *)SvPV_nolen(ST(2));
#line 2308 "Guestfs.xs"
      int r;
#line 5682 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_out(): g is not a blessed HV reference");
    };
#line 2310 "Guestfs.xs"
      r = guestfs_copy_out (g, remotepath, localdir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5699 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, src, dest, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
	int64_t    size = my_SvIV64 (ST(3));
#line 2321 "Guestfs.xs"
      int r;
#line 5725 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_size(): g is not a blessed HV reference");
    };
#line 2323 "Guestfs.xs"
      r = guestfs_copy_size (g, src, dest, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5742 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2333 "Guestfs.xs"
      int r;
#line 5767 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cp(): g is not a blessed HV reference");
    };
#line 2335 "Guestfs.xs"
      r = guestfs_cp (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5784 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cp_a); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cp_a)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2345 "Guestfs.xs"
      int r;
#line 5809 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cp_a(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cp_a(): g is not a blessed HV reference");
    };
#line 2347 "Guestfs.xs"
      r = guestfs_cp_a (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5826 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cp_r); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cp_r)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2357 "Guestfs.xs"
      int r;
#line 5851 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cp_r(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cp_r(): g is not a blessed HV reference");
    };
#line 2359 "Guestfs.xs"
      r = guestfs_cp_r (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5868 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cpio_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cpio_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, directory, cpiofile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	cpiofile = (char *)SvPV_nolen(ST(2));
#line 2369 "Guestfs.xs"
      int r;
      struct guestfs_cpio_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_cpio_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 5896 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cpio_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cpio_out(): g is not a blessed HV reference");
    };
#line 2374 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "format")) {
          optargs_s.format = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_CPIO_OUT_FORMAT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_cpio_out_argv (g, directory, cpiofile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5931 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_dd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_dd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2402 "Guestfs.xs"
      int r;
#line 5956 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::dd(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::dd(): g is not a blessed HV reference");
    };
#line 2404 "Guestfs.xs"
      r = guestfs_dd (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5973 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_debug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, subcmd, extraargs");
    {
	guestfs_h *	g;
	char *	subcmd = (char *)SvPV_nolen(ST(1));
	char **	extraargs = XS_unpack_charPtrPtr(ST(2));
#line 2414 "Guestfs.xs"
      char *r;
#line 5996 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::debug(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::debug(): g is not a blessed HV reference");
    };
#line 2416 "Guestfs.xs"
      r = guestfs_debug (g, subcmd, extraargs);
      free (extraargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6017 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_debug_drives); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_debug_drives)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 2429 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 6042 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::debug_drives(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::debug_drives(): g is not a blessed HV reference");
    };
#line 2432 "Guestfs.xs"
      r = guestfs_debug_drives (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 6066 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_debug_upload); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_debug_upload)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, filename, tmpname, mode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	tmpname = (char *)SvPV_nolen(ST(2));
	int	mode = (int)SvIV(ST(3));
#line 2450 "Guestfs.xs"
      int r;
#line 6092 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::debug_upload(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::debug_upload(): g is not a blessed HV reference");
    };
#line 2452 "Guestfs.xs"
      r = guestfs_debug_upload (g, filename, tmpname, mode);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6109 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_device_index); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_device_index)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 2461 "Guestfs.xs"
      int r;
#line 6131 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::device_index(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::device_index(): g is not a blessed HV reference");
    };
#line 2463 "Guestfs.xs"
      r = guestfs_device_index (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6150 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_df); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_df)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 2474 "Guestfs.xs"
      char *r;
#line 6172 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::df(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::df(): g is not a blessed HV reference");
    };
#line 2476 "Guestfs.xs"
      r = guestfs_df (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6192 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_df_h); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_df_h)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 2488 "Guestfs.xs"
      char *r;
#line 6214 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::df_h(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::df_h(): g is not a blessed HV reference");
    };
#line 2490 "Guestfs.xs"
      r = guestfs_df_h (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6234 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_disk_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4)
       croak_xs_usage(cv,  "g, filename, format, size, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	format = (char *)SvPV_nolen(ST(2));
	int64_t    size = my_SvIV64 (ST(3));
#line 2505 "Guestfs.xs"
      int r;
      struct guestfs_disk_create_argv optargs_s = { .bitmask = 0 };
      struct guestfs_disk_create_argv *optargs = &optargs_s;
      size_t items_i;
#line 6264 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_create(): g is not a blessed HV reference");
    };
#line 2510 "Guestfs.xs"
      if (((items - 4) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 4; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "backingfile")) {
          optargs_s.backingfile = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_BACKINGFILE_BITMASK;
        }
        else if (STREQ (this_arg, "backingformat")) {
          optargs_s.backingformat = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_BACKINGFORMAT_BITMASK;
        }
        else if (STREQ (this_arg, "preallocation")) {
          optargs_s.preallocation = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_PREALLOCATION_BITMASK;
        }
        else if (STREQ (this_arg, "compat")) {
          optargs_s.compat = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_COMPAT_BITMASK;
        }
        else if (STREQ (this_arg, "clustersize")) {
          optargs_s.clustersize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_CLUSTERSIZE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_disk_create_argv (g, filename, format, size, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6315 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_disk_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2553 "Guestfs.xs"
      char *r;
#line 6337 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_format(): g is not a blessed HV reference");
    };
#line 2555 "Guestfs.xs"
      r = guestfs_disk_format (g, filename);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6357 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_disk_has_backing_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_has_backing_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2568 "Guestfs.xs"
      int r;
#line 6380 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_has_backing_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_has_backing_file(): g is not a blessed HV reference");
    };
#line 2570 "Guestfs.xs"
      r = guestfs_disk_has_backing_file (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6399 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_disk_virtual_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_virtual_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2582 "Guestfs.xs"
      int64_t r;
#line 6422 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_virtual_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_virtual_size(): g is not a blessed HV reference");
    };
#line 2584 "Guestfs.xs"
      r = guestfs_disk_virtual_size (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 6441 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_dmesg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_dmesg)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 2595 "Guestfs.xs"
      char *r;
#line 6463 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::dmesg(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::dmesg(): g is not a blessed HV reference");
    };
#line 2597 "Guestfs.xs"
      r = guestfs_dmesg (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6483 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_download); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_download)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, remotefilename, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remotefilename = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
#line 2611 "Guestfs.xs"
      int r;
#line 6509 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::download(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::download(): g is not a blessed HV reference");
    };
#line 2613 "Guestfs.xs"
      r = guestfs_download (g, remotefilename, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6526 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_download_offset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_download_offset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, remotefilename, filename, offset, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remotefilename = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
	int64_t    size = my_SvIV64 (ST(4));
#line 2625 "Guestfs.xs"
      int r;
#line 6553 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::download_offset(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::download_offset(): g is not a blessed HV reference");
    };
#line 2627 "Guestfs.xs"
      r = guestfs_download_offset (g, remotefilename, filename, offset, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6570 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_drop_caches); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_drop_caches)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, whattodrop");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	whattodrop = (int)SvIV(ST(1));
#line 2636 "Guestfs.xs"
      int r;
#line 6594 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::drop_caches(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::drop_caches(): g is not a blessed HV reference");
    };
#line 2638 "Guestfs.xs"
      r = guestfs_drop_caches (g, whattodrop);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6611 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_du); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_du)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 2647 "Guestfs.xs"
      int64_t r;
#line 6633 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::du(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::du(): g is not a blessed HV reference");
    };
#line 2649 "Guestfs.xs"
      r = guestfs_du (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 6652 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_e2fsck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_e2fsck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 2661 "Guestfs.xs"
      int r;
      struct guestfs_e2fsck_argv optargs_s = { .bitmask = 0 };
      struct guestfs_e2fsck_argv *optargs = &optargs_s;
      size_t items_i;
#line 6680 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::e2fsck(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::e2fsck(): g is not a blessed HV reference");
    };
#line 2666 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "correct")) {
          optargs_s.correct = SvIV (ST (items_i+1));
          this_mask = GUESTFS_E2FSCK_CORRECT_BITMASK;
        }
        else if (STREQ (this_arg, "forceall")) {
          optargs_s.forceall = SvIV (ST (items_i+1));
          this_mask = GUESTFS_E2FSCK_FORCEALL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_e2fsck_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6719 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_e2fsck_f); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_e2fsck_f)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 2697 "Guestfs.xs"
      int r;
#line 6743 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::e2fsck_f(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::e2fsck_f(): g is not a blessed HV reference");
    };
#line 2699 "Guestfs.xs"
      r = guestfs_e2fsck_f (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6760 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_echo_daemon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_echo_daemon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, words");
    {
	guestfs_h *	g;
	char **	words = XS_unpack_charPtrPtr(ST(1));
#line 2708 "Guestfs.xs"
      char *r;
#line 6782 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::echo_daemon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::echo_daemon(): g is not a blessed HV reference");
    };
#line 2710 "Guestfs.xs"
      r = guestfs_echo_daemon (g, words);
      free (words);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6803 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_egrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_egrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2725 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 6830 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::egrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::egrep(): g is not a blessed HV reference");
    };
#line 2728 "Guestfs.xs"
      r = guestfs_egrep (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 6854 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_egrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_egrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2745 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 6880 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::egrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::egrepi(): g is not a blessed HV reference");
    };
#line 2748 "Guestfs.xs"
      r = guestfs_egrepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 6904 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_equal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_equal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, file1, file2");
    {
	guestfs_h *	g;
	char *	file1 = (char *)SvPV_nolen(ST(1));
	char *	file2 = (char *)SvPV_nolen(ST(2));
#line 2765 "Guestfs.xs"
      int r;
#line 6927 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::equal(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::equal(): g is not a blessed HV reference");
    };
#line 2767 "Guestfs.xs"
      r = guestfs_equal (g, file1, file2);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6946 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_exists); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_exists)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 2779 "Guestfs.xs"
      int r;
#line 6969 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::exists(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::exists(): g is not a blessed HV reference");
    };
#line 2781 "Guestfs.xs"
      r = guestfs_exists (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6988 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_extlinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_extlinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 2793 "Guestfs.xs"
      int r;
#line 7013 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::extlinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::extlinux(): g is not a blessed HV reference");
    };
#line 2795 "Guestfs.xs"
      r = guestfs_extlinux (g, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7030 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fallocate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fallocate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, len");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	len = (int)SvIV(ST(2));
#line 2805 "Guestfs.xs"
      int r;
#line 7055 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fallocate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fallocate(): g is not a blessed HV reference");
    };
#line 2807 "Guestfs.xs"
      r = guestfs_fallocate (g, path, len);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7072 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fallocate64); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fallocate64)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, len");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int64_t    len = my_SvIV64 (ST(2));
#line 2817 "Guestfs.xs"
      int r;
#line 7097 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fallocate64(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fallocate64(): g is not a blessed HV reference");
    };
#line 2819 "Guestfs.xs"
      r = guestfs_fallocate64 (g, path, len);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7114 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_feature_available); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_feature_available)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, groups");
    {
	guestfs_h *	g;
	char **	groups = XS_unpack_charPtrPtr(ST(1));
#line 2828 "Guestfs.xs"
      int r;
#line 7136 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::feature_available(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::feature_available(): g is not a blessed HV reference");
    };
#line 2830 "Guestfs.xs"
      r = guestfs_feature_available (g, groups);
      free (groups);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7156 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fgrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fgrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2844 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 7183 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fgrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fgrep(): g is not a blessed HV reference");
    };
#line 2847 "Guestfs.xs"
      r = guestfs_fgrep (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 7207 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fgrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fgrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2864 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 7233 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fgrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fgrepi(): g is not a blessed HV reference");
    };
#line 2867 "Guestfs.xs"
      r = guestfs_fgrepi (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 7257 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 2883 "Guestfs.xs"
      char *r;
#line 7279 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::file(): g is not a blessed HV reference");
    };
#line 2885 "Guestfs.xs"
      r = guestfs_file (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7299 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_file_architecture); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_file_architecture)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2898 "Guestfs.xs"
      char *r;
#line 7322 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::file_architecture(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::file_architecture(): g is not a blessed HV reference");
    };
#line 2900 "Guestfs.xs"
      r = guestfs_file_architecture (g, filename);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7342 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_filesize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_filesize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 2913 "Guestfs.xs"
      int64_t r;
#line 7365 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::filesize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::filesize(): g is not a blessed HV reference");
    };
#line 2915 "Guestfs.xs"
      r = guestfs_filesize (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 7384 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_filesystem_available); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_filesystem_available)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filesystem");
    {
	guestfs_h *	g;
	char *	filesystem = (char *)SvPV_nolen(ST(1));
#line 2927 "Guestfs.xs"
      int r;
#line 7407 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::filesystem_available(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::filesystem_available(): g is not a blessed HV reference");
    };
#line 2929 "Guestfs.xs"
      r = guestfs_filesystem_available (g, filesystem);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7426 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fill)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, c, len, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	c = (int)SvIV(ST(1));
	int	len = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 2943 "Guestfs.xs"
      int r;
#line 7453 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fill(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fill(): g is not a blessed HV reference");
    };
#line 2945 "Guestfs.xs"
      r = guestfs_fill (g, c, len, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7470 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fill_dir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fill_dir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, dir, nr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
	int	nr = (int)SvIV(ST(2));
#line 2955 "Guestfs.xs"
      int r;
#line 7495 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fill_dir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fill_dir(): g is not a blessed HV reference");
    };
#line 2957 "Guestfs.xs"
      r = guestfs_fill_dir (g, dir, nr);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7512 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fill_pattern); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fill_pattern)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, pattern, len, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	int	len = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 2968 "Guestfs.xs"
      int r;
#line 7538 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fill_pattern(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fill_pattern(): g is not a blessed HV reference");
    };
#line 2970 "Guestfs.xs"
      r = guestfs_fill_pattern (g, pattern, len, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7555 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_find); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_find)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 2979 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 7580 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::find(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::find(): g is not a blessed HV reference");
    };
#line 2982 "Guestfs.xs"
      r = guestfs_find (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 7604 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_find0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_find0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, directory, files");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	files = (char *)SvPV_nolen(ST(2));
#line 2999 "Guestfs.xs"
      int r;
#line 7629 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::find0(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::find0(): g is not a blessed HV reference");
    };
#line 3001 "Guestfs.xs"
      r = guestfs_find0 (g, directory, files);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7646 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_findfs_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_findfs_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 3010 "Guestfs.xs"
      char *r;
#line 7668 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::findfs_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::findfs_label(): g is not a blessed HV reference");
    };
#line 3012 "Guestfs.xs"
      r = guestfs_findfs_label (g, label);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7688 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_findfs_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_findfs_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, uuid");
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
#line 3025 "Guestfs.xs"
      char *r;
#line 7711 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::findfs_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::findfs_uuid(): g is not a blessed HV reference");
    };
#line 3027 "Guestfs.xs"
      r = guestfs_findfs_uuid (g, uuid);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7731 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fsck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fsck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, fstype, device");
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 3041 "Guestfs.xs"
      int r;
#line 7755 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fsck(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fsck(): g is not a blessed HV reference");
    };
#line 3043 "Guestfs.xs"
      r = guestfs_fsck (g, fstype, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7774 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fstrim); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fstrim)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 3055 "Guestfs.xs"
      int r;
      struct guestfs_fstrim_argv optargs_s = { .bitmask = 0 };
      struct guestfs_fstrim_argv *optargs = &optargs_s;
      size_t items_i;
#line 7802 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fstrim(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fstrim(): g is not a blessed HV reference");
    };
#line 3060 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "offset")) {
          optargs_s.offset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_FSTRIM_OFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "length")) {
          optargs_s.length = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_FSTRIM_LENGTH_BITMASK;
        }
        else if (STREQ (this_arg, "minimumfreeextent")) {
          optargs_s.minimumfreeextent = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_FSTRIM_MINIMUMFREEEXTENT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_fstrim_argv (g, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7845 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_get_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3094 "Guestfs.xs"
      const char *r;
#line 7866 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_append(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_append(): g is not a blessed HV reference");
    };
#line 3096 "Guestfs.xs"
      r = guestfs_get_append (g);
      if (r == NULL)
        RETVAL = &PL_sv_undef;
      else
        RETVAL = newSVpv (r, 0);
#line 7886 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_attach_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_attach_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3108 "Guestfs.xs"
      char *r;
#line 7908 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_attach_method(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_attach_method(): g is not a blessed HV reference");
    };
#line 3110 "Guestfs.xs"
      r = guestfs_get_attach_method (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7928 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_autosync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_autosync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3122 "Guestfs.xs"
      int r;
#line 7950 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_autosync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_autosync(): g is not a blessed HV reference");
    };
#line 3124 "Guestfs.xs"
      r = guestfs_get_autosync (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7969 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_backend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_backend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3135 "Guestfs.xs"
      char *r;
#line 7991 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_backend(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_backend(): g is not a blessed HV reference");
    };
#line 3137 "Guestfs.xs"
      r = guestfs_get_backend (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8011 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_backend_setting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_backend_setting)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, name");
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
#line 3150 "Guestfs.xs"
      char *r;
#line 8034 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_backend_setting(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_backend_setting(): g is not a blessed HV reference");
    };
#line 3152 "Guestfs.xs"
      r = guestfs_get_backend_setting (g, name);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8054 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_backend_settings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_backend_settings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 3164 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 8079 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_backend_settings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_backend_settings(): g is not a blessed HV reference");
    };
#line 3167 "Guestfs.xs"
      r = guestfs_get_backend_settings (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 8103 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_get_cachedir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_cachedir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3182 "Guestfs.xs"
      char *r;
#line 8124 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_cachedir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_cachedir(): g is not a blessed HV reference");
    };
#line 3184 "Guestfs.xs"
      r = guestfs_get_cachedir (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8144 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_direct); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_direct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3196 "Guestfs.xs"
      int r;
#line 8166 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_direct(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_direct(): g is not a blessed HV reference");
    };
#line 3198 "Guestfs.xs"
      r = guestfs_get_direct (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8185 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2attrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2attrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 3210 "Guestfs.xs"
      char *r;
#line 8208 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2attrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2attrs(): g is not a blessed HV reference");
    };
#line 3212 "Guestfs.xs"
      r = guestfs_get_e2attrs (g, file);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8228 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 3225 "Guestfs.xs"
      int64_t r;
#line 8251 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2generation(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2generation(): g is not a blessed HV reference");
    };
#line 3227 "Guestfs.xs"
      r = guestfs_get_e2generation (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 8270 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 3239 "Guestfs.xs"
      char *r;
#line 8293 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2label(): g is not a blessed HV reference");
    };
#line 3241 "Guestfs.xs"
      r = guestfs_get_e2label (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8313 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 3254 "Guestfs.xs"
      char *r;
#line 8336 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2uuid(): g is not a blessed HV reference");
    };
#line 3256 "Guestfs.xs"
      r = guestfs_get_e2uuid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8356 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_hv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_hv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3268 "Guestfs.xs"
      char *r;
#line 8378 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_hv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_hv(): g is not a blessed HV reference");
    };
#line 3270 "Guestfs.xs"
      r = guestfs_get_hv (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8398 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credential_challenge); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credential_challenge)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, index");
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
#line 3283 "Guestfs.xs"
      char *r;
#line 8421 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credential_challenge(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credential_challenge(): g is not a blessed HV reference");
    };
#line 3285 "Guestfs.xs"
      r = guestfs_get_libvirt_requested_credential_challenge (g, index);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8441 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credential_defresult); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credential_defresult)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, index");
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
#line 3298 "Guestfs.xs"
      char *r;
#line 8464 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credential_defresult(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credential_defresult(): g is not a blessed HV reference");
    };
#line 3300 "Guestfs.xs"
      r = guestfs_get_libvirt_requested_credential_defresult (g, index);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8484 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credential_prompt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credential_prompt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, index");
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
#line 3313 "Guestfs.xs"
      char *r;
#line 8507 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credential_prompt(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credential_prompt(): g is not a blessed HV reference");
    };
#line 3315 "Guestfs.xs"
      r = guestfs_get_libvirt_requested_credential_prompt (g, index);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8527 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credentials); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credentials)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 3327 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 8552 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credentials(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credentials(): g is not a blessed HV reference");
    };
#line 3330 "Guestfs.xs"
      r = guestfs_get_libvirt_requested_credentials (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 8576 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_get_memsize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_memsize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3345 "Guestfs.xs"
      int r;
#line 8597 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_memsize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_memsize(): g is not a blessed HV reference");
    };
#line 3347 "Guestfs.xs"
      r = guestfs_get_memsize (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8616 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_network); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_network)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3358 "Guestfs.xs"
      int r;
#line 8638 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_network(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_network(): g is not a blessed HV reference");
    };
#line 3360 "Guestfs.xs"
      r = guestfs_get_network (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8657 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3371 "Guestfs.xs"
      const char *r;
#line 8679 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_path(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_path(): g is not a blessed HV reference");
    };
#line 3373 "Guestfs.xs"
      r = guestfs_get_path (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8698 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_pgroup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_pgroup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3384 "Guestfs.xs"
      int r;
#line 8720 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_pgroup(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_pgroup(): g is not a blessed HV reference");
    };
#line 3386 "Guestfs.xs"
      r = guestfs_get_pgroup (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8739 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_pid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_pid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3397 "Guestfs.xs"
      int r;
#line 8761 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_pid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_pid(): g is not a blessed HV reference");
    };
#line 3399 "Guestfs.xs"
      r = guestfs_get_pid (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8780 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_program); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_program)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3410 "Guestfs.xs"
      const char *r;
#line 8802 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_program(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_program(): g is not a blessed HV reference");
    };
#line 3412 "Guestfs.xs"
      r = guestfs_get_program (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8821 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_qemu); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_qemu)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3423 "Guestfs.xs"
      const char *r;
#line 8843 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_qemu(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_qemu(): g is not a blessed HV reference");
    };
#line 3425 "Guestfs.xs"
      r = guestfs_get_qemu (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8862 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_recovery_proc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_recovery_proc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3436 "Guestfs.xs"
      int r;
#line 8884 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_recovery_proc(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_recovery_proc(): g is not a blessed HV reference");
    };
#line 3438 "Guestfs.xs"
      r = guestfs_get_recovery_proc (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8903 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_selinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_selinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3449 "Guestfs.xs"
      int r;
#line 8925 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_selinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_selinux(): g is not a blessed HV reference");
    };
#line 3451 "Guestfs.xs"
      r = guestfs_get_selinux (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8944 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_smp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_smp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3462 "Guestfs.xs"
      int r;
#line 8966 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_smp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_smp(): g is not a blessed HV reference");
    };
#line 3464 "Guestfs.xs"
      r = guestfs_get_smp (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8985 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_state); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_state)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3475 "Guestfs.xs"
      int r;
#line 9007 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_state(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_state(): g is not a blessed HV reference");
    };
#line 3477 "Guestfs.xs"
      r = guestfs_get_state (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9026 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_tmpdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_tmpdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3488 "Guestfs.xs"
      char *r;
#line 9048 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_tmpdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_tmpdir(): g is not a blessed HV reference");
    };
#line 3490 "Guestfs.xs"
      r = guestfs_get_tmpdir (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 9068 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_trace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_trace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3502 "Guestfs.xs"
      int r;
#line 9090 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_trace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_trace(): g is not a blessed HV reference");
    };
#line 3504 "Guestfs.xs"
      r = guestfs_get_trace (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9109 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_umask); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_umask)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3515 "Guestfs.xs"
      int r;
#line 9131 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_umask(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_umask(): g is not a blessed HV reference");
    };
#line 3517 "Guestfs.xs"
      r = guestfs_get_umask (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9150 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_verbose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_verbose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3528 "Guestfs.xs"
      int r;
#line 9172 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_verbose(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_verbose(): g is not a blessed HV reference");
    };
#line 3530 "Guestfs.xs"
      r = guestfs_get_verbose (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9191 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_getcon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_getcon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3541 "Guestfs.xs"
      char *r;
#line 9213 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::getcon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::getcon(): g is not a blessed HV reference");
    };
#line 3543 "Guestfs.xs"
      r = guestfs_getcon (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 9233 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_getxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_getxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, name");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 3557 "Guestfs.xs"
      char *r;
      size_t size;
#line 9258 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::getxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::getxattr(): g is not a blessed HV reference");
    };
#line 3560 "Guestfs.xs"
      r = guestfs_getxattr (g, path, name, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 9278 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_getxattrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_getxattrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 3573 "Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 9305 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::getxattrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::getxattrs(): g is not a blessed HV reference");
    };
#line 3577 "Guestfs.xs"
      r = guestfs_getxattrs (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 9330 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_glob_expand); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_glob_expand)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, pattern");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
#line 3594 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 9355 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::glob_expand(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::glob_expand(): g is not a blessed HV reference");
    };
#line 3597 "Guestfs.xs"
      r = guestfs_glob_expand (g, pattern);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9379 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_grep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_grep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, regex, path, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 3614 "Guestfs.xs"
      char **r;
      size_t i, n;
      struct guestfs_grep_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_grep_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 9408 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::grep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::grep(): g is not a blessed HV reference");
    };
#line 3620 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "extended")) {
          optargs_s.extended = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_EXTENDED_BITMASK;
        }
        else if (STREQ (this_arg, "fixed")) {
          optargs_s.fixed = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_FIXED_BITMASK;
        }
        else if (STREQ (this_arg, "insensitive")) {
          optargs_s.insensitive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_INSENSITIVE_BITMASK;
        }
        else if (STREQ (this_arg, "compressed")) {
          optargs_s.compressed = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_COMPRESSED_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_grep_opts_argv (g, regex, path, optargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9462 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_grepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_grepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 3667 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 9488 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::grepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::grepi(): g is not a blessed HV reference");
    };
#line 3670 "Guestfs.xs"
      r = guestfs_grepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9512 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_grub_install); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_grub_install)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, root, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 3687 "Guestfs.xs"
      int r;
#line 9537 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::grub_install(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::grub_install(): g is not a blessed HV reference");
    };
#line 3689 "Guestfs.xs"
      r = guestfs_grub_install (g, root, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9554 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_head); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_head)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 3698 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 9579 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::head(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::head(): g is not a blessed HV reference");
    };
#line 3701 "Guestfs.xs"
      r = guestfs_head (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9603 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_head_n); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_head_n)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nrlines, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	nrlines = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 3718 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 9629 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::head_n(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::head_n(): g is not a blessed HV reference");
    };
#line 3721 "Guestfs.xs"
      r = guestfs_head_n (g, nrlines, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9653 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hexdump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hexdump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 3737 "Guestfs.xs"
      char *r;
#line 9675 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hexdump(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hexdump(): g is not a blessed HV reference");
    };
#line 3739 "Guestfs.xs"
      r = guestfs_hexdump (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 9695 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 3751 "Guestfs.xs"
      int r;
#line 9719 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_close(): g is not a blessed HV reference");
    };
#line 3753 "Guestfs.xs"
      r = guestfs_hivex_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9736 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_commit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 3762 "Guestfs.xs"
      int r;
#line 9760 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_commit(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_commit(): g is not a blessed HV reference");
    };
#line 3764 "Guestfs.xs"
      r = guestfs_hivex_commit (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9777 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_add_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_add_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, parent, name");
    {
	guestfs_h *	g;
	int64_t    parent = my_SvIV64 (ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 3774 "Guestfs.xs"
      int64_t r;
#line 9800 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_add_child(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_add_child(): g is not a blessed HV reference");
    };
#line 3776 "Guestfs.xs"
      r = guestfs_hivex_node_add_child (g, parent, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 9819 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_children)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3788 "Guestfs.xs"
      struct guestfs_hivex_node_list *r;
      size_t i;
      HV *hv;
#line 9846 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_children(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_children(): g is not a blessed HV reference");
    };
#line 3792 "Guestfs.xs"
      r = guestfs_hivex_node_children (g, nodeh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "hivex_node_h", 12, my_newSVll (r->val[i].hivex_node_h), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_hivex_node_list (r);
#line 9870 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_delete_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_delete_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3808 "Guestfs.xs"
      int r;
#line 9894 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_delete_child(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_delete_child(): g is not a blessed HV reference");
    };
#line 3810 "Guestfs.xs"
      r = guestfs_hivex_node_delete_child (g, nodeh);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9911 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_get_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_get_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nodeh, name");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 3820 "Guestfs.xs"
      int64_t r;
#line 9934 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_get_child(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_get_child(): g is not a blessed HV reference");
    };
#line 3822 "Guestfs.xs"
      r = guestfs_hivex_node_get_child (g, nodeh, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 9953 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_get_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_get_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nodeh, key");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
#line 3835 "Guestfs.xs"
      int64_t r;
#line 9977 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_get_value(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_get_value(): g is not a blessed HV reference");
    };
#line 3837 "Guestfs.xs"
      r = guestfs_hivex_node_get_value (g, nodeh, key);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 9996 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3849 "Guestfs.xs"
      char *r;
#line 10019 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_name(): g is not a blessed HV reference");
    };
#line 3851 "Guestfs.xs"
      r = guestfs_hivex_node_name (g, nodeh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10039 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_parent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_parent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3864 "Guestfs.xs"
      int64_t r;
#line 10062 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_parent(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_parent(): g is not a blessed HV reference");
    };
#line 3866 "Guestfs.xs"
      r = guestfs_hivex_node_parent (g, nodeh);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10081 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_set_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_set_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, nodeh, key, t, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int64_t    t = my_SvIV64 (ST(3));
	char *	val = (char *)SvPV_nolen(ST(4));
	size_t	val_size = SvCUR (ST(4));
#line 3882 "Guestfs.xs"
      int r;
#line 10110 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_set_value(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_set_value(): g is not a blessed HV reference");
    };
#line 3884 "Guestfs.xs"
      r = guestfs_hivex_node_set_value (g, nodeh, key, t, val, val_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10127 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_values); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_values)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3893 "Guestfs.xs"
      struct guestfs_hivex_value_list *r;
      size_t i;
      HV *hv;
#line 10153 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_values(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_values(): g is not a blessed HV reference");
    };
#line 3897 "Guestfs.xs"
      r = guestfs_hivex_node_values (g, nodeh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "hivex_value_h", 13, my_newSVll (r->val[i].hivex_value_h), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_hivex_value_list (r);
#line 10177 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, filename, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 3913 "Guestfs.xs"
      int r;
      struct guestfs_hivex_open_argv optargs_s = { .bitmask = 0 };
      struct guestfs_hivex_open_argv *optargs = &optargs_s;
      size_t items_i;
#line 10204 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_open(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_open(): g is not a blessed HV reference");
    };
#line 3918 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "verbose")) {
          optargs_s.verbose = SvIV (ST (items_i+1));
          this_mask = GUESTFS_HIVEX_OPEN_VERBOSE_BITMASK;
        }
        else if (STREQ (this_arg, "debug")) {
          optargs_s.debug = SvIV (ST (items_i+1));
          this_mask = GUESTFS_HIVEX_OPEN_DEBUG_BITMASK;
        }
        else if (STREQ (this_arg, "write")) {
          optargs_s.write = SvIV (ST (items_i+1));
          this_mask = GUESTFS_HIVEX_OPEN_WRITE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_hivex_open_argv (g, filename, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10247 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_root)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3952 "Guestfs.xs"
      int64_t r;
#line 10268 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_root(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_root(): g is not a blessed HV reference");
    };
#line 3954 "Guestfs.xs"
      r = guestfs_hivex_root (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10287 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 3966 "Guestfs.xs"
      char *r;
#line 10310 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_key(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_key(): g is not a blessed HV reference");
    };
#line 3968 "Guestfs.xs"
      r = guestfs_hivex_value_key (g, valueh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10330 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 3981 "Guestfs.xs"
      int64_t r;
#line 10353 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_type(): g is not a blessed HV reference");
    };
#line 3983 "Guestfs.xs"
      r = guestfs_hivex_value_type (g, valueh);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10372 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_utf8); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_utf8)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 3995 "Guestfs.xs"
      char *r;
#line 10395 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_utf8(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_utf8(): g is not a blessed HV reference");
    };
#line 3997 "Guestfs.xs"
      r = guestfs_hivex_value_utf8 (g, valueh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10415 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 4010 "Guestfs.xs"
      char *r;
      size_t size;
#line 10439 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_value(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_value(): g is not a blessed HV reference");
    };
#line 4013 "Guestfs.xs"
      r = guestfs_hivex_value_value (g, valueh, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 10459 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_initrd_cat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_initrd_cat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, initrdpath, filename");
    {
	guestfs_h *	g;
	char *	initrdpath = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
#line 4027 "Guestfs.xs"
      char *r;
      size_t size;
#line 10484 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::initrd_cat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::initrd_cat(): g is not a blessed HV reference");
    };
#line 4030 "Guestfs.xs"
      r = guestfs_initrd_cat (g, initrdpath, filename, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 10504 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_initrd_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_initrd_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 4043 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 10530 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::initrd_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::initrd_list(): g is not a blessed HV reference");
    };
#line 4046 "Guestfs.xs"
      r = guestfs_initrd_list (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 10554 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_add_watch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_add_watch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, mask");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	mask = (int)SvIV(ST(2));
#line 4063 "Guestfs.xs"
      int64_t r;
#line 10577 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_add_watch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_add_watch(): g is not a blessed HV reference");
    };
#line 4065 "Guestfs.xs"
      r = guestfs_inotify_add_watch (g, path, mask);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10596 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inotify_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4076 "Guestfs.xs"
      int r;
#line 10620 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_close(): g is not a blessed HV reference");
    };
#line 4078 "Guestfs.xs"
      r = guestfs_inotify_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10637 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_files); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_files)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4086 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 10661 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_files(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_files(): g is not a blessed HV reference");
    };
#line 4089 "Guestfs.xs"
      r = guestfs_inotify_files (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 10685 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, maxevents");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	maxevents = (int)SvIV(ST(1));
#line 4105 "Guestfs.xs"
      int r;
#line 10709 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_init(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_init(): g is not a blessed HV reference");
    };
#line 4107 "Guestfs.xs"
      r = guestfs_inotify_init (g, maxevents);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10726 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4115 "Guestfs.xs"
      struct guestfs_inotify_event_list *r;
      size_t i;
      HV *hv;
#line 10751 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_read(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_read(): g is not a blessed HV reference");
    };
#line 4119 "Guestfs.xs"
      r = guestfs_inotify_read (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "in_wd", 5, my_newSVll (r->val[i].in_wd), 0);
        (void) hv_store (hv, "in_mask", 7, newSVnv (r->val[i].in_mask), 0);
        (void) hv_store (hv, "in_cookie", 9, newSVnv (r->val[i].in_cookie), 0);
        (void) hv_store (hv, "in_name", 7, newSVpv (r->val[i].in_name, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_inotify_event_list (r);
#line 10778 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_rm_watch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_rm_watch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, wd");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	wd = (int)SvIV(ST(1));
#line 4138 "Guestfs.xs"
      int r;
#line 10802 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_rm_watch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_rm_watch(): g is not a blessed HV reference");
    };
#line 4140 "Guestfs.xs"
      r = guestfs_inotify_rm_watch (g, wd);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10819 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_arch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_arch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4149 "Guestfs.xs"
      char *r;
#line 10841 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_arch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_arch(): g is not a blessed HV reference");
    };
#line 4151 "Guestfs.xs"
      r = guestfs_inspect_get_arch (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10861 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_distro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_distro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4164 "Guestfs.xs"
      char *r;
#line 10884 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_distro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_distro(): g is not a blessed HV reference");
    };
#line 4166 "Guestfs.xs"
      r = guestfs_inspect_get_distro (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10904 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_drive_mappings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_drive_mappings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4179 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 10930 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_drive_mappings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_drive_mappings(): g is not a blessed HV reference");
    };
#line 4182 "Guestfs.xs"
      r = guestfs_inspect_get_drive_mappings (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 10954 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_filesystems); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_filesystems)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4198 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 10979 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_filesystems(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_filesystems(): g is not a blessed HV reference");
    };
#line 4201 "Guestfs.xs"
      r = guestfs_inspect_get_filesystems (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11003 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4217 "Guestfs.xs"
      char *r;
#line 11025 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_format(): g is not a blessed HV reference");
    };
#line 4219 "Guestfs.xs"
      r = guestfs_inspect_get_format (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11045 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_hostname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_hostname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4232 "Guestfs.xs"
      char *r;
#line 11068 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_hostname(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_hostname(): g is not a blessed HV reference");
    };
#line 4234 "Guestfs.xs"
      r = guestfs_inspect_get_hostname (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11088 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_icon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_icon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, root, ...");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4247 "Guestfs.xs"
      char *r;
      size_t size;
      struct guestfs_inspect_get_icon_argv optargs_s = { .bitmask = 0 };
      struct guestfs_inspect_get_icon_argv *optargs = &optargs_s;
      size_t items_i;
#line 11115 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_icon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_icon(): g is not a blessed HV reference");
    };
#line 4253 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "favicon")) {
          optargs_s.favicon = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INSPECT_GET_ICON_FAVICON_BITMASK;
        }
        else if (STREQ (this_arg, "highquality")) {
          optargs_s.highquality = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INSPECT_GET_ICON_HIGHQUALITY_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_inspect_get_icon_argv (g, root, &size, optargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 11157 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_major_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_major_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4288 "Guestfs.xs"
      int r;
#line 11180 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_major_version(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_major_version(): g is not a blessed HV reference");
    };
#line 4290 "Guestfs.xs"
      r = guestfs_inspect_get_major_version (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11199 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_minor_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_minor_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4302 "Guestfs.xs"
      int r;
#line 11222 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_minor_version(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_minor_version(): g is not a blessed HV reference");
    };
#line 4304 "Guestfs.xs"
      r = guestfs_inspect_get_minor_version (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11241 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_mountpoints); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_mountpoints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4316 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 11267 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_mountpoints(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_mountpoints(): g is not a blessed HV reference");
    };
#line 4319 "Guestfs.xs"
      r = guestfs_inspect_get_mountpoints (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11291 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_package_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_package_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4335 "Guestfs.xs"
      char *r;
#line 11313 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_package_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_package_format(): g is not a blessed HV reference");
    };
#line 4337 "Guestfs.xs"
      r = guestfs_inspect_get_package_format (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11333 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_package_management); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_package_management)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4350 "Guestfs.xs"
      char *r;
#line 11356 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_package_management(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_package_management(): g is not a blessed HV reference");
    };
#line 4352 "Guestfs.xs"
      r = guestfs_inspect_get_package_management (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11376 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_product_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_product_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4365 "Guestfs.xs"
      char *r;
#line 11399 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_product_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_product_name(): g is not a blessed HV reference");
    };
#line 4367 "Guestfs.xs"
      r = guestfs_inspect_get_product_name (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11419 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_product_variant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_product_variant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4380 "Guestfs.xs"
      char *r;
#line 11442 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_product_variant(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_product_variant(): g is not a blessed HV reference");
    };
#line 4382 "Guestfs.xs"
      r = guestfs_inspect_get_product_variant (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11462 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_roots); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_roots)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4394 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 11487 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_roots(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_roots(): g is not a blessed HV reference");
    };
#line 4397 "Guestfs.xs"
      r = guestfs_inspect_get_roots (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11511 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4413 "Guestfs.xs"
      char *r;
#line 11533 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_type(): g is not a blessed HV reference");
    };
#line 4415 "Guestfs.xs"
      r = guestfs_inspect_get_type (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11553 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_windows_current_control_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_windows_current_control_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4428 "Guestfs.xs"
      char *r;
#line 11576 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_windows_current_control_set(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_windows_current_control_set(): g is not a blessed HV reference");
    };
#line 4430 "Guestfs.xs"
      r = guestfs_inspect_get_windows_current_control_set (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11596 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_windows_systemroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_windows_systemroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4443 "Guestfs.xs"
      char *r;
#line 11619 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_windows_systemroot(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_windows_systemroot(): g is not a blessed HV reference");
    };
#line 4445 "Guestfs.xs"
      r = guestfs_inspect_get_windows_systemroot (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11639 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_is_live); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_is_live)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4458 "Guestfs.xs"
      int r;
#line 11662 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_is_live(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_is_live(): g is not a blessed HV reference");
    };
#line 4460 "Guestfs.xs"
      r = guestfs_inspect_is_live (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11681 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_is_multipart); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_is_multipart)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4472 "Guestfs.xs"
      int r;
#line 11704 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_is_multipart(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_is_multipart(): g is not a blessed HV reference");
    };
#line 4474 "Guestfs.xs"
      r = guestfs_inspect_is_multipart (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11723 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_is_netinst); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_is_netinst)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4486 "Guestfs.xs"
      int r;
#line 11746 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_is_netinst(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_is_netinst(): g is not a blessed HV reference");
    };
#line 4488 "Guestfs.xs"
      r = guestfs_inspect_is_netinst (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11765 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_list_applications); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_list_applications)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4500 "Guestfs.xs"
      struct guestfs_application_list *r;
      size_t i;
      HV *hv;
#line 11792 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_list_applications(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_list_applications(): g is not a blessed HV reference");
    };
#line 4504 "Guestfs.xs"
      r = guestfs_inspect_list_applications (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "app_name", 8, newSVpv (r->val[i].app_name, 0), 0);
        (void) hv_store (hv, "app_display_name", 16, newSVpv (r->val[i].app_display_name, 0), 0);
        (void) hv_store (hv, "app_epoch", 9, newSVnv (r->val[i].app_epoch), 0);
        (void) hv_store (hv, "app_version", 11, newSVpv (r->val[i].app_version, 0), 0);
        (void) hv_store (hv, "app_release", 11, newSVpv (r->val[i].app_release, 0), 0);
        (void) hv_store (hv, "app_install_path", 16, newSVpv (r->val[i].app_install_path, 0), 0);
        (void) hv_store (hv, "app_trans_path", 14, newSVpv (r->val[i].app_trans_path, 0), 0);
        (void) hv_store (hv, "app_publisher", 13, newSVpv (r->val[i].app_publisher, 0), 0);
        (void) hv_store (hv, "app_url", 7, newSVpv (r->val[i].app_url, 0), 0);
        (void) hv_store (hv, "app_source_package", 18, newSVpv (r->val[i].app_source_package, 0), 0);
        (void) hv_store (hv, "app_summary", 11, newSVpv (r->val[i].app_summary, 0), 0);
        (void) hv_store (hv, "app_description", 15, newSVpv (r->val[i].app_description, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_application_list (r);
#line 11827 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_list_applications2); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_list_applications2)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4531 "Guestfs.xs"
      struct guestfs_application2_list *r;
      size_t i;
      HV *hv;
#line 11853 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_list_applications2(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_list_applications2(): g is not a blessed HV reference");
    };
#line 4535 "Guestfs.xs"
      r = guestfs_inspect_list_applications2 (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "app2_name", 9, newSVpv (r->val[i].app2_name, 0), 0);
        (void) hv_store (hv, "app2_display_name", 17, newSVpv (r->val[i].app2_display_name, 0), 0);
        (void) hv_store (hv, "app2_epoch", 10, newSVnv (r->val[i].app2_epoch), 0);
        (void) hv_store (hv, "app2_version", 12, newSVpv (r->val[i].app2_version, 0), 0);
        (void) hv_store (hv, "app2_release", 12, newSVpv (r->val[i].app2_release, 0), 0);
        (void) hv_store (hv, "app2_arch", 9, newSVpv (r->val[i].app2_arch, 0), 0);
        (void) hv_store (hv, "app2_install_path", 17, newSVpv (r->val[i].app2_install_path, 0), 0);
        (void) hv_store (hv, "app2_trans_path", 15, newSVpv (r->val[i].app2_trans_path, 0), 0);
        (void) hv_store (hv, "app2_publisher", 14, newSVpv (r->val[i].app2_publisher, 0), 0);
        (void) hv_store (hv, "app2_url", 8, newSVpv (r->val[i].app2_url, 0), 0);
        (void) hv_store (hv, "app2_source_package", 19, newSVpv (r->val[i].app2_source_package, 0), 0);
        (void) hv_store (hv, "app2_summary", 12, newSVpv (r->val[i].app2_summary, 0), 0);
        (void) hv_store (hv, "app2_description", 16, newSVpv (r->val[i].app2_description, 0), 0);
        (void) hv_store (hv, "app2_spare1", 11, newSVpv (r->val[i].app2_spare1, 0), 0);
        (void) hv_store (hv, "app2_spare2", 11, newSVpv (r->val[i].app2_spare2, 0), 0);
        (void) hv_store (hv, "app2_spare3", 11, newSVpv (r->val[i].app2_spare3, 0), 0);
        (void) hv_store (hv, "app2_spare4", 11, newSVpv (r->val[i].app2_spare4, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_application2_list (r);
#line 11893 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_os); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_os)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4566 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 11917 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_os(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_os(): g is not a blessed HV reference");
    };
#line 4569 "Guestfs.xs"
      r = guestfs_inspect_os (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11941 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_exit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_exit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4584 "Guestfs.xs"
      int r;
#line 11964 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_exit(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_exit(): g is not a blessed HV reference");
    };
#line 4586 "Guestfs.xs"
      r = guestfs_internal_exit (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 11981 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 10)
       croak_xs_usage(cv,  "g, str, optstr, strlist, b, integer, integer64, filein, fileout, bufferin, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	str = (char *)SvPV_nolen(ST(1));
	char *	optstr = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
	char **	strlist = XS_unpack_charPtrPtr(ST(3));
	int	b = (int)SvIV(ST(4));
	int	integer = (int)SvIV(ST(5));
	int64_t    integer64 = my_SvIV64 (ST(6));
	char *	filein = (char *)SvPV_nolen(ST(7));
	char *	fileout = (char *)SvPV_nolen(ST(8));
	char *	bufferin = (char *)SvPV_nolen(ST(9));
	size_t	bufferin_size = SvCUR (ST(9));
#line 4604 "Guestfs.xs"
      int r;
      struct guestfs_internal_test_argv optargs_s = { .bitmask = 0 };
      struct guestfs_internal_test_argv *optargs = &optargs_s;
      size_t items_i;
#line 12017 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test(): g is not a blessed HV reference");
    };
#line 4609 "Guestfs.xs"
      if (((items - 10) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 10; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "obool")) {
          optargs_s.obool = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OBOOL_BITMASK;
        }
        else if (STREQ (this_arg, "oint")) {
          optargs_s.oint = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OINT_BITMASK;
        }
        else if (STREQ (this_arg, "oint64")) {
          optargs_s.oint64 = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OINT64_BITMASK;
        }
        else if (STREQ (this_arg, "ostring")) {
          optargs_s.ostring = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OSTRING_BITMASK;
        }
        else if (STREQ (this_arg, "ostringlist")) {
          size_t i, len;
          char **r;
          SV *arg;
          AV *av;
          SV **svp;

          arg = ST (items_i+1);
          if (!SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
            croak ("array reference expected for '%s' argument", "ostringlist");
          av = (AV *) SvRV (ST (items_i+1));

          /* Note av_len returns index of final element. */
          len = av_len (av) + 1;

          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));
          for (i = 0; i < len; ++i) {
            svp = av_fetch (av, i, 0);
            r[i] = SvPV_nolen (*svp);
          }
          r[i] = NULL;
          optargs_s.ostringlist = r;
          this_mask = GUESTFS_INTERNAL_TEST_OSTRINGLIST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_internal_test_argv (g, str, optstr, strlist, b, integer, integer64, filein, fileout, bufferin, bufferin_size, optargs);
      free (strlist);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12089 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_63_optargs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_63_optargs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "g, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4672 "Guestfs.xs"
      int r;
      struct guestfs_internal_test_63_optargs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_internal_test_63_optargs_argv *optargs = &optargs_s;
      size_t items_i;
#line 12115 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_63_optargs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_63_optargs(): g is not a blessed HV reference");
    };
#line 4677 "Guestfs.xs"
      if (((items - 1) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 1; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "opt1")) {
          optargs_s.opt1 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT1_BITMASK;
        }
        else if (STREQ (this_arg, "opt2")) {
          optargs_s.opt2 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT2_BITMASK;
        }
        else if (STREQ (this_arg, "opt3")) {
          optargs_s.opt3 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT3_BITMASK;
        }
        else if (STREQ (this_arg, "opt4")) {
          optargs_s.opt4 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT4_BITMASK;
        }
        else if (STREQ (this_arg, "opt5")) {
          optargs_s.opt5 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT5_BITMASK;
        }
        else if (STREQ (this_arg, "opt6")) {
          optargs_s.opt6 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT6_BITMASK;
        }
        else if (STREQ (this_arg, "opt7")) {
          optargs_s.opt7 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT7_BITMASK;
        }
        else if (STREQ (this_arg, "opt8")) {
          optargs_s.opt8 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT8_BITMASK;
        }
        else if (STREQ (this_arg, "opt9")) {
          optargs_s.opt9 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT9_BITMASK;
        }
        else if (STREQ (this_arg, "opt10")) {
          optargs_s.opt10 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT10_BITMASK;
        }
        else if (STREQ (this_arg, "opt11")) {
          optargs_s.opt11 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT11_BITMASK;
        }
        else if (STREQ (this_arg, "opt12")) {
          optargs_s.opt12 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT12_BITMASK;
        }
        else if (STREQ (this_arg, "opt13")) {
          optargs_s.opt13 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT13_BITMASK;
        }
        else if (STREQ (this_arg, "opt14")) {
          optargs_s.opt14 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT14_BITMASK;
        }
        else if (STREQ (this_arg, "opt15")) {
          optargs_s.opt15 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT15_BITMASK;
        }
        else if (STREQ (this_arg, "opt16")) {
          optargs_s.opt16 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT16_BITMASK;
        }
        else if (STREQ (this_arg, "opt17")) {
          optargs_s.opt17 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT17_BITMASK;
        }
        else if (STREQ (this_arg, "opt18")) {
          optargs_s.opt18 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT18_BITMASK;
        }
        else if (STREQ (this_arg, "opt19")) {
          optargs_s.opt19 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT19_BITMASK;
        }
        else if (STREQ (this_arg, "opt20")) {
          optargs_s.opt20 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT20_BITMASK;
        }
        else if (STREQ (this_arg, "opt21")) {
          optargs_s.opt21 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT21_BITMASK;
        }
        else if (STREQ (this_arg, "opt22")) {
          optargs_s.opt22 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT22_BITMASK;
        }
        else if (STREQ (this_arg, "opt23")) {
          optargs_s.opt23 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT23_BITMASK;
        }
        else if (STREQ (this_arg, "opt24")) {
          optargs_s.opt24 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT24_BITMASK;
        }
        else if (STREQ (this_arg, "opt25")) {
          optargs_s.opt25 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT25_BITMASK;
        }
        else if (STREQ (this_arg, "opt26")) {
          optargs_s.opt26 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT26_BITMASK;
        }
        else if (STREQ (this_arg, "opt27")) {
          optargs_s.opt27 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT27_BITMASK;
        }
        else if (STREQ (this_arg, "opt28")) {
          optargs_s.opt28 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT28_BITMASK;
        }
        else if (STREQ (this_arg, "opt29")) {
          optargs_s.opt29 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT29_BITMASK;
        }
        else if (STREQ (this_arg, "opt30")) {
          optargs_s.opt30 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT30_BITMASK;
        }
        else if (STREQ (this_arg, "opt31")) {
          optargs_s.opt31 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT31_BITMASK;
        }
        else if (STREQ (this_arg, "opt32")) {
          optargs_s.opt32 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT32_BITMASK;
        }
        else if (STREQ (this_arg, "opt33")) {
          optargs_s.opt33 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT33_BITMASK;
        }
        else if (STREQ (this_arg, "opt34")) {
          optargs_s.opt34 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT34_BITMASK;
        }
        else if (STREQ (this_arg, "opt35")) {
          optargs_s.opt35 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT35_BITMASK;
        }
        else if (STREQ (this_arg, "opt36")) {
          optargs_s.opt36 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT36_BITMASK;
        }
        else if (STREQ (this_arg, "opt37")) {
          optargs_s.opt37 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT37_BITMASK;
        }
        else if (STREQ (this_arg, "opt38")) {
          optargs_s.opt38 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT38_BITMASK;
        }
        else if (STREQ (this_arg, "opt39")) {
          optargs_s.opt39 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT39_BITMASK;
        }
        else if (STREQ (this_arg, "opt40")) {
          optargs_s.opt40 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT40_BITMASK;
        }
        else if (STREQ (this_arg, "opt41")) {
          optargs_s.opt41 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT41_BITMASK;
        }
        else if (STREQ (this_arg, "opt42")) {
          optargs_s.opt42 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT42_BITMASK;
        }
        else if (STREQ (this_arg, "opt43")) {
          optargs_s.opt43 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT43_BITMASK;
        }
        else if (STREQ (this_arg, "opt44")) {
          optargs_s.opt44 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT44_BITMASK;
        }
        else if (STREQ (this_arg, "opt45")) {
          optargs_s.opt45 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT45_BITMASK;
        }
        else if (STREQ (this_arg, "opt46")) {
          optargs_s.opt46 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT46_BITMASK;
        }
        else if (STREQ (this_arg, "opt47")) {
          optargs_s.opt47 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT47_BITMASK;
        }
        else if (STREQ (this_arg, "opt48")) {
          optargs_s.opt48 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT48_BITMASK;
        }
        else if (STREQ (this_arg, "opt49")) {
          optargs_s.opt49 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT49_BITMASK;
        }
        else if (STREQ (this_arg, "opt50")) {
          optargs_s.opt50 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT50_BITMASK;
        }
        else if (STREQ (this_arg, "opt51")) {
          optargs_s.opt51 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT51_BITMASK;
        }
        else if (STREQ (this_arg, "opt52")) {
          optargs_s.opt52 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT52_BITMASK;
        }
        else if (STREQ (this_arg, "opt53")) {
          optargs_s.opt53 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT53_BITMASK;
        }
        else if (STREQ (this_arg, "opt54")) {
          optargs_s.opt54 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT54_BITMASK;
        }
        else if (STREQ (this_arg, "opt55")) {
          optargs_s.opt55 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT55_BITMASK;
        }
        else if (STREQ (this_arg, "opt56")) {
          optargs_s.opt56 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT56_BITMASK;
        }
        else if (STREQ (this_arg, "opt57")) {
          optargs_s.opt57 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT57_BITMASK;
        }
        else if (STREQ (this_arg, "opt58")) {
          optargs_s.opt58 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT58_BITMASK;
        }
        else if (STREQ (this_arg, "opt59")) {
          optargs_s.opt59 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT59_BITMASK;
        }
        else if (STREQ (this_arg, "opt60")) {
          optargs_s.opt60 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT60_BITMASK;
        }
        else if (STREQ (this_arg, "opt61")) {
          optargs_s.opt61 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT61_BITMASK;
        }
        else if (STREQ (this_arg, "opt62")) {
          optargs_s.opt62 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT62_BITMASK;
        }
        else if (STREQ (this_arg, "opt63")) {
          optargs_s.opt63 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT63_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_internal_test_63_optargs_argv (g, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12398 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_close_output); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_close_output)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4951 "Guestfs.xs"
      int r;
#line 12421 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_close_output(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_close_output(): g is not a blessed HV reference");
    };
#line 4953 "Guestfs.xs"
      r = guestfs_internal_test_close_output (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12438 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_only_optargs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_only_optargs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "g, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4961 "Guestfs.xs"
      int r;
      struct guestfs_internal_test_only_optargs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_internal_test_only_optargs_argv *optargs = &optargs_s;
      size_t items_i;
#line 12464 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_only_optargs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_only_optargs(): g is not a blessed HV reference");
    };
#line 4966 "Guestfs.xs"
      if (((items - 1) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 1; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "test")) {
          optargs_s.test = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_ONLY_OPTARGS_TEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_internal_test_only_optargs_argv (g, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12499 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rbool); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rbool)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 4993 "Guestfs.xs"
      int r;
#line 12521 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rbool(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rbool(): g is not a blessed HV reference");
    };
#line 4995 "Guestfs.xs"
      r = guestfs_internal_test_rbool (g, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 12540 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rboolerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rboolerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5006 "Guestfs.xs"
      int r;
#line 12562 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rboolerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rboolerr(): g is not a blessed HV reference");
    };
#line 5008 "Guestfs.xs"
      r = guestfs_internal_test_rboolerr (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 12581 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rbufferout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rbufferout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5020 "Guestfs.xs"
      char *r;
      size_t size;
#line 12605 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rbufferout(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rbufferout(): g is not a blessed HV reference");
    };
#line 5023 "Guestfs.xs"
      r = guestfs_internal_test_rbufferout (g, val, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 12625 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rbufferouterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rbufferouterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5035 "Guestfs.xs"
      char *r;
      size_t size;
#line 12648 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rbufferouterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rbufferouterr(): g is not a blessed HV reference");
    };
#line 5038 "Guestfs.xs"
      r = guestfs_internal_test_rbufferouterr (g, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 12668 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconstoptstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconstoptstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5051 "Guestfs.xs"
      const char *r;
#line 12691 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconstoptstring(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconstoptstring(): g is not a blessed HV reference");
    };
#line 5053 "Guestfs.xs"
      r = guestfs_internal_test_rconstoptstring (g, val);
      if (r == NULL)
        RETVAL = &PL_sv_undef;
      else
        RETVAL = newSVpv (r, 0);
#line 12711 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconstoptstringerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconstoptstringerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5065 "Guestfs.xs"
      const char *r;
#line 12733 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconstoptstringerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconstoptstringerr(): g is not a blessed HV reference");
    };
#line 5067 "Guestfs.xs"
      r = guestfs_internal_test_rconstoptstringerr (g);
      if (r == NULL)
        RETVAL = &PL_sv_undef;
      else
        RETVAL = newSVpv (r, 0);
#line 12753 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconststring); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconststring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5080 "Guestfs.xs"
      const char *r;
#line 12776 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconststring(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconststring(): g is not a blessed HV reference");
    };
#line 5082 "Guestfs.xs"
      r = guestfs_internal_test_rconststring (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 12795 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconststringerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconststringerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5093 "Guestfs.xs"
      const char *r;
#line 12817 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconststringerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconststringerr(): g is not a blessed HV reference");
    };
#line 5095 "Guestfs.xs"
      r = guestfs_internal_test_rconststringerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 12836 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rhashtable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rhashtable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5107 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 12862 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rhashtable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rhashtable(): g is not a blessed HV reference");
    };
#line 5110 "Guestfs.xs"
      r = guestfs_internal_test_rhashtable (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 12886 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rhashtableerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rhashtableerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5125 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 12910 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rhashtableerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rhashtableerr(): g is not a blessed HV reference");
    };
#line 5128 "Guestfs.xs"
      r = guestfs_internal_test_rhashtableerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 12934 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5144 "Guestfs.xs"
      int r;
#line 12956 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rint(): g is not a blessed HV reference");
    };
#line 5146 "Guestfs.xs"
      r = guestfs_internal_test_rint (g, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 12975 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rint64); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rint64)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5158 "Guestfs.xs"
      int64_t r;
#line 12998 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rint64(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rint64(): g is not a blessed HV reference");
    };
#line 5160 "Guestfs.xs"
      r = guestfs_internal_test_rint64 (g, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 13017 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rint64err); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rint64err)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5171 "Guestfs.xs"
      int64_t r;
#line 13039 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rint64err(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rint64err(): g is not a blessed HV reference");
    };
#line 5173 "Guestfs.xs"
      r = guestfs_internal_test_rint64err (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 13058 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rinterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rinterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5184 "Guestfs.xs"
      int r;
#line 13080 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rinterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rinterr(): g is not a blessed HV reference");
    };
#line 5186 "Guestfs.xs"
      r = guestfs_internal_test_rinterr (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13099 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5198 "Guestfs.xs"
      char *r;
#line 13122 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstring(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstring(): g is not a blessed HV reference");
    };
#line 5200 "Guestfs.xs"
      r = guestfs_internal_test_rstring (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 13142 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rstringerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstringerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5212 "Guestfs.xs"
      char *r;
#line 13164 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstringerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstringerr(): g is not a blessed HV reference");
    };
#line 5214 "Guestfs.xs"
      r = guestfs_internal_test_rstringerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 13184 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rstringlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstringlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5227 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 13210 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstringlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstringlist(): g is not a blessed HV reference");
    };
#line 5230 "Guestfs.xs"
      r = guestfs_internal_test_rstringlist (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 13234 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstringlisterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstringlisterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5245 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 13258 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstringlisterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstringlisterr(): g is not a blessed HV reference");
    };
#line 5248 "Guestfs.xs"
      r = guestfs_internal_test_rstringlisterr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 13282 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstruct); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstruct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5264 "Guestfs.xs"
      struct guestfs_lvm_pv *r;
#line 13306 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstruct(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstruct(): g is not a blessed HV reference");
    };
#line 5266 "Guestfs.xs"
      r = guestfs_internal_test_rstruct (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 14);
      PUSHs (sv_2mortal (newSVpv ("pv_name", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_name, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_uuid", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_uuid, 32)));
      PUSHs (sv_2mortal (newSVpv ("pv_fmt", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_fmt, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_size)));
      PUSHs (sv_2mortal (newSVpv ("dev_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->dev_size)));
      PUSHs (sv_2mortal (newSVpv ("pv_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_free)));
      PUSHs (sv_2mortal (newSVpv ("pv_used", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_used)));
      PUSHs (sv_2mortal (newSVpv ("pv_attr", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_attr, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_alloc_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_alloc_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_tags", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_tags, 0)));
      PUSHs (sv_2mortal (newSVpv ("pe_start", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pe_start)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_mda_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_mda_free)));
      free (r);
#line 13353 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstructerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstructerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5304 "Guestfs.xs"
      struct guestfs_lvm_pv *r;
#line 13376 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstructerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstructerr(): g is not a blessed HV reference");
    };
#line 5306 "Guestfs.xs"
      r = guestfs_internal_test_rstructerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 14);
      PUSHs (sv_2mortal (newSVpv ("pv_name", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_name, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_uuid", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_uuid, 32)));
      PUSHs (sv_2mortal (newSVpv ("pv_fmt", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_fmt, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_size)));
      PUSHs (sv_2mortal (newSVpv ("dev_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->dev_size)));
      PUSHs (sv_2mortal (newSVpv ("pv_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_free)));
      PUSHs (sv_2mortal (newSVpv ("pv_used", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_used)));
      PUSHs (sv_2mortal (newSVpv ("pv_attr", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_attr, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_alloc_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_alloc_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_tags", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_tags, 0)));
      PUSHs (sv_2mortal (newSVpv ("pe_start", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pe_start)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_mda_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_mda_free)));
      free (r);
#line 13423 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstructlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstructlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5345 "Guestfs.xs"
      struct guestfs_lvm_pv_list *r;
      size_t i;
      HV *hv;
#line 13449 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstructlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstructlist(): g is not a blessed HV reference");
    };
#line 5349 "Guestfs.xs"
      r = guestfs_internal_test_rstructlist (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "pv_name", 7, newSVpv (r->val[i].pv_name, 0), 0);
        (void) hv_store (hv, "pv_uuid", 7, newSVpv (r->val[i].pv_uuid, 32), 0);
        (void) hv_store (hv, "pv_fmt", 6, newSVpv (r->val[i].pv_fmt, 0), 0);
        (void) hv_store (hv, "pv_size", 7, my_newSVull (r->val[i].pv_size), 0);
        (void) hv_store (hv, "dev_size", 8, my_newSVull (r->val[i].dev_size), 0);
        (void) hv_store (hv, "pv_free", 7, my_newSVull (r->val[i].pv_free), 0);
        (void) hv_store (hv, "pv_used", 7, my_newSVull (r->val[i].pv_used), 0);
        (void) hv_store (hv, "pv_attr", 7, newSVpv (r->val[i].pv_attr, 0), 0);
        (void) hv_store (hv, "pv_pe_count", 11, my_newSVll (r->val[i].pv_pe_count), 0);
        (void) hv_store (hv, "pv_pe_alloc_count", 17, my_newSVll (r->val[i].pv_pe_alloc_count), 0);
        (void) hv_store (hv, "pv_tags", 7, newSVpv (r->val[i].pv_tags, 0), 0);
        (void) hv_store (hv, "pe_start", 8, my_newSVull (r->val[i].pe_start), 0);
        (void) hv_store (hv, "pv_mda_count", 12, my_newSVll (r->val[i].pv_mda_count), 0);
        (void) hv_store (hv, "pv_mda_free", 11, my_newSVull (r->val[i].pv_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_pv_list (r);
#line 13486 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstructlisterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstructlisterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5377 "Guestfs.xs"
      struct guestfs_lvm_pv_list *r;
      size_t i;
      HV *hv;
#line 13511 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstructlisterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstructlisterr(): g is not a blessed HV reference");
    };
#line 5381 "Guestfs.xs"
      r = guestfs_internal_test_rstructlisterr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "pv_name", 7, newSVpv (r->val[i].pv_name, 0), 0);
        (void) hv_store (hv, "pv_uuid", 7, newSVpv (r->val[i].pv_uuid, 32), 0);
        (void) hv_store (hv, "pv_fmt", 6, newSVpv (r->val[i].pv_fmt, 0), 0);
        (void) hv_store (hv, "pv_size", 7, my_newSVull (r->val[i].pv_size), 0);
        (void) hv_store (hv, "dev_size", 8, my_newSVull (r->val[i].dev_size), 0);
        (void) hv_store (hv, "pv_free", 7, my_newSVull (r->val[i].pv_free), 0);
        (void) hv_store (hv, "pv_used", 7, my_newSVull (r->val[i].pv_used), 0);
        (void) hv_store (hv, "pv_attr", 7, newSVpv (r->val[i].pv_attr, 0), 0);
        (void) hv_store (hv, "pv_pe_count", 11, my_newSVll (r->val[i].pv_pe_count), 0);
        (void) hv_store (hv, "pv_pe_alloc_count", 17, my_newSVll (r->val[i].pv_pe_alloc_count), 0);
        (void) hv_store (hv, "pv_tags", 7, newSVpv (r->val[i].pv_tags, 0), 0);
        (void) hv_store (hv, "pe_start", 8, my_newSVull (r->val[i].pe_start), 0);
        (void) hv_store (hv, "pv_mda_count", 12, my_newSVll (r->val[i].pv_mda_count), 0);
        (void) hv_store (hv, "pv_mda_free", 11, my_newSVull (r->val[i].pv_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_pv_list (r);
#line 13548 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_set_output); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_set_output)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 5410 "Guestfs.xs"
      int r;
#line 13572 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_set_output(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_set_output(): g is not a blessed HV reference");
    };
#line 5412 "Guestfs.xs"
      r = guestfs_internal_test_set_output (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 13589 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_is_blockdev); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_blockdev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5421 "Guestfs.xs"
      int r;
      struct guestfs_is_blockdev_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_blockdev_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13614 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_blockdev(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_blockdev(): g is not a blessed HV reference");
    };
#line 5426 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_BLOCKDEV_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_blockdev_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13651 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_busy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_busy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5455 "Guestfs.xs"
      int r;
#line 13673 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_busy(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_busy(): g is not a blessed HV reference");
    };
#line 5457 "Guestfs.xs"
      r = guestfs_is_busy (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13692 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_chardev); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_chardev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5469 "Guestfs.xs"
      int r;
      struct guestfs_is_chardev_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_chardev_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13718 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_chardev(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_chardev(): g is not a blessed HV reference");
    };
#line 5474 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_CHARDEV_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_chardev_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13755 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_config); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_config)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5503 "Guestfs.xs"
      int r;
#line 13777 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_config(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_config(): g is not a blessed HV reference");
    };
#line 5505 "Guestfs.xs"
      r = guestfs_is_config (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13796 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_dir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_dir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5517 "Guestfs.xs"
      int r;
      struct guestfs_is_dir_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_dir_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13822 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_dir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_dir(): g is not a blessed HV reference");
    };
#line 5522 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_DIR_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_dir_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13859 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_fifo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_fifo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5552 "Guestfs.xs"
      int r;
      struct guestfs_is_fifo_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_fifo_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13885 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_fifo(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_fifo(): g is not a blessed HV reference");
    };
#line 5557 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_FIFO_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_fifo_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13922 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5587 "Guestfs.xs"
      int r;
      struct guestfs_is_file_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_file_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13948 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_file(): g is not a blessed HV reference");
    };
#line 5592 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_file_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13985 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_launching); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_launching)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5621 "Guestfs.xs"
      int r;
#line 14007 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_launching(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_launching(): g is not a blessed HV reference");
    };
#line 5623 "Guestfs.xs"
      r = guestfs_is_launching (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14026 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_lv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_lv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5635 "Guestfs.xs"
      int r;
#line 14049 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_lv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_lv(): g is not a blessed HV reference");
    };
#line 5637 "Guestfs.xs"
      r = guestfs_is_lv (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14068 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_ready); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_ready)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5648 "Guestfs.xs"
      int r;
#line 14090 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_ready(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_ready(): g is not a blessed HV reference");
    };
#line 5650 "Guestfs.xs"
      r = guestfs_is_ready (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14109 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_socket); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_socket)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5662 "Guestfs.xs"
      int r;
      struct guestfs_is_socket_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_socket_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 14135 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_socket(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_socket(): g is not a blessed HV reference");
    };
#line 5667 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_SOCKET_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_socket_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14172 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_symlink); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_symlink)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5697 "Guestfs.xs"
      int r;
#line 14195 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_symlink(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_symlink(): g is not a blessed HV reference");
    };
#line 5699 "Guestfs.xs"
      r = guestfs_is_symlink (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14214 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_whole_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_whole_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5711 "Guestfs.xs"
      int r;
#line 14237 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_whole_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_whole_device(): g is not a blessed HV reference");
    };
#line 5713 "Guestfs.xs"
      r = guestfs_is_whole_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14256 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_zero); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_zero)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5725 "Guestfs.xs"
      int r;
#line 14279 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_zero(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_zero(): g is not a blessed HV reference");
    };
#line 5727 "Guestfs.xs"
      r = guestfs_is_zero (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14298 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_zero_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_zero_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5739 "Guestfs.xs"
      int r;
#line 14321 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_zero_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_zero_device(): g is not a blessed HV reference");
    };
#line 5741 "Guestfs.xs"
      r = guestfs_is_zero_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14340 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_isoinfo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_isoinfo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, isofile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	isofile = (char *)SvPV_nolen(ST(1));
#line 5753 "Guestfs.xs"
      struct guestfs_isoinfo *r;
#line 14365 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::isoinfo(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::isoinfo(): g is not a blessed HV reference");
    };
#line 5755 "Guestfs.xs"
      r = guestfs_isoinfo (g, isofile);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 17);
      PUSHs (sv_2mortal (newSVpv ("iso_system_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_system_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_space_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_space_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_set_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_sequence_number", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_sequence_number)));
      PUSHs (sv_2mortal (newSVpv ("iso_logical_block_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_logical_block_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_set_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_publisher_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_publisher_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_data_preparer_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_data_preparer_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_application_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_application_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_copyright_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_copyright_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_abstract_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_abstract_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_bibliographic_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_bibliographic_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_creation_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_creation_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_modification_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_modification_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_expiration_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_expiration_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_effective_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_effective_t)));
      free (r);
#line 14418 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_isoinfo_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_isoinfo_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5800 "Guestfs.xs"
      struct guestfs_isoinfo *r;
#line 14442 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::isoinfo_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::isoinfo_device(): g is not a blessed HV reference");
    };
#line 5802 "Guestfs.xs"
      r = guestfs_isoinfo_device (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 17);
      PUSHs (sv_2mortal (newSVpv ("iso_system_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_system_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_space_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_space_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_set_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_sequence_number", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_sequence_number)));
      PUSHs (sv_2mortal (newSVpv ("iso_logical_block_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_logical_block_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_set_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_publisher_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_publisher_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_data_preparer_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_data_preparer_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_application_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_application_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_copyright_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_copyright_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_abstract_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_abstract_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_bibliographic_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_bibliographic_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_creation_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_creation_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_modification_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_modification_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_expiration_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_expiration_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_effective_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_effective_t)));
      free (r);
#line 14495 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5846 "Guestfs.xs"
      int r;
#line 14518 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_close(): g is not a blessed HV reference");
    };
#line 5848 "Guestfs.xs"
      r = guestfs_journal_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14535 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5856 "Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 14560 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_get(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_get(): g is not a blessed HV reference");
    };
#line 5860 "Guestfs.xs"
      r = guestfs_journal_get (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 14585 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_get_data_threshold); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_get_data_threshold)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5876 "Guestfs.xs"
      int64_t r;
#line 14606 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_get_data_threshold(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_get_data_threshold(): g is not a blessed HV reference");
    };
#line 5878 "Guestfs.xs"
      r = guestfs_journal_get_data_threshold (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 14625 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_journal_get_realtime_usec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_get_realtime_usec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5889 "Guestfs.xs"
      int64_t r;
#line 14647 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_get_realtime_usec(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_get_realtime_usec(): g is not a blessed HV reference");
    };
#line 5891 "Guestfs.xs"
      r = guestfs_journal_get_realtime_usec (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 14666 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_journal_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5902 "Guestfs.xs"
      int r;
#line 14688 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_next(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_next(): g is not a blessed HV reference");
    };
#line 5904 "Guestfs.xs"
      r = guestfs_journal_next (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14707 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_journal_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 5916 "Guestfs.xs"
      int r;
#line 14732 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_open(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_open(): g is not a blessed HV reference");
    };
#line 5918 "Guestfs.xs"
      r = guestfs_journal_open (g, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14749 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_set_data_threshold); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_set_data_threshold)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, threshold");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    threshold = my_SvIV64 (ST(1));
#line 5927 "Guestfs.xs"
      int r;
#line 14773 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_set_data_threshold(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_set_data_threshold(): g is not a blessed HV reference");
    };
#line 5929 "Guestfs.xs"
      r = guestfs_journal_set_data_threshold (g, threshold);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14790 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_skip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_skip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, skip");
    {
	guestfs_h *	g;
	int64_t    skip = my_SvIV64 (ST(1));
#line 5938 "Guestfs.xs"
      int64_t r;
#line 14812 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_skip(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_skip(): g is not a blessed HV reference");
    };
#line 5940 "Guestfs.xs"
      r = guestfs_journal_skip (g, skip);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 14831 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_kill_subprocess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_kill_subprocess)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5951 "Guestfs.xs"
      int r;
#line 14855 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::kill_subprocess(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::kill_subprocess(): g is not a blessed HV reference");
    };
#line 5953 "Guestfs.xs"
      r = guestfs_kill_subprocess (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14872 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_launch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_launch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5961 "Guestfs.xs"
      int r;
#line 14895 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::launch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::launch(): g is not a blessed HV reference");
    };
#line 5963 "Guestfs.xs"
      r = guestfs_launch (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14912 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lchown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lchown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, owner, group, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	owner = (int)SvIV(ST(1));
	int	group = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 5974 "Guestfs.xs"
      int r;
#line 14938 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lchown(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lchown(): g is not a blessed HV reference");
    };
#line 5976 "Guestfs.xs"
      r = guestfs_lchown (g, owner, group, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14955 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_create_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_create_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5984 "Guestfs.xs"
      int r;
#line 14978 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_create_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_create_all(): g is not a blessed HV reference");
    };
#line 5986 "Guestfs.xs"
      r = guestfs_ldmtool_create_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14995 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_diskgroup_disks); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_diskgroup_disks)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, diskgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
#line 5995 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15020 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_diskgroup_disks(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_diskgroup_disks(): g is not a blessed HV reference");
    };
#line 5998 "Guestfs.xs"
      r = guestfs_ldmtool_diskgroup_disks (g, diskgroup);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15044 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_diskgroup_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_diskgroup_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, diskgroup");
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
#line 6014 "Guestfs.xs"
      char *r;
#line 15066 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_diskgroup_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_diskgroup_name(): g is not a blessed HV reference");
    };
#line 6016 "Guestfs.xs"
      r = guestfs_ldmtool_diskgroup_name (g, diskgroup);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15086 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ldmtool_diskgroup_volumes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_diskgroup_volumes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, diskgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
#line 6029 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15112 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_diskgroup_volumes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_diskgroup_volumes(): g is not a blessed HV reference");
    };
#line 6032 "Guestfs.xs"
      r = guestfs_ldmtool_diskgroup_volumes (g, diskgroup);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15136 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_remove_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_remove_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6047 "Guestfs.xs"
      int r;
#line 15159 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_remove_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_remove_all(): g is not a blessed HV reference");
    };
#line 6049 "Guestfs.xs"
      r = guestfs_ldmtool_remove_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 15176 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_scan); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_scan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6057 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15200 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_scan(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_scan(): g is not a blessed HV reference");
    };
#line 6060 "Guestfs.xs"
      r = guestfs_ldmtool_scan (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15224 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_scan_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_scan_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, devices");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
#line 6076 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15249 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_scan_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_scan_devices(): g is not a blessed HV reference");
    };
#line 6079 "Guestfs.xs"
      r = guestfs_ldmtool_scan_devices (g, devices);
      free (devices);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15274 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_volume_hint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_volume_hint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, diskgroup, volume");
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
	char *	volume = (char *)SvPV_nolen(ST(2));
#line 6097 "Guestfs.xs"
      char *r;
#line 15297 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_volume_hint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_volume_hint(): g is not a blessed HV reference");
    };
#line 6099 "Guestfs.xs"
      r = guestfs_ldmtool_volume_hint (g, diskgroup, volume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15317 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ldmtool_volume_partitions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_volume_partitions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, diskgroup, volume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
	char *	volume = (char *)SvPV_nolen(ST(2));
#line 6113 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15344 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_volume_partitions(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_volume_partitions(): g is not a blessed HV reference");
    };
#line 6116 "Guestfs.xs"
      r = guestfs_ldmtool_volume_partitions (g, diskgroup, volume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15368 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_volume_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_volume_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, diskgroup, volume");
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
	char *	volume = (char *)SvPV_nolen(ST(2));
#line 6133 "Guestfs.xs"
      char *r;
#line 15391 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_volume_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_volume_type(): g is not a blessed HV reference");
    };
#line 6135 "Guestfs.xs"
      r = guestfs_ldmtool_volume_type (g, diskgroup, volume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15411 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lgetxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lgetxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, name");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 6149 "Guestfs.xs"
      char *r;
      size_t size;
#line 15436 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lgetxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lgetxattr(): g is not a blessed HV reference");
    };
#line 6152 "Guestfs.xs"
      r = guestfs_lgetxattr (g, path, name, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 15456 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lgetxattrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lgetxattrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 6165 "Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 15483 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lgetxattrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lgetxattrs(): g is not a blessed HV reference");
    };
#line 6169 "Guestfs.xs"
      r = guestfs_lgetxattrs (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 15508 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_9p); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_9p)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6185 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15532 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_9p(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_9p(): g is not a blessed HV reference");
    };
#line 6188 "Guestfs.xs"
      r = guestfs_list_9p (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15556 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6203 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15580 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_devices(): g is not a blessed HV reference");
    };
#line 6206 "Guestfs.xs"
      r = guestfs_list_devices (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15604 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_disk_labels); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_disk_labels)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6221 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15628 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_disk_labels(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_disk_labels(): g is not a blessed HV reference");
    };
#line 6224 "Guestfs.xs"
      r = guestfs_list_disk_labels (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15652 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_dm_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_dm_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6239 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15676 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_dm_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_dm_devices(): g is not a blessed HV reference");
    };
#line 6242 "Guestfs.xs"
      r = guestfs_list_dm_devices (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15700 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_filesystems); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_filesystems)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6257 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15724 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_filesystems(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_filesystems(): g is not a blessed HV reference");
    };
#line 6260 "Guestfs.xs"
      r = guestfs_list_filesystems (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15748 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_ldm_partitions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_ldm_partitions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6275 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15772 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_ldm_partitions(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_ldm_partitions(): g is not a blessed HV reference");
    };
#line 6278 "Guestfs.xs"
      r = guestfs_list_ldm_partitions (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15796 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_ldm_volumes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_ldm_volumes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6293 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15820 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_ldm_volumes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_ldm_volumes(): g is not a blessed HV reference");
    };
#line 6296 "Guestfs.xs"
      r = guestfs_list_ldm_volumes (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15844 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_md_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_md_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6311 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15868 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_md_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_md_devices(): g is not a blessed HV reference");
    };
#line 6314 "Guestfs.xs"
      r = guestfs_list_md_devices (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15892 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_partitions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_partitions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6329 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 15916 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_partitions(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_partitions(): g is not a blessed HV reference");
    };
#line 6332 "Guestfs.xs"
      r = guestfs_list_partitions (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15940 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ll); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ll)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 6348 "Guestfs.xs"
      char *r;
#line 15962 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ll(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ll(): g is not a blessed HV reference");
    };
#line 6350 "Guestfs.xs"
      r = guestfs_ll (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15982 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_llz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_llz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 6363 "Guestfs.xs"
      char *r;
#line 16005 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::llz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::llz(): g is not a blessed HV reference");
    };
#line 6365 "Guestfs.xs"
      r = guestfs_llz (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 16025 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ln); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6379 "Guestfs.xs"
      int r;
#line 16051 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln(): g is not a blessed HV reference");
    };
#line 6381 "Guestfs.xs"
      r = guestfs_ln (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16068 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ln_f); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln_f)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6391 "Guestfs.xs"
      int r;
#line 16093 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln_f(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln_f(): g is not a blessed HV reference");
    };
#line 6393 "Guestfs.xs"
      r = guestfs_ln_f (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16110 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ln_s); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln_s)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6403 "Guestfs.xs"
      int r;
#line 16135 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln_s(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln_s(): g is not a blessed HV reference");
    };
#line 6405 "Guestfs.xs"
      r = guestfs_ln_s (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16152 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ln_sf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln_sf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6415 "Guestfs.xs"
      int r;
#line 16177 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln_sf(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln_sf(): g is not a blessed HV reference");
    };
#line 6417 "Guestfs.xs"
      r = guestfs_ln_sf (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16194 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lremovexattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lremovexattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, xattr, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 6427 "Guestfs.xs"
      int r;
#line 16219 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lremovexattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lremovexattr(): g is not a blessed HV reference");
    };
#line 6429 "Guestfs.xs"
      r = guestfs_lremovexattr (g, xattr, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16236 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ls); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ls)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 6438 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 16261 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ls(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ls(): g is not a blessed HV reference");
    };
#line 6441 "Guestfs.xs"
      r = guestfs_ls (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 16285 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ls0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ls0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, dir, filenames");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
	char *	filenames = (char *)SvPV_nolen(ST(2));
#line 6458 "Guestfs.xs"
      int r;
#line 16310 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ls0(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ls0(): g is not a blessed HV reference");
    };
#line 6460 "Guestfs.xs"
      r = guestfs_ls0 (g, dir, filenames);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16327 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lsetxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lsetxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, xattr, val, vallen, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
	int	vallen = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 6472 "Guestfs.xs"
      int r;
#line 16354 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lsetxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lsetxattr(): g is not a blessed HV reference");
    };
#line 6474 "Guestfs.xs"
      r = guestfs_lsetxattr (g, xattr, val, vallen, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16371 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 6483 "Guestfs.xs"
      struct guestfs_stat *r;
#line 16395 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstat(): g is not a blessed HV reference");
    };
#line 6485 "Guestfs.xs"
      r = guestfs_lstat (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 13);
      PUSHs (sv_2mortal (newSVpv ("dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->dev)));
      PUSHs (sv_2mortal (newSVpv ("ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ino)));
      PUSHs (sv_2mortal (newSVpv ("mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mode)));
      PUSHs (sv_2mortal (newSVpv ("nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->nlink)));
      PUSHs (sv_2mortal (newSVpv ("uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->uid)));
      PUSHs (sv_2mortal (newSVpv ("gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->gid)));
      PUSHs (sv_2mortal (newSVpv ("rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->rdev)));
      PUSHs (sv_2mortal (newSVpv ("size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->size)));
      PUSHs (sv_2mortal (newSVpv ("blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blksize)));
      PUSHs (sv_2mortal (newSVpv ("blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blocks)));
      PUSHs (sv_2mortal (newSVpv ("atime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->atime)));
      PUSHs (sv_2mortal (newSVpv ("mtime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mtime)));
      PUSHs (sv_2mortal (newSVpv ("ctime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ctime)));
      free (r);
#line 16440 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstatlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstatlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 6523 "Guestfs.xs"
      struct guestfs_stat_list *r;
      size_t i;
      HV *hv;
#line 16467 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstatlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstatlist(): g is not a blessed HV reference");
    };
#line 6527 "Guestfs.xs"
      r = guestfs_lstatlist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "dev", 3, my_newSVll (r->val[i].dev), 0);
        (void) hv_store (hv, "ino", 3, my_newSVll (r->val[i].ino), 0);
        (void) hv_store (hv, "mode", 4, my_newSVll (r->val[i].mode), 0);
        (void) hv_store (hv, "nlink", 5, my_newSVll (r->val[i].nlink), 0);
        (void) hv_store (hv, "uid", 3, my_newSVll (r->val[i].uid), 0);
        (void) hv_store (hv, "gid", 3, my_newSVll (r->val[i].gid), 0);
        (void) hv_store (hv, "rdev", 4, my_newSVll (r->val[i].rdev), 0);
        (void) hv_store (hv, "size", 4, my_newSVll (r->val[i].size), 0);
        (void) hv_store (hv, "blksize", 7, my_newSVll (r->val[i].blksize), 0);
        (void) hv_store (hv, "blocks", 6, my_newSVll (r->val[i].blocks), 0);
        (void) hv_store (hv, "atime", 5, my_newSVll (r->val[i].atime), 0);
        (void) hv_store (hv, "mtime", 5, my_newSVll (r->val[i].mtime), 0);
        (void) hv_store (hv, "ctime", 5, my_newSVll (r->val[i].ctime), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_stat_list (r);
#line 16504 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstatns); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstatns)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 6556 "Guestfs.xs"
      struct guestfs_statns *r;
#line 16528 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstatns(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstatns(): g is not a blessed HV reference");
    };
#line 6558 "Guestfs.xs"
      r = guestfs_lstatns (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 22);
      PUSHs (sv_2mortal (newSVpv ("st_dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_dev)));
      PUSHs (sv_2mortal (newSVpv ("st_ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ino)));
      PUSHs (sv_2mortal (newSVpv ("st_mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mode)));
      PUSHs (sv_2mortal (newSVpv ("st_nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_nlink)));
      PUSHs (sv_2mortal (newSVpv ("st_uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_uid)));
      PUSHs (sv_2mortal (newSVpv ("st_gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_gid)));
      PUSHs (sv_2mortal (newSVpv ("st_rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_rdev)));
      PUSHs (sv_2mortal (newSVpv ("st_size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_size)));
      PUSHs (sv_2mortal (newSVpv ("st_blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blksize)));
      PUSHs (sv_2mortal (newSVpv ("st_blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blocks)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_spare1", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare1)));
      PUSHs (sv_2mortal (newSVpv ("st_spare2", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare2)));
      PUSHs (sv_2mortal (newSVpv ("st_spare3", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare3)));
      PUSHs (sv_2mortal (newSVpv ("st_spare4", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare4)));
      PUSHs (sv_2mortal (newSVpv ("st_spare5", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare5)));
      PUSHs (sv_2mortal (newSVpv ("st_spare6", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare6)));
      free (r);
#line 16591 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstatnslist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstatnslist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 6614 "Guestfs.xs"
      struct guestfs_statns_list *r;
      size_t i;
      HV *hv;
#line 16618 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstatnslist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstatnslist(): g is not a blessed HV reference");
    };
#line 6618 "Guestfs.xs"
      r = guestfs_lstatnslist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "st_dev", 6, my_newSVll (r->val[i].st_dev), 0);
        (void) hv_store (hv, "st_ino", 6, my_newSVll (r->val[i].st_ino), 0);
        (void) hv_store (hv, "st_mode", 7, my_newSVll (r->val[i].st_mode), 0);
        (void) hv_store (hv, "st_nlink", 8, my_newSVll (r->val[i].st_nlink), 0);
        (void) hv_store (hv, "st_uid", 6, my_newSVll (r->val[i].st_uid), 0);
        (void) hv_store (hv, "st_gid", 6, my_newSVll (r->val[i].st_gid), 0);
        (void) hv_store (hv, "st_rdev", 7, my_newSVll (r->val[i].st_rdev), 0);
        (void) hv_store (hv, "st_size", 7, my_newSVll (r->val[i].st_size), 0);
        (void) hv_store (hv, "st_blksize", 10, my_newSVll (r->val[i].st_blksize), 0);
        (void) hv_store (hv, "st_blocks", 9, my_newSVll (r->val[i].st_blocks), 0);
        (void) hv_store (hv, "st_atime_sec", 12, my_newSVll (r->val[i].st_atime_sec), 0);
        (void) hv_store (hv, "st_atime_nsec", 13, my_newSVll (r->val[i].st_atime_nsec), 0);
        (void) hv_store (hv, "st_mtime_sec", 12, my_newSVll (r->val[i].st_mtime_sec), 0);
        (void) hv_store (hv, "st_mtime_nsec", 13, my_newSVll (r->val[i].st_mtime_nsec), 0);
        (void) hv_store (hv, "st_ctime_sec", 12, my_newSVll (r->val[i].st_ctime_sec), 0);
        (void) hv_store (hv, "st_ctime_nsec", 13, my_newSVll (r->val[i].st_ctime_nsec), 0);
        (void) hv_store (hv, "st_spare1", 9, my_newSVll (r->val[i].st_spare1), 0);
        (void) hv_store (hv, "st_spare2", 9, my_newSVll (r->val[i].st_spare2), 0);
        (void) hv_store (hv, "st_spare3", 9, my_newSVll (r->val[i].st_spare3), 0);
        (void) hv_store (hv, "st_spare4", 9, my_newSVll (r->val[i].st_spare4), 0);
        (void) hv_store (hv, "st_spare5", 9, my_newSVll (r->val[i].st_spare5), 0);
        (void) hv_store (hv, "st_spare6", 9, my_newSVll (r->val[i].st_spare6), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_statns_list (r);
#line 16664 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_add_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_add_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, device, key, newkey, keyslot");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	char *	newkey = (char *)SvPV_nolen(ST(3));
	int	keyslot = (int)SvIV(ST(4));
#line 6659 "Guestfs.xs"
      int r;
#line 16691 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_add_key(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_add_key(): g is not a blessed HV reference");
    };
#line 6661 "Guestfs.xs"
      r = guestfs_luks_add_key (g, device, key, newkey, keyslot);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16708 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 6670 "Guestfs.xs"
      int r;
#line 16732 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_close(): g is not a blessed HV reference");
    };
#line 6672 "Guestfs.xs"
      r = guestfs_luks_close (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16749 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, keyslot");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int	keyslot = (int)SvIV(ST(3));
#line 6683 "Guestfs.xs"
      int r;
#line 16775 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_format(): g is not a blessed HV reference");
    };
#line 6685 "Guestfs.xs"
      r = guestfs_luks_format (g, device, key, keyslot);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16792 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_format_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_format_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, device, key, keyslot, cipher");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int	keyslot = (int)SvIV(ST(3));
	char *	cipher = (char *)SvPV_nolen(ST(4));
#line 6697 "Guestfs.xs"
      int r;
#line 16819 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_format_cipher(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_format_cipher(): g is not a blessed HV reference");
    };
#line 6699 "Guestfs.xs"
      r = guestfs_luks_format_cipher (g, device, key, keyslot, cipher);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16836 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_kill_slot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_kill_slot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, keyslot");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int	keyslot = (int)SvIV(ST(3));
#line 6710 "Guestfs.xs"
      int r;
#line 16862 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_kill_slot(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_kill_slot(): g is not a blessed HV reference");
    };
#line 6712 "Guestfs.xs"
      r = guestfs_luks_kill_slot (g, device, key, keyslot);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16879 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, mapname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	char *	mapname = (char *)SvPV_nolen(ST(3));
#line 6723 "Guestfs.xs"
      int r;
#line 16905 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_open(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_open(): g is not a blessed HV reference");
    };
#line 6725 "Guestfs.xs"
      r = guestfs_luks_open (g, device, key, mapname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16922 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_open_ro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_open_ro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, mapname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	char *	mapname = (char *)SvPV_nolen(ST(3));
#line 6736 "Guestfs.xs"
      int r;
#line 16948 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_open_ro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_open_ro(): g is not a blessed HV reference");
    };
#line 6738 "Guestfs.xs"
      r = guestfs_luks_open_ro (g, device, key, mapname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16965 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvcreate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvcreate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, logvol, volgroup, mbytes");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	logvol = (char *)SvPV_nolen(ST(1));
	char *	volgroup = (char *)SvPV_nolen(ST(2));
	int	mbytes = (int)SvIV(ST(3));
#line 6749 "Guestfs.xs"
      int r;
#line 16991 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvcreate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvcreate(): g is not a blessed HV reference");
    };
#line 6751 "Guestfs.xs"
      r = guestfs_lvcreate (g, logvol, volgroup, mbytes);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17008 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvcreate_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvcreate_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, logvol, volgroup, percent");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	logvol = (char *)SvPV_nolen(ST(1));
	char *	volgroup = (char *)SvPV_nolen(ST(2));
	int	percent = (int)SvIV(ST(3));
#line 6762 "Guestfs.xs"
      int r;
#line 17034 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvcreate_free(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvcreate_free(): g is not a blessed HV reference");
    };
#line 6764 "Guestfs.xs"
      r = guestfs_lvcreate_free (g, logvol, volgroup, percent);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17051 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvm_canonical_lv_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_canonical_lv_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, lvname");
    {
	guestfs_h *	g;
	char *	lvname = (char *)SvPV_nolen(ST(1));
#line 6773 "Guestfs.xs"
      char *r;
#line 17073 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_canonical_lv_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_canonical_lv_name(): g is not a blessed HV reference");
    };
#line 6775 "Guestfs.xs"
      r = guestfs_lvm_canonical_lv_name (g, lvname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 17093 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lvm_clear_filter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_clear_filter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6787 "Guestfs.xs"
      int r;
#line 17117 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_clear_filter(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_clear_filter(): g is not a blessed HV reference");
    };
#line 6789 "Guestfs.xs"
      r = guestfs_lvm_clear_filter (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17134 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvm_remove_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_remove_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6797 "Guestfs.xs"
      int r;
#line 17157 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_remove_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_remove_all(): g is not a blessed HV reference");
    };
#line 6799 "Guestfs.xs"
      r = guestfs_lvm_remove_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17174 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvm_set_filter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_set_filter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, devices");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
#line 6808 "Guestfs.xs"
      int r;
#line 17198 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_set_filter(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_set_filter(): g is not a blessed HV reference");
    };
#line 6810 "Guestfs.xs"
      r = guestfs_lvm_set_filter (g, devices);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17216 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvremove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvremove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 6820 "Guestfs.xs"
      int r;
#line 17240 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvremove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvremove(): g is not a blessed HV reference");
    };
#line 6822 "Guestfs.xs"
      r = guestfs_lvremove (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17257 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvrename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvrename)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, logvol, newlogvol");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	logvol = (char *)SvPV_nolen(ST(1));
	char *	newlogvol = (char *)SvPV_nolen(ST(2));
#line 6832 "Guestfs.xs"
      int r;
#line 17282 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvrename(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvrename(): g is not a blessed HV reference");
    };
#line 6834 "Guestfs.xs"
      r = guestfs_lvrename (g, logvol, newlogvol);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17299 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvresize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvresize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, mbytes");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	mbytes = (int)SvIV(ST(2));
#line 6844 "Guestfs.xs"
      int r;
#line 17324 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvresize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvresize(): g is not a blessed HV reference");
    };
#line 6846 "Guestfs.xs"
      r = guestfs_lvresize (g, device, mbytes);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17341 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvresize_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvresize_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, lv, percent");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	lv = (char *)SvPV_nolen(ST(1));
	int	percent = (int)SvIV(ST(2));
#line 6856 "Guestfs.xs"
      int r;
#line 17366 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvresize_free(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvresize_free(): g is not a blessed HV reference");
    };
#line 6858 "Guestfs.xs"
      r = guestfs_lvresize_free (g, lv, percent);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17383 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6866 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 17407 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvs(): g is not a blessed HV reference");
    };
#line 6869 "Guestfs.xs"
      r = guestfs_lvs (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 17431 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvs_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvs_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6884 "Guestfs.xs"
      struct guestfs_lvm_lv_list *r;
      size_t i;
      HV *hv;
#line 17456 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvs_full(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvs_full(): g is not a blessed HV reference");
    };
#line 6888 "Guestfs.xs"
      r = guestfs_lvs_full (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "lv_name", 7, newSVpv (r->val[i].lv_name, 0), 0);
        (void) hv_store (hv, "lv_uuid", 7, newSVpv (r->val[i].lv_uuid, 32), 0);
        (void) hv_store (hv, "lv_attr", 7, newSVpv (r->val[i].lv_attr, 0), 0);
        (void) hv_store (hv, "lv_major", 8, my_newSVll (r->val[i].lv_major), 0);
        (void) hv_store (hv, "lv_minor", 8, my_newSVll (r->val[i].lv_minor), 0);
        (void) hv_store (hv, "lv_kernel_major", 15, my_newSVll (r->val[i].lv_kernel_major), 0);
        (void) hv_store (hv, "lv_kernel_minor", 15, my_newSVll (r->val[i].lv_kernel_minor), 0);
        (void) hv_store (hv, "lv_size", 7, my_newSVull (r->val[i].lv_size), 0);
        (void) hv_store (hv, "seg_count", 9, my_newSVll (r->val[i].seg_count), 0);
        (void) hv_store (hv, "origin", 6, newSVpv (r->val[i].origin, 0), 0);
        (void) hv_store (hv, "snap_percent", 12, newSVnv (r->val[i].snap_percent), 0);
        (void) hv_store (hv, "copy_percent", 12, newSVnv (r->val[i].copy_percent), 0);
        (void) hv_store (hv, "move_pv", 7, newSVpv (r->val[i].move_pv, 0), 0);
        (void) hv_store (hv, "lv_tags", 7, newSVpv (r->val[i].lv_tags, 0), 0);
        (void) hv_store (hv, "mirror_log", 10, newSVpv (r->val[i].mirror_log, 0), 0);
        (void) hv_store (hv, "modules", 7, newSVpv (r->val[i].modules, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_lv_list (r);
#line 17495 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvuuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvuuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 6919 "Guestfs.xs"
      char *r;
#line 17517 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvuuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvuuid(): g is not a blessed HV reference");
    };
#line 6921 "Guestfs.xs"
      r = guestfs_lvuuid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 17537 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lxattrlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lxattrlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 6935 "Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 17565 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lxattrlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lxattrlist(): g is not a blessed HV reference");
    };
#line 6939 "Guestfs.xs"
      r = guestfs_lxattrlist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 17591 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_max_disks); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_max_disks)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 6956 "Guestfs.xs"
      int r;
#line 17612 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::max_disks(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::max_disks(): g is not a blessed HV reference");
    };
#line 6958 "Guestfs.xs"
      r = guestfs_max_disks (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 17631 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_md_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, name, devices, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char **	devices = XS_unpack_charPtrPtr(ST(2));
#line 6971 "Guestfs.xs"
      int r;
      struct guestfs_md_create_argv optargs_s = { .bitmask = 0 };
      struct guestfs_md_create_argv *optargs = &optargs_s;
      size_t items_i;
#line 17660 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_create(): g is not a blessed HV reference");
    };
#line 6976 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "missingbitmap")) {
          optargs_s.missingbitmap = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_MISSINGBITMAP_BITMASK;
        }
        else if (STREQ (this_arg, "nrdevices")) {
          optargs_s.nrdevices = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_NRDEVICES_BITMASK;
        }
        else if (STREQ (this_arg, "spare")) {
          optargs_s.spare = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_SPARE_BITMASK;
        }
        else if (STREQ (this_arg, "chunk")) {
          optargs_s.chunk = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_CHUNK_BITMASK;
        }
        else if (STREQ (this_arg, "level")) {
          optargs_s.level = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_LEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_md_create_argv (g, name, devices, optargs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17712 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_md_detail); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_detail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, md");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	md = (char *)SvPV_nolen(ST(1));
#line 7020 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 17737 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_detail(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_detail(): g is not a blessed HV reference");
    };
#line 7023 "Guestfs.xs"
      r = guestfs_md_detail (g, md);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 17761 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_md_stat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_stat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, md");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	md = (char *)SvPV_nolen(ST(1));
#line 7039 "Guestfs.xs"
      struct guestfs_mdstat_list *r;
      size_t i;
      HV *hv;
#line 17787 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_stat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_stat(): g is not a blessed HV reference");
    };
#line 7043 "Guestfs.xs"
      r = guestfs_md_stat (g, md);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "mdstat_device", 13, newSVpv (r->val[i].mdstat_device, 0), 0);
        (void) hv_store (hv, "mdstat_index", 12, newSVnv (r->val[i].mdstat_index), 0);
        (void) hv_store (hv, "mdstat_flags", 12, newSVpv (r->val[i].mdstat_flags, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_mdstat_list (r);
#line 17813 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_md_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_stop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, md");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	md = (char *)SvPV_nolen(ST(1));
#line 7061 "Guestfs.xs"
      int r;
#line 17837 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_stop(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_stop(): g is not a blessed HV reference");
    };
#line 7063 "Guestfs.xs"
      r = guestfs_md_stop (g, md);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17854 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 7072 "Guestfs.xs"
      int r;
#line 17878 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdir(): g is not a blessed HV reference");
    };
#line 7074 "Guestfs.xs"
      r = guestfs_mkdir (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17895 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdir_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdir_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, mode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	mode = (int)SvIV(ST(2));
#line 7084 "Guestfs.xs"
      int r;
#line 17920 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdir_mode(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdir_mode(): g is not a blessed HV reference");
    };
#line 7086 "Guestfs.xs"
      r = guestfs_mkdir_mode (g, path, mode);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17937 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdir_p); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdir_p)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 7095 "Guestfs.xs"
      int r;
#line 17961 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdir_p(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdir_p(): g is not a blessed HV reference");
    };
#line 7097 "Guestfs.xs"
      r = guestfs_mkdir_p (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17978 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdtemp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdtemp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, tmpl");
    {
	guestfs_h *	g;
	char *	tmpl = (char *)SvPV_nolen(ST(1));
#line 7106 "Guestfs.xs"
      char *r;
#line 18000 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdtemp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdtemp(): g is not a blessed HV reference");
    };
#line 7108 "Guestfs.xs"
      r = guestfs_mkdtemp (g, tmpl);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 18020 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_mke2fs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 7121 "Guestfs.xs"
      int r;
      struct guestfs_mke2fs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mke2fs_argv *optargs = &optargs_s;
      size_t items_i;
#line 18048 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs(): g is not a blessed HV reference");
    };
#line 7126 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "blockscount")) {
          optargs_s.blockscount = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BLOCKSCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "blocksize")) {
          optargs_s.blocksize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BLOCKSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "fragsize")) {
          optargs_s.fragsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FRAGSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "blockspergroup")) {
          optargs_s.blockspergroup = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BLOCKSPERGROUP_BITMASK;
        }
        else if (STREQ (this_arg, "numberofgroups")) {
          optargs_s.numberofgroups = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_NUMBEROFGROUPS_BITMASK;
        }
        else if (STREQ (this_arg, "bytesperinode")) {
          optargs_s.bytesperinode = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BYTESPERINODE_BITMASK;
        }
        else if (STREQ (this_arg, "inodesize")) {
          optargs_s.inodesize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_INODESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "journalsize")) {
          optargs_s.journalsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_JOURNALSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "numberofinodes")) {
          optargs_s.numberofinodes = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_NUMBEROFINODES_BITMASK;
        }
        else if (STREQ (this_arg, "stridesize")) {
          optargs_s.stridesize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_STRIDESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "stripewidth")) {
          optargs_s.stripewidth = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_STRIPEWIDTH_BITMASK;
        }
        else if (STREQ (this_arg, "maxonlineresize")) {
          optargs_s.maxonlineresize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_MAXONLINERESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "reservedblockspercentage")) {
          optargs_s.reservedblockspercentage = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_RESERVEDBLOCKSPERCENTAGE_BITMASK;
        }
        else if (STREQ (this_arg, "mmpupdateinterval")) {
          optargs_s.mmpupdateinterval = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_MMPUPDATEINTERVAL_BITMASK;
        }
        else if (STREQ (this_arg, "journaldevice")) {
          optargs_s.journaldevice = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_JOURNALDEVICE_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "lastmounteddir")) {
          optargs_s.lastmounteddir = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LASTMOUNTEDDIR_BITMASK;
        }
        else if (STREQ (this_arg, "creatoros")) {
          optargs_s.creatoros = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_CREATOROS_BITMASK;
        }
        else if (STREQ (this_arg, "fstype")) {
          optargs_s.fstype = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FSTYPE_BITMASK;
        }
        else if (STREQ (this_arg, "usagetype")) {
          optargs_s.usagetype = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_USAGETYPE_BITMASK;
        }
        else if (STREQ (this_arg, "uuid")) {
          optargs_s.uuid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_UUID_BITMASK;
        }
        else if (STREQ (this_arg, "forcecreate")) {
          optargs_s.forcecreate = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FORCECREATE_BITMASK;
        }
        else if (STREQ (this_arg, "writesbandgrouponly")) {
          optargs_s.writesbandgrouponly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_WRITESBANDGROUPONLY_BITMASK;
        }
        else if (STREQ (this_arg, "lazyitableinit")) {
          optargs_s.lazyitableinit = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LAZYITABLEINIT_BITMASK;
        }
        else if (STREQ (this_arg, "lazyjournalinit")) {
          optargs_s.lazyjournalinit = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LAZYJOURNALINIT_BITMASK;
        }
        else if (STREQ (this_arg, "testfs")) {
          optargs_s.testfs = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_TESTFS_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "quotatype")) {
          optargs_s.quotatype = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_QUOTATYPE_BITMASK;
        }
        else if (STREQ (this_arg, "extent")) {
          optargs_s.extent = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_EXTENT_BITMASK;
        }
        else if (STREQ (this_arg, "filetype")) {
          optargs_s.filetype = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FILETYPE_BITMASK;
        }
        else if (STREQ (this_arg, "flexbg")) {
          optargs_s.flexbg = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FLEXBG_BITMASK;
        }
        else if (STREQ (this_arg, "hasjournal")) {
          optargs_s.hasjournal = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_HASJOURNAL_BITMASK;
        }
        else if (STREQ (this_arg, "journaldev")) {
          optargs_s.journaldev = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_JOURNALDEV_BITMASK;
        }
        else if (STREQ (this_arg, "largefile")) {
          optargs_s.largefile = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LARGEFILE_BITMASK;
        }
        else if (STREQ (this_arg, "quota")) {
          optargs_s.quota = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_QUOTA_BITMASK;
        }
        else if (STREQ (this_arg, "resizeinode")) {
          optargs_s.resizeinode = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_RESIZEINODE_BITMASK;
        }
        else if (STREQ (this_arg, "sparsesuper")) {
          optargs_s.sparsesuper = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_SPARSESUPER_BITMASK;
        }
        else if (STREQ (this_arg, "uninitbg")) {
          optargs_s.uninitbg = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_UNINITBG_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mke2fs_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18231 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2fs_J); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs_J)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, fstype, blocksize, device, journal");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
	char *	journal = (char *)SvPV_nolen(ST(4));
#line 7304 "Guestfs.xs"
      int r;
#line 18258 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs_J(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs_J(): g is not a blessed HV reference");
    };
#line 7306 "Guestfs.xs"
      r = guestfs_mke2fs_J (g, fstype, blocksize, device, journal);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18275 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2fs_JL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs_JL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, fstype, blocksize, device, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
	char *	label = (char *)SvPV_nolen(ST(4));
#line 7318 "Guestfs.xs"
      int r;
#line 18302 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs_JL(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs_JL(): g is not a blessed HV reference");
    };
#line 7320 "Guestfs.xs"
      r = guestfs_mke2fs_JL (g, fstype, blocksize, device, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18319 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2fs_JU); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs_JU)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, fstype, blocksize, device, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
	char *	uuid = (char *)SvPV_nolen(ST(4));
#line 7332 "Guestfs.xs"
      int r;
#line 18346 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs_JU(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs_JU(): g is not a blessed HV reference");
    };
#line 7334 "Guestfs.xs"
      r = guestfs_mke2fs_JU (g, fstype, blocksize, device, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18363 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2journal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2journal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, blocksize, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	blocksize = (int)SvIV(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7344 "Guestfs.xs"
      int r;
#line 18388 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2journal(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2journal(): g is not a blessed HV reference");
    };
#line 7346 "Guestfs.xs"
      r = guestfs_mke2journal (g, blocksize, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18405 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2journal_L); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2journal_L)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, blocksize, label, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	blocksize = (int)SvIV(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
#line 7357 "Guestfs.xs"
      int r;
#line 18431 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2journal_L(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2journal_L(): g is not a blessed HV reference");
    };
#line 7359 "Guestfs.xs"
      r = guestfs_mke2journal_L (g, blocksize, label, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18448 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2journal_U); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2journal_U)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, blocksize, uuid, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	blocksize = (int)SvIV(ST(1));
	char *	uuid = (char *)SvPV_nolen(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
#line 7370 "Guestfs.xs"
      int r;
#line 18474 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2journal_U(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2journal_U(): g is not a blessed HV reference");
    };
#line 7372 "Guestfs.xs"
      r = guestfs_mke2journal_U (g, blocksize, uuid, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18491 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfifo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfifo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mode, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 7382 "Guestfs.xs"
      int r;
#line 18516 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfifo(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfifo(): g is not a blessed HV reference");
    };
#line 7384 "Guestfs.xs"
      r = guestfs_mkfifo (g, mode, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18533 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, fstype, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7394 "Guestfs.xs"
      int r;
      struct guestfs_mkfs_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mkfs_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 18561 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfs(): g is not a blessed HV reference");
    };
#line 7399 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "blocksize")) {
          optargs_s.blocksize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_BLOCKSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "features")) {
          optargs_s.features = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_FEATURES_BITMASK;
        }
        else if (STREQ (this_arg, "inode")) {
          optargs_s.inode = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_INODE_BITMASK;
        }
        else if (STREQ (this_arg, "sectorsize")) {
          optargs_s.sectorsize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_SECTORSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_LABEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mkfs_opts_argv (g, fstype, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18612 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfs_b); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfs_b)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, fstype, blocksize, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
#line 7444 "Guestfs.xs"
      int r;
#line 18638 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfs_b(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfs_b(): g is not a blessed HV reference");
    };
#line 7446 "Guestfs.xs"
      r = guestfs_mkfs_b (g, fstype, blocksize, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18655 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfs_btrfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfs_btrfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, devices, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
#line 7455 "Guestfs.xs"
      int r;
      struct guestfs_mkfs_btrfs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mkfs_btrfs_argv *optargs = &optargs_s;
      size_t items_i;
#line 18682 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfs_btrfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfs_btrfs(): g is not a blessed HV reference");
    };
#line 7460 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "allocstart")) {
          optargs_s.allocstart = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_ALLOCSTART_BITMASK;
        }
        else if (STREQ (this_arg, "bytecount")) {
          optargs_s.bytecount = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_BYTECOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "datatype")) {
          optargs_s.datatype = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_DATATYPE_BITMASK;
        }
        else if (STREQ (this_arg, "leafsize")) {
          optargs_s.leafsize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_LEAFSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "metadata")) {
          optargs_s.metadata = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_METADATA_BITMASK;
        }
        else if (STREQ (this_arg, "nodesize")) {
          optargs_s.nodesize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_NODESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sectorsize")) {
          optargs_s.sectorsize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_SECTORSIZE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mkfs_btrfs_argv (g, devices, optargs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18746 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mklost_and_found); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mklost_and_found)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 7516 "Guestfs.xs"
      int r;
#line 18770 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mklost_and_found(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mklost_and_found(): g is not a blessed HV reference");
    };
#line 7518 "Guestfs.xs"
      r = guestfs_mklost_and_found (g, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18787 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkmountpoint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkmountpoint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, exemptpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	exemptpath = (char *)SvPV_nolen(ST(1));
#line 7527 "Guestfs.xs"
      int r;
#line 18811 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkmountpoint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkmountpoint(): g is not a blessed HV reference");
    };
#line 7529 "Guestfs.xs"
      r = guestfs_mkmountpoint (g, exemptpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18828 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mknod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mknod)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, mode, devmajor, devminor, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	int	devmajor = (int)SvIV(ST(2));
	int	devminor = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 7541 "Guestfs.xs"
      int r;
#line 18855 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mknod(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mknod(): g is not a blessed HV reference");
    };
#line 7543 "Guestfs.xs"
      r = guestfs_mknod (g, mode, devmajor, devminor, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18872 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mknod_b); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mknod_b)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, mode, devmajor, devminor, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	int	devmajor = (int)SvIV(ST(2));
	int	devminor = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 7555 "Guestfs.xs"
      int r;
#line 18899 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mknod_b(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mknod_b(): g is not a blessed HV reference");
    };
#line 7557 "Guestfs.xs"
      r = guestfs_mknod_b (g, mode, devmajor, devminor, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18916 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mknod_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mknod_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, mode, devmajor, devminor, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	int	devmajor = (int)SvIV(ST(2));
	int	devminor = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 7569 "Guestfs.xs"
      int r;
#line 18943 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mknod_c(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mknod_c(): g is not a blessed HV reference");
    };
#line 7571 "Guestfs.xs"
      r = guestfs_mknod_c (g, mode, devmajor, devminor, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18960 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 7580 "Guestfs.xs"
      int r;
      struct guestfs_mkswap_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mkswap_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 18987 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap(): g is not a blessed HV reference");
    };
#line 7585 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKSWAP_OPTS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "uuid")) {
          optargs_s.uuid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKSWAP_OPTS_UUID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mkswap_opts_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19026 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap_L); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap_L)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, label, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7617 "Guestfs.xs"
      int r;
#line 19051 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap_L(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap_L(): g is not a blessed HV reference");
    };
#line 7619 "Guestfs.xs"
      r = guestfs_mkswap_L (g, label, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19068 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap_U); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap_U)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, uuid, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7629 "Guestfs.xs"
      int r;
#line 19093 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap_U(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap_U(): g is not a blessed HV reference");
    };
#line 7631 "Guestfs.xs"
      r = guestfs_mkswap_U (g, uuid, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19110 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 7640 "Guestfs.xs"
      int r;
#line 19134 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap_file(): g is not a blessed HV reference");
    };
#line 7642 "Guestfs.xs"
      r = guestfs_mkswap_file (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19151 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mktemp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mktemp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, tmpl, ...");
    {
	guestfs_h *	g;
	char *	tmpl = (char *)SvPV_nolen(ST(1));
#line 7651 "Guestfs.xs"
      char *r;
      struct guestfs_mktemp_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mktemp_argv *optargs = &optargs_s;
      size_t items_i;
#line 19176 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mktemp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mktemp(): g is not a blessed HV reference");
    };
#line 7656 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "suffix")) {
          optargs_s.suffix = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKTEMP_SUFFIX_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mktemp_argv (g, tmpl, optargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 19214 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_modprobe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_modprobe)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, modulename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	modulename = (char *)SvPV_nolen(ST(1));
#line 7687 "Guestfs.xs"
      int r;
#line 19239 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::modprobe(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::modprobe(): g is not a blessed HV reference");
    };
#line 7689 "Guestfs.xs"
      r = guestfs_modprobe (g, modulename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19256 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7699 "Guestfs.xs"
      int r;
#line 19281 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount(): g is not a blessed HV reference");
    };
#line 7701 "Guestfs.xs"
      r = guestfs_mount (g, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19298 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_9p); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_9p)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, mounttag, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mounttag = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7711 "Guestfs.xs"
      int r;
      struct guestfs_mount_9p_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mount_9p_argv *optargs = &optargs_s;
      size_t items_i;
#line 19326 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_9p(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_9p(): g is not a blessed HV reference");
    };
#line 7716 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "options")) {
          optargs_s.options = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_9P_OPTIONS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mount_9p_argv (g, mounttag, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19361 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_local); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_local)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, localmountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	localmountpoint = (char *)SvPV_nolen(ST(1));
#line 7743 "Guestfs.xs"
      int r;
      struct guestfs_mount_local_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mount_local_argv *optargs = &optargs_s;
      size_t items_i;
#line 19388 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_local(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_local(): g is not a blessed HV reference");
    };
#line 7748 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "options")) {
          optargs_s.options = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_OPTIONS_BITMASK;
        }
        else if (STREQ (this_arg, "cachetimeout")) {
          optargs_s.cachetimeout = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_CACHETIMEOUT_BITMASK;
        }
        else if (STREQ (this_arg, "debugcalls")) {
          optargs_s.debugcalls = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_DEBUGCALLS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mount_local_argv (g, localmountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19435 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_local_run); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_local_run)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 7786 "Guestfs.xs"
      int r;
#line 19458 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_local_run(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_local_run(): g is not a blessed HV reference");
    };
#line 7788 "Guestfs.xs"
      r = guestfs_mount_local_run (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19475 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_loop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_loop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, file, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7798 "Guestfs.xs"
      int r;
#line 19500 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_loop(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_loop(): g is not a blessed HV reference");
    };
#line 7800 "Guestfs.xs"
      r = guestfs_mount_loop (g, file, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19517 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_options); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_options)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, options, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	options = (char *)SvPV_nolen(ST(1));
	char *	mountable = (char *)SvPV_nolen(ST(2));
	char *	mountpoint = (char *)SvPV_nolen(ST(3));
#line 7811 "Guestfs.xs"
      int r;
#line 19543 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_options(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_options(): g is not a blessed HV reference");
    };
#line 7813 "Guestfs.xs"
      r = guestfs_mount_options (g, options, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19560 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_ro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_ro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7823 "Guestfs.xs"
      int r;
#line 19585 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_ro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_ro(): g is not a blessed HV reference");
    };
#line 7825 "Guestfs.xs"
      r = guestfs_mount_ro (g, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19602 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_vfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_vfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, options, vfstype, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	options = (char *)SvPV_nolen(ST(1));
	char *	vfstype = (char *)SvPV_nolen(ST(2));
	char *	mountable = (char *)SvPV_nolen(ST(3));
	char *	mountpoint = (char *)SvPV_nolen(ST(4));
#line 7837 "Guestfs.xs"
      int r;
#line 19629 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_vfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_vfs(): g is not a blessed HV reference");
    };
#line 7839 "Guestfs.xs"
      r = guestfs_mount_vfs (g, options, vfstype, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19646 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mountpoints); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mountpoints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 7847 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 19670 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mountpoints(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mountpoints(): g is not a blessed HV reference");
    };
#line 7850 "Guestfs.xs"
      r = guestfs_mountpoints (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 19694 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mounts); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mounts)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 7865 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 19718 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mounts(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mounts(): g is not a blessed HV reference");
    };
#line 7868 "Guestfs.xs"
      r = guestfs_mounts (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 19742 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 7885 "Guestfs.xs"
      int r;
#line 19767 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mv(): g is not a blessed HV reference");
    };
#line 7887 "Guestfs.xs"
      r = guestfs_mv (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19784 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_nr_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_nr_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 7895 "Guestfs.xs"
      int r;
#line 19805 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::nr_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::nr_devices(): g is not a blessed HV reference");
    };
#line 7897 "Guestfs.xs"
      r = guestfs_nr_devices (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 19824 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ntfs_3g_probe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfs_3g_probe)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, rw, device");
    {
	guestfs_h *	g;
	int	rw = (int)SvIV(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7910 "Guestfs.xs"
      int r;
#line 19848 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfs_3g_probe(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfs_3g_probe(): g is not a blessed HV reference");
    };
#line 7912 "Guestfs.xs"
      r = guestfs_ntfs_3g_probe (g, rw, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 19867 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ntfsclone_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsclone_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, backupfile, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	backupfile = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7925 "Guestfs.xs"
      int r;
#line 19893 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsclone_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsclone_in(): g is not a blessed HV reference");
    };
#line 7927 "Guestfs.xs"
      r = guestfs_ntfsclone_in (g, backupfile, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19910 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsclone_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsclone_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, device, backupfile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	backupfile = (char *)SvPV_nolen(ST(2));
#line 7937 "Guestfs.xs"
      int r;
      struct guestfs_ntfsclone_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_ntfsclone_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 19938 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsclone_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsclone_out(): g is not a blessed HV reference");
    };
#line 7942 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "metadataonly")) {
          optargs_s.metadataonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_METADATAONLY_BITMASK;
        }
        else if (STREQ (this_arg, "rescue")) {
          optargs_s.rescue = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_RESCUE_BITMASK;
        }
        else if (STREQ (this_arg, "ignorefscheck")) {
          optargs_s.ignorefscheck = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_IGNOREFSCHECK_BITMASK;
        }
        else if (STREQ (this_arg, "preservetimestamps")) {
          optargs_s.preservetimestamps = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_PRESERVETIMESTAMPS_BITMASK;
        }
        else if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_FORCE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_ntfsclone_out_argv (g, device, backupfile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19989 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsfix); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsfix)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 7985 "Guestfs.xs"
      int r;
      struct guestfs_ntfsfix_argv optargs_s = { .bitmask = 0 };
      struct guestfs_ntfsfix_argv *optargs = &optargs_s;
      size_t items_i;
#line 20016 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsfix(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsfix(): g is not a blessed HV reference");
    };
#line 7990 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "clearbadsectors")) {
          optargs_s.clearbadsectors = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSFIX_CLEARBADSECTORS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_ntfsfix_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20051 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsresize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsresize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8017 "Guestfs.xs"
      int r;
      struct guestfs_ntfsresize_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_ntfsresize_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 20078 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsresize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsresize(): g is not a blessed HV reference");
    };
#line 8022 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_NTFSRESIZE_OPTS_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSRESIZE_OPTS_FORCE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_ntfsresize_opts_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20117 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsresize_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsresize_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 8054 "Guestfs.xs"
      int r;
#line 20142 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsresize_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsresize_size(): g is not a blessed HV reference");
    };
#line 8056 "Guestfs.xs"
      r = guestfs_ntfsresize_size (g, device, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20159 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_parse_environment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_parse_environment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8064 "Guestfs.xs"
      int r;
#line 20182 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::parse_environment(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::parse_environment(): g is not a blessed HV reference");
    };
#line 8066 "Guestfs.xs"
      r = guestfs_parse_environment (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20199 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_parse_environment_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_parse_environment_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, environment");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	environment = XS_unpack_charPtrPtr(ST(1));
#line 8075 "Guestfs.xs"
      int r;
#line 20223 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::parse_environment_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::parse_environment_list(): g is not a blessed HV reference");
    };
#line 8077 "Guestfs.xs"
      r = guestfs_parse_environment_list (g, environment);
      free (environment);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20241 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, device, prlogex, startsect, endsect");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	prlogex = (char *)SvPV_nolen(ST(2));
	int64_t    startsect = my_SvIV64 (ST(3));
	int64_t    endsect = my_SvIV64 (ST(4));
#line 8090 "Guestfs.xs"
      int r;
#line 20268 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_add(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_add(): g is not a blessed HV reference");
    };
#line 8092 "Guestfs.xs"
      r = guestfs_part_add (g, device, prlogex, startsect, endsect);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20285 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_del); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_del)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8102 "Guestfs.xs"
      int r;
#line 20310 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_del(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_del(): g is not a blessed HV reference");
    };
#line 8104 "Guestfs.xs"
      r = guestfs_part_del (g, device, partnum);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20327 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_disk); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_disk)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, parttype");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	parttype = (char *)SvPV_nolen(ST(2));
#line 8114 "Guestfs.xs"
      int r;
#line 20352 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_disk(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_disk(): g is not a blessed HV reference");
    };
#line 8116 "Guestfs.xs"
      r = guestfs_part_disk (g, device, parttype);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20369 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_get_bootable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_bootable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8126 "Guestfs.xs"
      int r;
#line 20392 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_bootable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_bootable(): g is not a blessed HV reference");
    };
#line 8128 "Guestfs.xs"
      r = guestfs_part_get_bootable (g, device, partnum);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 20411 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_gpt_guid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_gpt_guid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8141 "Guestfs.xs"
      char *r;
#line 20435 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_gpt_guid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_gpt_guid(): g is not a blessed HV reference");
    };
#line 8143 "Guestfs.xs"
      r = guestfs_part_get_gpt_guid (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20455 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_gpt_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_gpt_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8157 "Guestfs.xs"
      char *r;
#line 20479 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_gpt_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_gpt_type(): g is not a blessed HV reference");
    };
#line 8159 "Guestfs.xs"
      r = guestfs_part_get_gpt_type (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20499 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_mbr_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_mbr_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8173 "Guestfs.xs"
      int r;
#line 20523 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_mbr_id(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_mbr_id(): g is not a blessed HV reference");
    };
#line 8175 "Guestfs.xs"
      r = guestfs_part_get_mbr_id (g, device, partnum);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 20542 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_mbr_part_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_mbr_part_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8188 "Guestfs.xs"
      char *r;
#line 20566 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_mbr_part_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_mbr_part_type(): g is not a blessed HV reference");
    };
#line 8190 "Guestfs.xs"
      r = guestfs_part_get_mbr_part_type (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20586 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8204 "Guestfs.xs"
      char *r;
#line 20610 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_name(): g is not a blessed HV reference");
    };
#line 8206 "Guestfs.xs"
      r = guestfs_part_get_name (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20630 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_parttype); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_parttype)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8219 "Guestfs.xs"
      char *r;
#line 20653 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_parttype(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_parttype(): g is not a blessed HV reference");
    };
#line 8221 "Guestfs.xs"
      r = guestfs_part_get_parttype (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20673 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, parttype");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	parttype = (char *)SvPV_nolen(ST(2));
#line 8235 "Guestfs.xs"
      int r;
#line 20699 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_init(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_init(): g is not a blessed HV reference");
    };
#line 8237 "Guestfs.xs"
      r = guestfs_part_init (g, device, parttype);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20716 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8246 "Guestfs.xs"
      struct guestfs_partition_list *r;
      size_t i;
      HV *hv;
#line 20742 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_list(): g is not a blessed HV reference");
    };
#line 8250 "Guestfs.xs"
      r = guestfs_part_list (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "part_num", 8, newSVnv (r->val[i].part_num), 0);
        (void) hv_store (hv, "part_start", 10, my_newSVull (r->val[i].part_start), 0);
        (void) hv_store (hv, "part_end", 8, my_newSVull (r->val[i].part_end), 0);
        (void) hv_store (hv, "part_size", 9, my_newSVull (r->val[i].part_size), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_partition_list (r);
#line 20769 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_bootable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_bootable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, bootable");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	int	bootable = (int)SvIV(ST(3));
#line 8271 "Guestfs.xs"
      int r;
#line 20795 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_bootable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_bootable(): g is not a blessed HV reference");
    };
#line 8273 "Guestfs.xs"
      r = guestfs_part_set_bootable (g, device, partnum, bootable);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20812 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_gpt_guid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_gpt_guid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, guid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	char *	guid = (char *)SvPV_nolen(ST(3));
#line 8284 "Guestfs.xs"
      int r;
#line 20838 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_gpt_guid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_gpt_guid(): g is not a blessed HV reference");
    };
#line 8286 "Guestfs.xs"
      r = guestfs_part_set_gpt_guid (g, device, partnum, guid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20855 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_gpt_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_gpt_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, guid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	char *	guid = (char *)SvPV_nolen(ST(3));
#line 8297 "Guestfs.xs"
      int r;
#line 20881 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_gpt_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_gpt_type(): g is not a blessed HV reference");
    };
#line 8299 "Guestfs.xs"
      r = guestfs_part_set_gpt_type (g, device, partnum, guid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20898 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_mbr_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_mbr_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, idbyte");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	int	idbyte = (int)SvIV(ST(3));
#line 8310 "Guestfs.xs"
      int r;
#line 20924 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_mbr_id(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_mbr_id(): g is not a blessed HV reference");
    };
#line 8312 "Guestfs.xs"
      r = guestfs_part_set_mbr_id (g, device, partnum, idbyte);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20941 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	char *	name = (char *)SvPV_nolen(ST(3));
#line 8323 "Guestfs.xs"
      int r;
#line 20967 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_name(): g is not a blessed HV reference");
    };
#line 8325 "Guestfs.xs"
      r = guestfs_part_set_name (g, device, partnum, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20984 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_to_dev); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_to_dev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, partition");
    {
	guestfs_h *	g;
	char *	partition = (char *)SvPV_nolen(ST(1));
#line 8334 "Guestfs.xs"
      char *r;
#line 21006 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_to_dev(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_to_dev(): g is not a blessed HV reference");
    };
#line 8336 "Guestfs.xs"
      r = guestfs_part_to_dev (g, partition);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21026 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_to_partnum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_to_partnum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, partition");
    {
	guestfs_h *	g;
	char *	partition = (char *)SvPV_nolen(ST(1));
#line 8349 "Guestfs.xs"
      int r;
#line 21049 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_to_partnum(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_to_partnum(): g is not a blessed HV reference");
    };
#line 8351 "Guestfs.xs"
      r = guestfs_part_to_partnum (g, partition);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 21068 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ping_daemon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ping_daemon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8362 "Guestfs.xs"
      int r;
#line 21092 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ping_daemon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ping_daemon(): g is not a blessed HV reference");
    };
#line 8364 "Guestfs.xs"
      r = guestfs_ping_daemon (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21109 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pread); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pread)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, count, offset");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	count = (int)SvIV(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8375 "Guestfs.xs"
      char *r;
      size_t size;
#line 21134 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pread(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pread(): g is not a blessed HV reference");
    };
#line 8378 "Guestfs.xs"
      r = guestfs_pread (g, path, count, offset, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 21154 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pread_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pread_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, count, offset");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	count = (int)SvIV(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8393 "Guestfs.xs"
      char *r;
      size_t size;
#line 21180 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pread_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pread_device(): g is not a blessed HV reference");
    };
#line 8396 "Guestfs.xs"
      r = guestfs_pread_device (g, device, count, offset, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 21200 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pvchange_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvchange_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8409 "Guestfs.xs"
      int r;
#line 21225 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvchange_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvchange_uuid(): g is not a blessed HV reference");
    };
#line 8411 "Guestfs.xs"
      r = guestfs_pvchange_uuid (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21242 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvchange_uuid_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvchange_uuid_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8419 "Guestfs.xs"
      int r;
#line 21265 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvchange_uuid_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvchange_uuid_all(): g is not a blessed HV reference");
    };
#line 8421 "Guestfs.xs"
      r = guestfs_pvchange_uuid_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21282 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvcreate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvcreate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8430 "Guestfs.xs"
      int r;
#line 21306 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvcreate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvcreate(): g is not a blessed HV reference");
    };
#line 8432 "Guestfs.xs"
      r = guestfs_pvcreate (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21323 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvremove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvremove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8441 "Guestfs.xs"
      int r;
#line 21347 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvremove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvremove(): g is not a blessed HV reference");
    };
#line 8443 "Guestfs.xs"
      r = guestfs_pvremove (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21364 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvresize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvresize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8452 "Guestfs.xs"
      int r;
#line 21388 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvresize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvresize(): g is not a blessed HV reference");
    };
#line 8454 "Guestfs.xs"
      r = guestfs_pvresize (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21405 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvresize_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvresize_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 8464 "Guestfs.xs"
      int r;
#line 21430 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvresize_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvresize_size(): g is not a blessed HV reference");
    };
#line 8466 "Guestfs.xs"
      r = guestfs_pvresize_size (g, device, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21447 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8474 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 21471 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvs(): g is not a blessed HV reference");
    };
#line 8477 "Guestfs.xs"
      r = guestfs_pvs (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 21495 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvs_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvs_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8492 "Guestfs.xs"
      struct guestfs_lvm_pv_list *r;
      size_t i;
      HV *hv;
#line 21520 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvs_full(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvs_full(): g is not a blessed HV reference");
    };
#line 8496 "Guestfs.xs"
      r = guestfs_pvs_full (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "pv_name", 7, newSVpv (r->val[i].pv_name, 0), 0);
        (void) hv_store (hv, "pv_uuid", 7, newSVpv (r->val[i].pv_uuid, 32), 0);
        (void) hv_store (hv, "pv_fmt", 6, newSVpv (r->val[i].pv_fmt, 0), 0);
        (void) hv_store (hv, "pv_size", 7, my_newSVull (r->val[i].pv_size), 0);
        (void) hv_store (hv, "dev_size", 8, my_newSVull (r->val[i].dev_size), 0);
        (void) hv_store (hv, "pv_free", 7, my_newSVull (r->val[i].pv_free), 0);
        (void) hv_store (hv, "pv_used", 7, my_newSVull (r->val[i].pv_used), 0);
        (void) hv_store (hv, "pv_attr", 7, newSVpv (r->val[i].pv_attr, 0), 0);
        (void) hv_store (hv, "pv_pe_count", 11, my_newSVll (r->val[i].pv_pe_count), 0);
        (void) hv_store (hv, "pv_pe_alloc_count", 17, my_newSVll (r->val[i].pv_pe_alloc_count), 0);
        (void) hv_store (hv, "pv_tags", 7, newSVpv (r->val[i].pv_tags, 0), 0);
        (void) hv_store (hv, "pe_start", 8, my_newSVull (r->val[i].pe_start), 0);
        (void) hv_store (hv, "pv_mda_count", 12, my_newSVll (r->val[i].pv_mda_count), 0);
        (void) hv_store (hv, "pv_mda_free", 11, my_newSVull (r->val[i].pv_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_pv_list (r);
#line 21557 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvuuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvuuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8525 "Guestfs.xs"
      char *r;
#line 21579 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvuuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvuuid(): g is not a blessed HV reference");
    };
#line 8527 "Guestfs.xs"
      r = guestfs_pvuuid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21599 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pwrite); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pwrite)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, content, offset");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8543 "Guestfs.xs"
      int r;
#line 21625 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pwrite(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pwrite(): g is not a blessed HV reference");
    };
#line 8545 "Guestfs.xs"
      r = guestfs_pwrite (g, path, content, content_size, offset);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 21644 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pwrite_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pwrite_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, content, offset");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8560 "Guestfs.xs"
      int r;
#line 21670 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pwrite_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pwrite_device(): g is not a blessed HV reference");
    };
#line 8562 "Guestfs.xs"
      r = guestfs_pwrite_device (g, device, content, content_size, offset);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 21689 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_read_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_read_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8574 "Guestfs.xs"
      char *r;
      size_t size;
#line 21713 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::read_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::read_file(): g is not a blessed HV reference");
    };
#line 8577 "Guestfs.xs"
      r = guestfs_read_file (g, path, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 21733 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_read_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_read_lines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8590 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 21759 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::read_lines(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::read_lines(): g is not a blessed HV reference");
    };
#line 8593 "Guestfs.xs"
      r = guestfs_read_lines (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 21783 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_readdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_readdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
#line 8609 "Guestfs.xs"
      struct guestfs_dirent_list *r;
      size_t i;
      HV *hv;
#line 21809 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::readdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::readdir(): g is not a blessed HV reference");
    };
#line 8613 "Guestfs.xs"
      r = guestfs_readdir (g, dir);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "ino", 3, my_newSVll (r->val[i].ino), 0);
        (void) hv_store (hv, "ftyp", 4, newSVpv (&r->val[i].ftyp, 1), 0);
        (void) hv_store (hv, "name", 4, newSVpv (r->val[i].name, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_dirent_list (r);
#line 21835 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_readlink); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_readlink)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8631 "Guestfs.xs"
      char *r;
#line 21857 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::readlink(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::readlink(): g is not a blessed HV reference");
    };
#line 8633 "Guestfs.xs"
      r = guestfs_readlink (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21877 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_readlinklist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_readlinklist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 8647 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 21904 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::readlinklist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::readlinklist(): g is not a blessed HV reference");
    };
#line 8650 "Guestfs.xs"
      r = guestfs_readlinklist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 21929 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_realpath); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_realpath)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8667 "Guestfs.xs"
      char *r;
#line 21951 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::realpath(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::realpath(): g is not a blessed HV reference");
    };
#line 8669 "Guestfs.xs"
      r = guestfs_realpath (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21971 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_remount); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_remount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 8682 "Guestfs.xs"
      int r;
      struct guestfs_remount_argv optargs_s = { .bitmask = 0 };
      struct guestfs_remount_argv *optargs = &optargs_s;
      size_t items_i;
#line 21999 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::remount(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::remount(): g is not a blessed HV reference");
    };
#line 8687 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "rw")) {
          optargs_s.rw = SvIV (ST (items_i+1));
          this_mask = GUESTFS_REMOUNT_RW_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_remount_argv (g, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22034 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_remove_drive); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_remove_drive)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 8714 "Guestfs.xs"
      int r;
#line 22058 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::remove_drive(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::remove_drive(): g is not a blessed HV reference");
    };
#line 8716 "Guestfs.xs"
      r = guestfs_remove_drive (g, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22075 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_removexattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_removexattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, xattr, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 8726 "Guestfs.xs"
      int r;
#line 22100 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::removexattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::removexattr(): g is not a blessed HV reference");
    };
#line 8728 "Guestfs.xs"
      r = guestfs_removexattr (g, xattr, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22117 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rename)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, oldpath, newpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	oldpath = (char *)SvPV_nolen(ST(1));
	char *	newpath = (char *)SvPV_nolen(ST(2));
#line 8738 "Guestfs.xs"
      int r;
#line 22142 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rename(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rename(): g is not a blessed HV reference");
    };
#line 8740 "Guestfs.xs"
      r = guestfs_rename (g, oldpath, newpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22159 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_resize2fs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_resize2fs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8749 "Guestfs.xs"
      int r;
#line 22183 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::resize2fs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::resize2fs(): g is not a blessed HV reference");
    };
#line 8751 "Guestfs.xs"
      r = guestfs_resize2fs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22200 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_resize2fs_M); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_resize2fs_M)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8760 "Guestfs.xs"
      int r;
#line 22224 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::resize2fs_M(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::resize2fs_M(): g is not a blessed HV reference");
    };
#line 8762 "Guestfs.xs"
      r = guestfs_resize2fs_M (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22241 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_resize2fs_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_resize2fs_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 8772 "Guestfs.xs"
      int r;
#line 22266 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::resize2fs_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::resize2fs_size(): g is not a blessed HV reference");
    };
#line 8774 "Guestfs.xs"
      r = guestfs_resize2fs_size (g, device, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22283 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8783 "Guestfs.xs"
      int r;
#line 22307 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rm(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rm(): g is not a blessed HV reference");
    };
#line 8785 "Guestfs.xs"
      r = guestfs_rm (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22324 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rm_f); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rm_f)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8794 "Guestfs.xs"
      int r;
#line 22348 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rm_f(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rm_f(): g is not a blessed HV reference");
    };
#line 8796 "Guestfs.xs"
      r = guestfs_rm_f (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22365 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rm_rf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rm_rf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8805 "Guestfs.xs"
      int r;
#line 22389 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rm_rf(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rm_rf(): g is not a blessed HV reference");
    };
#line 8807 "Guestfs.xs"
      r = guestfs_rm_rf (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22406 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rmdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rmdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8816 "Guestfs.xs"
      int r;
#line 22430 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rmdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rmdir(): g is not a blessed HV reference");
    };
#line 8818 "Guestfs.xs"
      r = guestfs_rmdir (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22447 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rmmountpoint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rmmountpoint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, exemptpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	exemptpath = (char *)SvPV_nolen(ST(1));
#line 8827 "Guestfs.xs"
      int r;
#line 22471 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rmmountpoint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rmmountpoint(): g is not a blessed HV reference");
    };
#line 8829 "Guestfs.xs"
      r = guestfs_rmmountpoint (g, exemptpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22488 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rsync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rsync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 8839 "Guestfs.xs"
      int r;
      struct guestfs_rsync_argv optargs_s = { .bitmask = 0 };
      struct guestfs_rsync_argv *optargs = &optargs_s;
      size_t items_i;
#line 22516 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rsync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rsync(): g is not a blessed HV reference");
    };
#line 8844 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "archive")) {
          optargs_s.archive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_ARCHIVE_BITMASK;
        }
        else if (STREQ (this_arg, "deletedest")) {
          optargs_s.deletedest = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_DELETEDEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_rsync_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22555 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rsync_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rsync_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, remote, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remote = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 8876 "Guestfs.xs"
      int r;
      struct guestfs_rsync_in_argv optargs_s = { .bitmask = 0 };
      struct guestfs_rsync_in_argv *optargs = &optargs_s;
      size_t items_i;
#line 22583 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rsync_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rsync_in(): g is not a blessed HV reference");
    };
#line 8881 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "archive")) {
          optargs_s.archive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_IN_ARCHIVE_BITMASK;
        }
        else if (STREQ (this_arg, "deletedest")) {
          optargs_s.deletedest = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_IN_DELETEDEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_rsync_in_argv (g, remote, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22622 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rsync_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rsync_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, remote, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	remote = (char *)SvPV_nolen(ST(2));
#line 8913 "Guestfs.xs"
      int r;
      struct guestfs_rsync_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_rsync_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 22650 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rsync_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rsync_out(): g is not a blessed HV reference");
    };
#line 8918 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "archive")) {
          optargs_s.archive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_OUT_ARCHIVE_BITMASK;
        }
        else if (STREQ (this_arg, "deletedest")) {
          optargs_s.deletedest = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_OUT_DELETEDEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_rsync_out_argv (g, src, remote, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22689 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_scrub_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_scrub_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8949 "Guestfs.xs"
      int r;
#line 22713 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::scrub_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::scrub_device(): g is not a blessed HV reference");
    };
#line 8951 "Guestfs.xs"
      r = guestfs_scrub_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22730 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_scrub_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_scrub_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 8960 "Guestfs.xs"
      int r;
#line 22754 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::scrub_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::scrub_file(): g is not a blessed HV reference");
    };
#line 8962 "Guestfs.xs"
      r = guestfs_scrub_file (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22771 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_scrub_freespace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_scrub_freespace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
#line 8971 "Guestfs.xs"
      int r;
#line 22795 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::scrub_freespace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::scrub_freespace(): g is not a blessed HV reference");
    };
#line 8973 "Guestfs.xs"
      r = guestfs_scrub_freespace (g, dir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22812 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, append");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	append = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 8982 "Guestfs.xs"
      int r;
#line 22836 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_append(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_append(): g is not a blessed HV reference");
    };
#line 8984 "Guestfs.xs"
      r = guestfs_set_append (g, append);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22853 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_attach_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_attach_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, backend");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	backend = (char *)SvPV_nolen(ST(1));
#line 8993 "Guestfs.xs"
      int r;
#line 22877 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_attach_method(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_attach_method(): g is not a blessed HV reference");
    };
#line 8995 "Guestfs.xs"
      r = guestfs_set_attach_method (g, backend);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22894 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_autosync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_autosync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, autosync");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	autosync = (int)SvIV(ST(1));
#line 9004 "Guestfs.xs"
      int r;
#line 22918 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_autosync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_autosync(): g is not a blessed HV reference");
    };
#line 9006 "Guestfs.xs"
      r = guestfs_set_autosync (g, autosync);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22935 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_backend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_backend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, backend");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	backend = (char *)SvPV_nolen(ST(1));
#line 9015 "Guestfs.xs"
      int r;
#line 22959 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_backend(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_backend(): g is not a blessed HV reference");
    };
#line 9017 "Guestfs.xs"
      r = guestfs_set_backend (g, backend);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22976 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_backend_setting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_backend_setting)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, name, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
#line 9027 "Guestfs.xs"
      int r;
#line 23001 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_backend_setting(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_backend_setting(): g is not a blessed HV reference");
    };
#line 9029 "Guestfs.xs"
      r = guestfs_set_backend_setting (g, name, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23018 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_backend_settings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_backend_settings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, settings");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	settings = XS_unpack_charPtrPtr(ST(1));
#line 9038 "Guestfs.xs"
      int r;
#line 23042 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_backend_settings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_backend_settings(): g is not a blessed HV reference");
    };
#line 9040 "Guestfs.xs"
      r = guestfs_set_backend_settings (g, settings);
      free (settings);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23060 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_cachedir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_cachedir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, cachedir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	cachedir = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9050 "Guestfs.xs"
      int r;
#line 23084 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_cachedir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_cachedir(): g is not a blessed HV reference");
    };
#line 9052 "Guestfs.xs"
      r = guestfs_set_cachedir (g, cachedir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23101 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_direct); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_direct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, direct");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	direct = (int)SvIV(ST(1));
#line 9061 "Guestfs.xs"
      int r;
#line 23125 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_direct(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_direct(): g is not a blessed HV reference");
    };
#line 9063 "Guestfs.xs"
      r = guestfs_set_direct (g, direct);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23142 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2attrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2attrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, file, attrs, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
	char *	attrs = (char *)SvPV_nolen(ST(2));
#line 9073 "Guestfs.xs"
      int r;
      struct guestfs_set_e2attrs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_set_e2attrs_argv *optargs = &optargs_s;
      size_t items_i;
#line 23170 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2attrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2attrs(): g is not a blessed HV reference");
    };
#line 9078 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "clear")) {
          optargs_s.clear = SvIV (ST (items_i+1));
          this_mask = GUESTFS_SET_E2ATTRS_CLEAR_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_set_e2attrs_argv (g, file, attrs, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23205 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, file, generation");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
	int64_t    generation = my_SvIV64 (ST(2));
#line 9106 "Guestfs.xs"
      int r;
#line 23230 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2generation(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2generation(): g is not a blessed HV reference");
    };
#line 9108 "Guestfs.xs"
      r = guestfs_set_e2generation (g, file, generation);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23247 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
#line 9118 "Guestfs.xs"
      int r;
#line 23272 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2label(): g is not a blessed HV reference");
    };
#line 9120 "Guestfs.xs"
      r = guestfs_set_e2label (g, device, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23289 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	uuid = (char *)SvPV_nolen(ST(2));
#line 9130 "Guestfs.xs"
      int r;
#line 23314 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2uuid(): g is not a blessed HV reference");
    };
#line 9132 "Guestfs.xs"
      r = guestfs_set_e2uuid (g, device, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23331 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_hv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_hv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	hv = (char *)SvPV_nolen(ST(1));
#line 9141 "Guestfs.xs"
      int r;
#line 23355 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_hv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_hv(): g is not a blessed HV reference");
    };
#line 9143 "Guestfs.xs"
      r = guestfs_set_hv (g, hv);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23372 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mountable, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
#line 9153 "Guestfs.xs"
      int r;
#line 23397 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_label(): g is not a blessed HV reference");
    };
#line 9155 "Guestfs.xs"
      r = guestfs_set_label (g, mountable, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23414 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_libvirt_requested_credential); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_libvirt_requested_credential)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, index, cred");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
	char *	cred = (char *)SvPV_nolen(ST(2));
	size_t	cred_size = SvCUR (ST(2));
#line 9166 "Guestfs.xs"
      int r;
#line 23440 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_libvirt_requested_credential(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_libvirt_requested_credential(): g is not a blessed HV reference");
    };
#line 9168 "Guestfs.xs"
      r = guestfs_set_libvirt_requested_credential (g, index, cred, cred_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23457 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_libvirt_supported_credentials); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_libvirt_supported_credentials)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, creds");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	creds = XS_unpack_charPtrPtr(ST(1));
#line 9177 "Guestfs.xs"
      int r;
#line 23481 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_libvirt_supported_credentials(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_libvirt_supported_credentials(): g is not a blessed HV reference");
    };
#line 9179 "Guestfs.xs"
      r = guestfs_set_libvirt_supported_credentials (g, creds);
      free (creds);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23499 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_memsize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_memsize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, memsize");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	memsize = (int)SvIV(ST(1));
#line 9189 "Guestfs.xs"
      int r;
#line 23523 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_memsize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_memsize(): g is not a blessed HV reference");
    };
#line 9191 "Guestfs.xs"
      r = guestfs_set_memsize (g, memsize);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23540 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_network); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_network)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, network");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	network = (int)SvIV(ST(1));
#line 9200 "Guestfs.xs"
      int r;
#line 23564 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_network(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_network(): g is not a blessed HV reference");
    };
#line 9202 "Guestfs.xs"
      r = guestfs_set_network (g, network);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23581 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, searchpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	searchpath = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9211 "Guestfs.xs"
      int r;
#line 23605 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_path(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_path(): g is not a blessed HV reference");
    };
#line 9213 "Guestfs.xs"
      r = guestfs_set_path (g, searchpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23622 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_pgroup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_pgroup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, pgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	pgroup = (int)SvIV(ST(1));
#line 9222 "Guestfs.xs"
      int r;
#line 23646 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_pgroup(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_pgroup(): g is not a blessed HV reference");
    };
#line 9224 "Guestfs.xs"
      r = guestfs_set_pgroup (g, pgroup);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23663 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_program); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_program)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, program");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	program = (char *)SvPV_nolen(ST(1));
#line 9233 "Guestfs.xs"
      int r;
#line 23687 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_program(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_program(): g is not a blessed HV reference");
    };
#line 9235 "Guestfs.xs"
      r = guestfs_set_program (g, program);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23704 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_qemu); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_qemu)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	hv = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9244 "Guestfs.xs"
      int r;
#line 23728 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_qemu(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_qemu(): g is not a blessed HV reference");
    };
#line 9246 "Guestfs.xs"
      r = guestfs_set_qemu (g, hv);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23745 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_recovery_proc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_recovery_proc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, recoveryproc");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	recoveryproc = (int)SvIV(ST(1));
#line 9255 "Guestfs.xs"
      int r;
#line 23769 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_recovery_proc(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_recovery_proc(): g is not a blessed HV reference");
    };
#line 9257 "Guestfs.xs"
      r = guestfs_set_recovery_proc (g, recoveryproc);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23786 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_selinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_selinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, selinux");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	selinux = (int)SvIV(ST(1));
#line 9266 "Guestfs.xs"
      int r;
#line 23810 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_selinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_selinux(): g is not a blessed HV reference");
    };
#line 9268 "Guestfs.xs"
      r = guestfs_set_selinux (g, selinux);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23827 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_smp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_smp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, smp");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	smp = (int)SvIV(ST(1));
#line 9277 "Guestfs.xs"
      int r;
#line 23851 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_smp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_smp(): g is not a blessed HV reference");
    };
#line 9279 "Guestfs.xs"
      r = guestfs_set_smp (g, smp);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23868 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_tmpdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_tmpdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, tmpdir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tmpdir = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9288 "Guestfs.xs"
      int r;
#line 23892 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_tmpdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_tmpdir(): g is not a blessed HV reference");
    };
#line 9290 "Guestfs.xs"
      r = guestfs_set_tmpdir (g, tmpdir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23909 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_trace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_trace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, trace");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	trace = (int)SvIV(ST(1));
#line 9299 "Guestfs.xs"
      int r;
#line 23933 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_trace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_trace(): g is not a blessed HV reference");
    };
#line 9301 "Guestfs.xs"
      r = guestfs_set_trace (g, trace);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23950 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	uuid = (char *)SvPV_nolen(ST(2));
#line 9311 "Guestfs.xs"
      int r;
#line 23975 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_uuid(): g is not a blessed HV reference");
    };
#line 9313 "Guestfs.xs"
      r = guestfs_set_uuid (g, device, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23992 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_uuid_random); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_uuid_random)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9322 "Guestfs.xs"
      int r;
#line 24016 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_uuid_random(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_uuid_random(): g is not a blessed HV reference");
    };
#line 9324 "Guestfs.xs"
      r = guestfs_set_uuid_random (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24033 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_verbose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_verbose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, verbose");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	verbose = (int)SvIV(ST(1));
#line 9333 "Guestfs.xs"
      int r;
#line 24057 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_verbose(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_verbose(): g is not a blessed HV reference");
    };
#line 9335 "Guestfs.xs"
      r = guestfs_set_verbose (g, verbose);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24074 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_setcon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_setcon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, context");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	context = (char *)SvPV_nolen(ST(1));
#line 9344 "Guestfs.xs"
      int r;
#line 24098 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::setcon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::setcon(): g is not a blessed HV reference");
    };
#line 9346 "Guestfs.xs"
      r = guestfs_setcon (g, context);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24115 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_setxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_setxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, xattr, val, vallen, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
	int	vallen = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 9358 "Guestfs.xs"
      int r;
#line 24142 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::setxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::setxattr(): g is not a blessed HV reference");
    };
#line 9360 "Guestfs.xs"
      r = guestfs_setxattr (g, xattr, val, vallen, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24159 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdisk); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "g, device, cyls, heads, sectors, lines");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	cyls = (int)SvIV(ST(2));
	int	heads = (int)SvIV(ST(3));
	int	sectors = (int)SvIV(ST(4));
	char **	lines = XS_unpack_charPtrPtr(ST(5));
#line 9373 "Guestfs.xs"
      int r;
#line 24187 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk(): g is not a blessed HV reference");
    };
#line 9375 "Guestfs.xs"
      r = guestfs_sfdisk (g, device, cyls, heads, sectors, lines);
      free (lines);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24205 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdiskM); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdiskM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, lines");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char **	lines = XS_unpack_charPtrPtr(ST(2));
#line 9386 "Guestfs.xs"
      int r;
#line 24230 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdiskM(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdiskM(): g is not a blessed HV reference");
    };
#line 9388 "Guestfs.xs"
      r = guestfs_sfdiskM (g, device, lines);
      free (lines);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24248 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdisk_N); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_N)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "g, device, partnum, cyls, heads, sectors, line");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	int	cyls = (int)SvIV(ST(3));
	int	heads = (int)SvIV(ST(4));
	int	sectors = (int)SvIV(ST(5));
	char *	line = (char *)SvPV_nolen(ST(6));
#line 9403 "Guestfs.xs"
      int r;
#line 24277 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_N(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_N(): g is not a blessed HV reference");
    };
#line 9405 "Guestfs.xs"
      r = guestfs_sfdisk_N (g, device, partnum, cyls, heads, sectors, line);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24294 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdisk_disk_geometry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_disk_geometry)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9414 "Guestfs.xs"
      char *r;
#line 24316 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_disk_geometry(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_disk_geometry(): g is not a blessed HV reference");
    };
#line 9416 "Guestfs.xs"
      r = guestfs_sfdisk_disk_geometry (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24336 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sfdisk_kernel_geometry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_kernel_geometry)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9429 "Guestfs.xs"
      char *r;
#line 24359 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_kernel_geometry(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_kernel_geometry(): g is not a blessed HV reference");
    };
#line 9431 "Guestfs.xs"
      r = guestfs_sfdisk_kernel_geometry (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24379 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sfdisk_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_l)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9444 "Guestfs.xs"
      char *r;
#line 24402 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_l(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_l(): g is not a blessed HV reference");
    };
#line 9446 "Guestfs.xs"
      r = guestfs_sfdisk_l (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24422 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, command");
    {
	guestfs_h *	g;
	char *	command = (char *)SvPV_nolen(ST(1));
#line 9459 "Guestfs.xs"
      char *r;
#line 24445 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sh(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sh(): g is not a blessed HV reference");
    };
#line 9461 "Guestfs.xs"
      r = guestfs_sh (g, command);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24465 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sh_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sh_lines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, command");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	command = (char *)SvPV_nolen(ST(1));
#line 9474 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 24491 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sh_lines(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sh_lines(): g is not a blessed HV reference");
    };
#line 9477 "Guestfs.xs"
      r = guestfs_sh_lines (g, command);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 24515 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 9492 "Guestfs.xs"
      int r;
#line 24538 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::shutdown(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::shutdown(): g is not a blessed HV reference");
    };
#line 9494 "Guestfs.xs"
      r = guestfs_shutdown (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24555 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sleep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sleep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, secs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	secs = (int)SvIV(ST(1));
#line 9503 "Guestfs.xs"
      int r;
#line 24579 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sleep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sleep(): g is not a blessed HV reference");
    };
#line 9505 "Guestfs.xs"
      r = guestfs_sleep (g, secs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24596 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_stat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_stat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9514 "Guestfs.xs"
      struct guestfs_stat *r;
#line 24620 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::stat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::stat(): g is not a blessed HV reference");
    };
#line 9516 "Guestfs.xs"
      r = guestfs_stat (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 13);
      PUSHs (sv_2mortal (newSVpv ("dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->dev)));
      PUSHs (sv_2mortal (newSVpv ("ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ino)));
      PUSHs (sv_2mortal (newSVpv ("mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mode)));
      PUSHs (sv_2mortal (newSVpv ("nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->nlink)));
      PUSHs (sv_2mortal (newSVpv ("uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->uid)));
      PUSHs (sv_2mortal (newSVpv ("gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->gid)));
      PUSHs (sv_2mortal (newSVpv ("rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->rdev)));
      PUSHs (sv_2mortal (newSVpv ("size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->size)));
      PUSHs (sv_2mortal (newSVpv ("blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blksize)));
      PUSHs (sv_2mortal (newSVpv ("blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blocks)));
      PUSHs (sv_2mortal (newSVpv ("atime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->atime)));
      PUSHs (sv_2mortal (newSVpv ("mtime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mtime)));
      PUSHs (sv_2mortal (newSVpv ("ctime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ctime)));
      free (r);
#line 24665 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_statns); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_statns)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9553 "Guestfs.xs"
      struct guestfs_statns *r;
#line 24689 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::statns(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::statns(): g is not a blessed HV reference");
    };
#line 9555 "Guestfs.xs"
      r = guestfs_statns (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 22);
      PUSHs (sv_2mortal (newSVpv ("st_dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_dev)));
      PUSHs (sv_2mortal (newSVpv ("st_ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ino)));
      PUSHs (sv_2mortal (newSVpv ("st_mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mode)));
      PUSHs (sv_2mortal (newSVpv ("st_nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_nlink)));
      PUSHs (sv_2mortal (newSVpv ("st_uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_uid)));
      PUSHs (sv_2mortal (newSVpv ("st_gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_gid)));
      PUSHs (sv_2mortal (newSVpv ("st_rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_rdev)));
      PUSHs (sv_2mortal (newSVpv ("st_size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_size)));
      PUSHs (sv_2mortal (newSVpv ("st_blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blksize)));
      PUSHs (sv_2mortal (newSVpv ("st_blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blocks)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_spare1", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare1)));
      PUSHs (sv_2mortal (newSVpv ("st_spare2", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare2)));
      PUSHs (sv_2mortal (newSVpv ("st_spare3", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare3)));
      PUSHs (sv_2mortal (newSVpv ("st_spare4", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare4)));
      PUSHs (sv_2mortal (newSVpv ("st_spare5", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare5)));
      PUSHs (sv_2mortal (newSVpv ("st_spare6", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare6)));
      free (r);
#line 24752 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_statvfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_statvfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9610 "Guestfs.xs"
      struct guestfs_statvfs *r;
#line 24776 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::statvfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::statvfs(): g is not a blessed HV reference");
    };
#line 9612 "Guestfs.xs"
      r = guestfs_statvfs (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 11);
      PUSHs (sv_2mortal (newSVpv ("bsize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->bsize)));
      PUSHs (sv_2mortal (newSVpv ("frsize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->frsize)));
      PUSHs (sv_2mortal (newSVpv ("blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blocks)));
      PUSHs (sv_2mortal (newSVpv ("bfree", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->bfree)));
      PUSHs (sv_2mortal (newSVpv ("bavail", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->bavail)));
      PUSHs (sv_2mortal (newSVpv ("files", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->files)));
      PUSHs (sv_2mortal (newSVpv ("ffree", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ffree)));
      PUSHs (sv_2mortal (newSVpv ("favail", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->favail)));
      PUSHs (sv_2mortal (newSVpv ("fsid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->fsid)));
      PUSHs (sv_2mortal (newSVpv ("flag", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->flag)));
      PUSHs (sv_2mortal (newSVpv ("namemax", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->namemax)));
      free (r);
#line 24817 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_strings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_strings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9645 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 24842 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::strings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::strings(): g is not a blessed HV reference");
    };
#line 9648 "Guestfs.xs"
      r = guestfs_strings (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 24866 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_strings_e); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_strings_e)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, encoding, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	encoding = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 9665 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 24892 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::strings_e(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::strings_e(): g is not a blessed HV reference");
    };
#line 9668 "Guestfs.xs"
      r = guestfs_strings_e (g, encoding, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 24916 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9684 "Guestfs.xs"
      int r;
#line 24940 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_device(): g is not a blessed HV reference");
    };
#line 9686 "Guestfs.xs"
      r = guestfs_swapoff_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24957 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 9695 "Guestfs.xs"
      int r;
#line 24981 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_file(): g is not a blessed HV reference");
    };
#line 9697 "Guestfs.xs"
      r = guestfs_swapoff_file (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24998 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 9706 "Guestfs.xs"
      int r;
#line 25022 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_label(): g is not a blessed HV reference");
    };
#line 9708 "Guestfs.xs"
      r = guestfs_swapoff_label (g, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25039 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
#line 9717 "Guestfs.xs"
      int r;
#line 25063 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_uuid(): g is not a blessed HV reference");
    };
#line 9719 "Guestfs.xs"
      r = guestfs_swapoff_uuid (g, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25080 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9728 "Guestfs.xs"
      int r;
#line 25104 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_device(): g is not a blessed HV reference");
    };
#line 9730 "Guestfs.xs"
      r = guestfs_swapon_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25121 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 9739 "Guestfs.xs"
      int r;
#line 25145 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_file(): g is not a blessed HV reference");
    };
#line 9741 "Guestfs.xs"
      r = guestfs_swapon_file (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25162 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 9750 "Guestfs.xs"
      int r;
#line 25186 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_label(): g is not a blessed HV reference");
    };
#line 9752 "Guestfs.xs"
      r = guestfs_swapon_label (g, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25203 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
#line 9761 "Guestfs.xs"
      int r;
#line 25227 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_uuid(): g is not a blessed HV reference");
    };
#line 9763 "Guestfs.xs"
      r = guestfs_swapon_uuid (g, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25244 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 9771 "Guestfs.xs"
      int r;
#line 25267 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sync(): g is not a blessed HV reference");
    };
#line 9773 "Guestfs.xs"
      r = guestfs_sync (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25284 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_syslinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_syslinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9782 "Guestfs.xs"
      int r;
      struct guestfs_syslinux_argv optargs_s = { .bitmask = 0 };
      struct guestfs_syslinux_argv *optargs = &optargs_s;
      size_t items_i;
#line 25311 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::syslinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::syslinux(): g is not a blessed HV reference");
    };
#line 9787 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "directory")) {
          optargs_s.directory = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_SYSLINUX_DIRECTORY_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_syslinux_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25346 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tail); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9814 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 25371 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tail(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tail(): g is not a blessed HV reference");
    };
#line 9817 "Guestfs.xs"
      r = guestfs_tail (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 25395 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tail_n); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tail_n)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nrlines, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	nrlines = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 9834 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 25421 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tail_n(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tail_n(): g is not a blessed HV reference");
    };
#line 9837 "Guestfs.xs"
      r = guestfs_tail_n (g, nrlines, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 25445 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tar_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tar_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, tarfile, directory, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tarfile = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
#line 9854 "Guestfs.xs"
      int r;
      struct guestfs_tar_in_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_tar_in_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 25473 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tar_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tar_in(): g is not a blessed HV reference");
    };
#line 9859 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "compress")) {
          optargs_s.compress = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TAR_IN_OPTS_COMPRESS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_tar_in_opts_argv (g, tarfile, directory, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25508 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tar_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tar_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, directory, tarfile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	tarfile = (char *)SvPV_nolen(ST(2));
#line 9887 "Guestfs.xs"
      int r;
      struct guestfs_tar_out_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_tar_out_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 25536 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tar_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tar_out(): g is not a blessed HV reference");
    };
#line 9892 "Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "compress")) {
          optargs_s.compress = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_COMPRESS_BITMASK;
        }
        else if (STREQ (this_arg, "numericowner")) {
          optargs_s.numericowner = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_NUMERICOWNER_BITMASK;
        }
        else if (STREQ (this_arg, "excludes")) {
          size_t i, len;
          char **r;
          SV *arg;
          AV *av;
          SV **svp;

          arg = ST (items_i+1);
          if (!SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
            croak ("array reference expected for '%s' argument", "excludes");
          av = (AV *) SvRV (ST (items_i+1));

          /* Note av_len returns index of final element. */
          len = av_len (av) + 1;

          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));
          for (i = 0; i < len; ++i) {
            svp = av_fetch (av, i, 0);
            r[i] = SvPV_nolen (*svp);
          }
          r[i] = NULL;
          optargs_s.excludes = r;
          this_mask = GUESTFS_TAR_OUT_OPTS_EXCLUDES_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_tar_out_opts_argv (g, directory, tarfile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25599 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tgz_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tgz_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, tarball, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tarball = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
#line 9948 "Guestfs.xs"
      int r;
#line 25624 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tgz_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tgz_in(): g is not a blessed HV reference");
    };
#line 9950 "Guestfs.xs"
      r = guestfs_tgz_in (g, tarball, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25641 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tgz_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tgz_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, directory, tarball");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	tarball = (char *)SvPV_nolen(ST(2));
#line 9960 "Guestfs.xs"
      int r;
#line 25666 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tgz_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tgz_out(): g is not a blessed HV reference");
    };
#line 9962 "Guestfs.xs"
      r = guestfs_tgz_out (g, directory, tarball);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25683 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_touch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_touch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9971 "Guestfs.xs"
      int r;
#line 25707 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::touch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::touch(): g is not a blessed HV reference");
    };
#line 9973 "Guestfs.xs"
      r = guestfs_touch (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25724 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_truncate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_truncate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9982 "Guestfs.xs"
      int r;
#line 25748 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::truncate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::truncate(): g is not a blessed HV reference");
    };
#line 9984 "Guestfs.xs"
      r = guestfs_truncate (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25765 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_truncate_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_truncate_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 9994 "Guestfs.xs"
      int r;
#line 25790 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::truncate_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::truncate_size(): g is not a blessed HV reference");
    };
#line 9996 "Guestfs.xs"
      r = guestfs_truncate_size (g, path, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25807 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tune2fs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tune2fs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10005 "Guestfs.xs"
      int r;
      struct guestfs_tune2fs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_tune2fs_argv *optargs = &optargs_s;
      size_t items_i;
#line 25834 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tune2fs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tune2fs(): g is not a blessed HV reference");
    };
#line 10010 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_FORCE_BITMASK;
        }
        else if (STREQ (this_arg, "maxmountcount")) {
          optargs_s.maxmountcount = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_MAXMOUNTCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "mountcount")) {
          optargs_s.mountcount = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_MOUNTCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "errorbehavior")) {
          optargs_s.errorbehavior = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_ERRORBEHAVIOR_BITMASK;
        }
        else if (STREQ (this_arg, "group")) {
          optargs_s.group = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_GROUP_BITMASK;
        }
        else if (STREQ (this_arg, "intervalbetweenchecks")) {
          optargs_s.intervalbetweenchecks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS_BITMASK;
        }
        else if (STREQ (this_arg, "reservedblockspercentage")) {
          optargs_s.reservedblockspercentage = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE_BITMASK;
        }
        else if (STREQ (this_arg, "lastmounteddirectory")) {
          optargs_s.lastmounteddirectory = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY_BITMASK;
        }
        else if (STREQ (this_arg, "reservedblockscount")) {
          optargs_s.reservedblockscount = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "user")) {
          optargs_s.user = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_USER_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_tune2fs_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25905 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tune2fs_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tune2fs_l)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10073 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 25930 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tune2fs_l(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tune2fs_l(): g is not a blessed HV reference");
    };
#line 10076 "Guestfs.xs"
      r = guestfs_tune2fs_l (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 25954 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_txz_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_txz_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, tarball, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tarball = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
#line 10093 "Guestfs.xs"
      int r;
#line 25979 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::txz_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::txz_in(): g is not a blessed HV reference");
    };
#line 10095 "Guestfs.xs"
      r = guestfs_txz_in (g, tarball, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25996 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_txz_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_txz_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, directory, tarball");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	tarball = (char *)SvPV_nolen(ST(2));
#line 10105 "Guestfs.xs"
      int r;
#line 26021 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::txz_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::txz_out(): g is not a blessed HV reference");
    };
#line 10107 "Guestfs.xs"
      r = guestfs_txz_out (g, directory, tarball);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26038 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_umask); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umask)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mask");
    {
	guestfs_h *	g;
	int	mask = (int)SvIV(ST(1));
#line 10116 "Guestfs.xs"
      int r;
#line 26060 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umask(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umask(): g is not a blessed HV reference");
    };
#line 10118 "Guestfs.xs"
      r = guestfs_umask (g, mask);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 26079 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_umount); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, pathordevice, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pathordevice = (char *)SvPV_nolen(ST(1));
#line 10130 "Guestfs.xs"
      int r;
      struct guestfs_umount_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_umount_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 26107 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umount(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umount(): g is not a blessed HV reference");
    };
#line 10135 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_UMOUNT_OPTS_FORCE_BITMASK;
        }
        else if (STREQ (this_arg, "lazyunmount")) {
          optargs_s.lazyunmount = SvIV (ST (items_i+1));
          this_mask = GUESTFS_UMOUNT_OPTS_LAZYUNMOUNT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_umount_opts_argv (g, pathordevice, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26146 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_umount_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umount_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10165 "Guestfs.xs"
      int r;
#line 26169 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umount_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umount_all(): g is not a blessed HV reference");
    };
#line 10167 "Guestfs.xs"
      r = guestfs_umount_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26186 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_umount_local); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umount_local)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "g, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10175 "Guestfs.xs"
      int r;
      struct guestfs_umount_local_argv optargs_s = { .bitmask = 0 };
      struct guestfs_umount_local_argv *optargs = &optargs_s;
      size_t items_i;
#line 26212 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umount_local(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umount_local(): g is not a blessed HV reference");
    };
#line 10180 "Guestfs.xs"
      if (((items - 1) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 1; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "retry")) {
          optargs_s.retry = SvIV (ST (items_i+1));
          this_mask = GUESTFS_UMOUNT_LOCAL_RETRY_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_umount_local_argv (g, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26247 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_upload); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_upload)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, remotefilename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	remotefilename = (char *)SvPV_nolen(ST(2));
#line 10208 "Guestfs.xs"
      int r;
#line 26272 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::upload(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::upload(): g is not a blessed HV reference");
    };
#line 10210 "Guestfs.xs"
      r = guestfs_upload (g, filename, remotefilename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26289 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_upload_offset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_upload_offset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, filename, remotefilename, offset");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	remotefilename = (char *)SvPV_nolen(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 10221 "Guestfs.xs"
      int r;
#line 26315 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::upload_offset(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::upload_offset(): g is not a blessed HV reference");
    };
#line 10223 "Guestfs.xs"
      r = guestfs_upload_offset (g, filename, remotefilename, offset);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26332 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_user_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_user_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10231 "Guestfs.xs"
      int r;
#line 26355 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::user_cancel(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::user_cancel(): g is not a blessed HV reference");
    };
#line 10233 "Guestfs.xs"
      r = guestfs_user_cancel (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26372 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_utimens); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_utimens)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "g, path, atsecs, atnsecs, mtsecs, mtnsecs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int64_t    atsecs = my_SvIV64 (ST(2));
	int64_t    atnsecs = my_SvIV64 (ST(3));
	int64_t    mtsecs = my_SvIV64 (ST(4));
	int64_t    mtnsecs = my_SvIV64 (ST(5));
#line 10246 "Guestfs.xs"
      int r;
#line 26400 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::utimens(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::utimens(): g is not a blessed HV reference");
    };
#line 10248 "Guestfs.xs"
      r = guestfs_utimens (g, path, atsecs, atnsecs, mtsecs, mtnsecs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26417 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_utsname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_utsname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10256 "Guestfs.xs"
      struct guestfs_utsname *r;
#line 26440 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::utsname(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::utsname(): g is not a blessed HV reference");
    };
#line 10258 "Guestfs.xs"
      r = guestfs_utsname (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 4);
      PUSHs (sv_2mortal (newSVpv ("uts_sysname", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_sysname, 0)));
      PUSHs (sv_2mortal (newSVpv ("uts_release", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_release, 0)));
      PUSHs (sv_2mortal (newSVpv ("uts_version", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_version, 0)));
      PUSHs (sv_2mortal (newSVpv ("uts_machine", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_machine, 0)));
      free (r);
#line 26467 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10276 "Guestfs.xs"
      struct guestfs_version *r;
#line 26490 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::version(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::version(): g is not a blessed HV reference");
    };
#line 10278 "Guestfs.xs"
      r = guestfs_version (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 4);
      PUSHs (sv_2mortal (newSVpv ("major", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->major)));
      PUSHs (sv_2mortal (newSVpv ("minor", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->minor)));
      PUSHs (sv_2mortal (newSVpv ("release", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->release)));
      PUSHs (sv_2mortal (newSVpv ("extra", 0)));
      PUSHs (sv_2mortal (newSVpv (r->extra, 0)));
      free (r);
#line 26517 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vfs_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10297 "Guestfs.xs"
      char *r;
#line 26539 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_label(): g is not a blessed HV reference");
    };
#line 10299 "Guestfs.xs"
      r = guestfs_vfs_label (g, mountable);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 26559 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vfs_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10312 "Guestfs.xs"
      char *r;
#line 26582 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_type(): g is not a blessed HV reference");
    };
#line 10314 "Guestfs.xs"
      r = guestfs_vfs_type (g, mountable);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 26602 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vfs_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10327 "Guestfs.xs"
      char *r;
#line 26625 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_uuid(): g is not a blessed HV reference");
    };
#line 10329 "Guestfs.xs"
      r = guestfs_vfs_uuid (g, mountable);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 26645 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vg_activate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vg_activate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, activate, volgroups");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	activate = (int)SvIV(ST(1));
	char **	volgroups = XS_unpack_charPtrPtr(ST(2));
#line 10343 "Guestfs.xs"
      int r;
#line 26671 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vg_activate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vg_activate(): g is not a blessed HV reference");
    };
#line 10345 "Guestfs.xs"
      r = guestfs_vg_activate (g, activate, volgroups);
      free (volgroups);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26689 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vg_activate_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vg_activate_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, activate");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	activate = (int)SvIV(ST(1));
#line 10355 "Guestfs.xs"
      int r;
#line 26713 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vg_activate_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vg_activate_all(): g is not a blessed HV reference");
    };
#line 10357 "Guestfs.xs"
      r = guestfs_vg_activate_all (g, activate);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26730 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgchange_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgchange_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vg");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vg = (char *)SvPV_nolen(ST(1));
#line 10366 "Guestfs.xs"
      int r;
#line 26754 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgchange_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgchange_uuid(): g is not a blessed HV reference");
    };
#line 10368 "Guestfs.xs"
      r = guestfs_vgchange_uuid (g, vg);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26771 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgchange_uuid_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgchange_uuid_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10376 "Guestfs.xs"
      int r;
#line 26794 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgchange_uuid_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgchange_uuid_all(): g is not a blessed HV reference");
    };
#line 10378 "Guestfs.xs"
      r = guestfs_vgchange_uuid_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26811 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgcreate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgcreate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, volgroup, physvols");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	volgroup = (char *)SvPV_nolen(ST(1));
	char **	physvols = XS_unpack_charPtrPtr(ST(2));
#line 10388 "Guestfs.xs"
      int r;
#line 26836 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgcreate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgcreate(): g is not a blessed HV reference");
    };
#line 10390 "Guestfs.xs"
      r = guestfs_vgcreate (g, volgroup, physvols);
      free (physvols);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26854 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vglvuuids); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vglvuuids)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10400 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 26879 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vglvuuids(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vglvuuids(): g is not a blessed HV reference");
    };
#line 10403 "Guestfs.xs"
      r = guestfs_vglvuuids (g, vgname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 26903 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgmeta); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgmeta)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10419 "Guestfs.xs"
      char *r;
      size_t size;
#line 26926 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgmeta(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgmeta(): g is not a blessed HV reference");
    };
#line 10422 "Guestfs.xs"
      r = guestfs_vgmeta (g, vgname, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 26946 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vgpvuuids); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgpvuuids)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10435 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 26972 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgpvuuids(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgpvuuids(): g is not a blessed HV reference");
    };
#line 10438 "Guestfs.xs"
      r = guestfs_vgpvuuids (g, vgname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 26996 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgremove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgremove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10454 "Guestfs.xs"
      int r;
#line 27020 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgremove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgremove(): g is not a blessed HV reference");
    };
#line 10456 "Guestfs.xs"
      r = guestfs_vgremove (g, vgname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27037 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgrename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgrename)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, volgroup, newvolgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	volgroup = (char *)SvPV_nolen(ST(1));
	char *	newvolgroup = (char *)SvPV_nolen(ST(2));
#line 10466 "Guestfs.xs"
      int r;
#line 27062 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgrename(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgrename(): g is not a blessed HV reference");
    };
#line 10468 "Guestfs.xs"
      r = guestfs_vgrename (g, volgroup, newvolgroup);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27079 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10476 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 27103 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgs(): g is not a blessed HV reference");
    };
#line 10479 "Guestfs.xs"
      r = guestfs_vgs (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 27127 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgs_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgs_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10494 "Guestfs.xs"
      struct guestfs_lvm_vg_list *r;
      size_t i;
      HV *hv;
#line 27152 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgs_full(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgs_full(): g is not a blessed HV reference");
    };
#line 10498 "Guestfs.xs"
      r = guestfs_vgs_full (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "vg_name", 7, newSVpv (r->val[i].vg_name, 0), 0);
        (void) hv_store (hv, "vg_uuid", 7, newSVpv (r->val[i].vg_uuid, 32), 0);
        (void) hv_store (hv, "vg_fmt", 6, newSVpv (r->val[i].vg_fmt, 0), 0);
        (void) hv_store (hv, "vg_attr", 7, newSVpv (r->val[i].vg_attr, 0), 0);
        (void) hv_store (hv, "vg_size", 7, my_newSVull (r->val[i].vg_size), 0);
        (void) hv_store (hv, "vg_free", 7, my_newSVull (r->val[i].vg_free), 0);
        (void) hv_store (hv, "vg_sysid", 8, newSVpv (r->val[i].vg_sysid, 0), 0);
        (void) hv_store (hv, "vg_extent_size", 14, my_newSVull (r->val[i].vg_extent_size), 0);
        (void) hv_store (hv, "vg_extent_count", 15, my_newSVll (r->val[i].vg_extent_count), 0);
        (void) hv_store (hv, "vg_free_count", 13, my_newSVll (r->val[i].vg_free_count), 0);
        (void) hv_store (hv, "max_lv", 6, my_newSVll (r->val[i].max_lv), 0);
        (void) hv_store (hv, "max_pv", 6, my_newSVll (r->val[i].max_pv), 0);
        (void) hv_store (hv, "pv_count", 8, my_newSVll (r->val[i].pv_count), 0);
        (void) hv_store (hv, "lv_count", 8, my_newSVll (r->val[i].lv_count), 0);
        (void) hv_store (hv, "snap_count", 10, my_newSVll (r->val[i].snap_count), 0);
        (void) hv_store (hv, "vg_seqno", 8, my_newSVll (r->val[i].vg_seqno), 0);
        (void) hv_store (hv, "vg_tags", 7, newSVpv (r->val[i].vg_tags, 0), 0);
        (void) hv_store (hv, "vg_mda_count", 12, my_newSVll (r->val[i].vg_mda_count), 0);
        (void) hv_store (hv, "vg_mda_free", 11, my_newSVull (r->val[i].vg_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_vg_list (r);
#line 27194 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgscan); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgscan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10531 "Guestfs.xs"
      int r;
#line 27217 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgscan(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgscan(): g is not a blessed HV reference");
    };
#line 10533 "Guestfs.xs"
      r = guestfs_vgscan (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27234 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vguuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vguuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10542 "Guestfs.xs"
      char *r;
#line 27256 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vguuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vguuid(): g is not a blessed HV reference");
    };
#line 10544 "Guestfs.xs"
      r = guestfs_vguuid (g, vgname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 27276 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wait_ready); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wait_ready)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10556 "Guestfs.xs"
      int r;
#line 27300 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wait_ready(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wait_ready(): g is not a blessed HV reference");
    };
#line 10558 "Guestfs.xs"
      r = guestfs_wait_ready (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27317 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_wc_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wc_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10567 "Guestfs.xs"
      int r;
#line 27339 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wc_c(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wc_c(): g is not a blessed HV reference");
    };
#line 10569 "Guestfs.xs"
      r = guestfs_wc_c (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27358 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wc_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wc_l)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10581 "Guestfs.xs"
      int r;
#line 27381 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wc_l(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wc_l(): g is not a blessed HV reference");
    };
#line 10583 "Guestfs.xs"
      r = guestfs_wc_l (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27400 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wc_w); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wc_w)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10595 "Guestfs.xs"
      int r;
#line 27423 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wc_w(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wc_w(): g is not a blessed HV reference");
    };
#line 10597 "Guestfs.xs"
      r = guestfs_wc_w (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27442 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wipefs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wipefs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10609 "Guestfs.xs"
      int r;
#line 27467 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wipefs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wipefs(): g is not a blessed HV reference");
    };
#line 10611 "Guestfs.xs"
      r = guestfs_wipefs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27484 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, content");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
#line 10622 "Guestfs.xs"
      int r;
#line 27510 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::write(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::write(): g is not a blessed HV reference");
    };
#line 10624 "Guestfs.xs"
      r = guestfs_write (g, path, content, content_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27527 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_write_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_write_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, content");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
#line 10635 "Guestfs.xs"
      int r;
#line 27553 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::write_append(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::write_append(): g is not a blessed HV reference");
    };
#line 10637 "Guestfs.xs"
      r = guestfs_write_append (g, path, content, content_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27570 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_write_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_write_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, content, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	int	size = (int)SvIV(ST(3));
#line 10648 "Guestfs.xs"
      int r;
#line 27596 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::write_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::write_file(): g is not a blessed HV reference");
    };
#line 10650 "Guestfs.xs"
      r = guestfs_write_file (g, path, content, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27613 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_admin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_admin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10659 "Guestfs.xs"
      int r;
      struct guestfs_xfs_admin_argv optargs_s = { .bitmask = 0 };
      struct guestfs_xfs_admin_argv *optargs = &optargs_s;
      size_t items_i;
#line 27640 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_admin(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_admin(): g is not a blessed HV reference");
    };
#line 10664 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "extunwritten")) {
          optargs_s.extunwritten = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_EXTUNWRITTEN_BITMASK;
        }
        else if (STREQ (this_arg, "imgfile")) {
          optargs_s.imgfile = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_IMGFILE_BITMASK;
        }
        else if (STREQ (this_arg, "v2log")) {
          optargs_s.v2log = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_V2LOG_BITMASK;
        }
        else if (STREQ (this_arg, "projid32bit")) {
          optargs_s.projid32bit = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_PROJID32BIT_BITMASK;
        }
        else if (STREQ (this_arg, "lazycounter")) {
          optargs_s.lazycounter = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_LAZYCOUNTER_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "uuid")) {
          optargs_s.uuid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_UUID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_xfs_admin_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27699 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_growfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_growfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10715 "Guestfs.xs"
      int r;
      struct guestfs_xfs_growfs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_xfs_growfs_argv *optargs = &optargs_s;
      size_t items_i;
#line 27726 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_growfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_growfs(): g is not a blessed HV reference");
    };
#line 10720 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "datasec")) {
          optargs_s.datasec = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_DATASEC_BITMASK;
        }
        else if (STREQ (this_arg, "logsec")) {
          optargs_s.logsec = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_LOGSEC_BITMASK;
        }
        else if (STREQ (this_arg, "rtsec")) {
          optargs_s.rtsec = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_RTSEC_BITMASK;
        }
        else if (STREQ (this_arg, "datasize")) {
          optargs_s.datasize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_DATASIZE_BITMASK;
        }
        else if (STREQ (this_arg, "logsize")) {
          optargs_s.logsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_LOGSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "rtsize")) {
          optargs_s.rtsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_RTSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "rtextsize")) {
          optargs_s.rtextsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_RTEXTSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "maxpct")) {
          optargs_s.maxpct = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_MAXPCT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_xfs_growfs_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27789 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, pathordevice");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pathordevice = (char *)SvPV_nolen(ST(1));
#line 10775 "Guestfs.xs"
      struct guestfs_xfsinfo *r;
#line 27813 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_info(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_info(): g is not a blessed HV reference");
    };
#line 10777 "Guestfs.xs"
      r = guestfs_xfs_info (g, pathordevice);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 25);
      PUSHs (sv_2mortal (newSVpv ("xfs_mntpoint", 0)));
      PUSHs (sv_2mortal (newSVpv (r->xfs_mntpoint, 0)));
      PUSHs (sv_2mortal (newSVpv ("xfs_inodesize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_inodesize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_agcount", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_agcount)));
      PUSHs (sv_2mortal (newSVpv ("xfs_agsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_agsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_sectsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_sectsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_attr", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_attr)));
      PUSHs (sv_2mortal (newSVpv ("xfs_blocksize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_blocksize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_datablocks", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->xfs_datablocks)));
      PUSHs (sv_2mortal (newSVpv ("xfs_imaxpct", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_imaxpct)));
      PUSHs (sv_2mortal (newSVpv ("xfs_sunit", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_sunit)));
      PUSHs (sv_2mortal (newSVpv ("xfs_swidth", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_swidth)));
      PUSHs (sv_2mortal (newSVpv ("xfs_dirversion", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_dirversion)));
      PUSHs (sv_2mortal (newSVpv ("xfs_dirblocksize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_dirblocksize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_cimode", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_cimode)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logname", 0)));
      PUSHs (sv_2mortal (newSVpv (r->xfs_logname, 0)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logblocksize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logblocksize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logblocks", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logblocks)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logversion", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logversion)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logsectsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logsectsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logsunit", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logsunit)));
      PUSHs (sv_2mortal (newSVpv ("xfs_lazycount", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_lazycount)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtname", 0)));
      PUSHs (sv_2mortal (newSVpv (r->xfs_rtname, 0)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtextsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_rtextsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtblocks", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->xfs_rtblocks)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtextents", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->xfs_rtextents)));
      free (r);
#line 27882 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_repair); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_repair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10838 "Guestfs.xs"
      int r;
      struct guestfs_xfs_repair_argv optargs_s = { .bitmask = 0 };
      struct guestfs_xfs_repair_argv *optargs = &optargs_s;
      size_t items_i;
#line 27907 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_repair(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_repair(): g is not a blessed HV reference");
    };
#line 10843 "Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "forcelogzero")) {
          optargs_s.forcelogzero = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_FORCELOGZERO_BITMASK;
        }
        else if (STREQ (this_arg, "nomodify")) {
          optargs_s.nomodify = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_NOMODIFY_BITMASK;
        }
        else if (STREQ (this_arg, "noprefetch")) {
          optargs_s.noprefetch = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_NOPREFETCH_BITMASK;
        }
        else if (STREQ (this_arg, "forcegeometry")) {
          optargs_s.forcegeometry = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_FORCEGEOMETRY_BITMASK;
        }
        else if (STREQ (this_arg, "maxmem")) {
          optargs_s.maxmem = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_MAXMEM_BITMASK;
        }
        else if (STREQ (this_arg, "ihashsize")) {
          optargs_s.ihashsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_IHASHSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "bhashsize")) {
          optargs_s.bhashsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_BHASHSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "agstride")) {
          optargs_s.agstride = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_AGSTRIDE_BITMASK;
        }
        else if (STREQ (this_arg, "logdev")) {
          optargs_s.logdev = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_LOGDEV_BITMASK;
        }
        else if (STREQ (this_arg, "rtdev")) {
          optargs_s.rtdev = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_RTDEV_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_xfs_repair_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27980 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_zegrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zegrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 10910 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 28007 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zegrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zegrep(): g is not a blessed HV reference");
    };
#line 10913 "Guestfs.xs"
      r = guestfs_zegrep (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28031 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zegrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zegrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 10930 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 28057 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zegrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zegrepi(): g is not a blessed HV reference");
    };
#line 10933 "Guestfs.xs"
      r = guestfs_zegrepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28081 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zero); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zero)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10949 "Guestfs.xs"
      int r;
#line 28105 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zero(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zero(): g is not a blessed HV reference");
    };
#line 10951 "Guestfs.xs"
      r = guestfs_zero (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28122 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zero_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zero_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10960 "Guestfs.xs"
      int r;
#line 28146 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zero_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zero_device(): g is not a blessed HV reference");
    };
#line 10962 "Guestfs.xs"
      r = guestfs_zero_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28163 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zero_free_space); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zero_free_space)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 10971 "Guestfs.xs"
      int r;
#line 28187 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zero_free_space(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zero_free_space(): g is not a blessed HV reference");
    };
#line 10973 "Guestfs.xs"
      r = guestfs_zero_free_space (g, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28204 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zerofree); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zerofree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10982 "Guestfs.xs"
      int r;
#line 28228 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zerofree(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zerofree(): g is not a blessed HV reference");
    };
#line 10984 "Guestfs.xs"
      r = guestfs_zerofree (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28245 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zfgrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zfgrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 10994 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 28271 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zfgrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zfgrep(): g is not a blessed HV reference");
    };
#line 10997 "Guestfs.xs"
      r = guestfs_zfgrep (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28295 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zfgrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zfgrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11014 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 28321 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zfgrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zfgrepi(): g is not a blessed HV reference");
    };
#line 11017 "Guestfs.xs"
      r = guestfs_zfgrepi (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28345 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zfile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zfile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, meth, path");
    {
	guestfs_h *	g;
	char *	meth = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11034 "Guestfs.xs"
      char *r;
#line 28368 "Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zfile(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zfile(): g is not a blessed HV reference");
    };
#line 11036 "Guestfs.xs"
      r = guestfs_zfile (g, meth, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 28388 "Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_zgrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zgrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11050 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 28415 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zgrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zgrep(): g is not a blessed HV reference");
    };
#line 11053 "Guestfs.xs"
      r = guestfs_zgrep (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28439 "Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zgrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zgrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11070 "Guestfs.xs"
      char **r;
      size_t i, n;
#line 28465 "Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zgrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zgrepi(): g is not a blessed HV reference");
    };
#line 11073 "Guestfs.xs"
      r = guestfs_zgrepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28489 "Guestfs.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Sys__Guestfs); /* prototype to pass -Wmissing-prototypes */
XS(boot_Sys__Guestfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Sys::Guestfs::_create", XS_Sys__Guestfs__create, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::DESTROY", XS_Sys__Guestfs_DESTROY, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::close", XS_Sys__Guestfs_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::set_event_callback", XS_Sys__Guestfs_set_event_callback, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::delete_event_callback", XS_Sys__Guestfs_delete_event_callback, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::event_to_string", XS_Sys__Guestfs_event_to_string, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::last_errno", XS_Sys__Guestfs_last_errno, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::acl_delete_def_file", XS_Sys__Guestfs_acl_delete_def_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::acl_get_file", XS_Sys__Guestfs_acl_get_file, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::acl_set_file", XS_Sys__Guestfs_acl_set_file, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::add_cdrom", XS_Sys__Guestfs_add_cdrom, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::add_domain", XS_Sys__Guestfs_add_domain, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::add_drive", XS_Sys__Guestfs_add_drive, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_ro", XS_Sys__Guestfs_add_drive_ro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_ro_with_if", XS_Sys__Guestfs_add_drive_ro_with_if, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_scratch", XS_Sys__Guestfs_add_drive_scratch, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_with_if", XS_Sys__Guestfs_add_drive_with_if, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::add_libvirt_dom", XS_Sys__Guestfs_add_libvirt_dom, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::aug_clear", XS_Sys__Guestfs_aug_clear, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_close", XS_Sys__Guestfs_aug_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::aug_defnode", XS_Sys__Guestfs_aug_defnode, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_defvar", XS_Sys__Guestfs_aug_defvar, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_get", XS_Sys__Guestfs_aug_get, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_init", XS_Sys__Guestfs_aug_init, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_insert", XS_Sys__Guestfs_aug_insert, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_label", XS_Sys__Guestfs_aug_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_load", XS_Sys__Guestfs_aug_load, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::aug_ls", XS_Sys__Guestfs_aug_ls, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_match", XS_Sys__Guestfs_aug_match, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_mv", XS_Sys__Guestfs_aug_mv, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_rm", XS_Sys__Guestfs_aug_rm, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_save", XS_Sys__Guestfs_aug_save, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::aug_set", XS_Sys__Guestfs_aug_set, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_setm", XS_Sys__Guestfs_aug_setm, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::available", XS_Sys__Guestfs_available, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::available_all_groups", XS_Sys__Guestfs_available_all_groups, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::base64_in", XS_Sys__Guestfs_base64_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::base64_out", XS_Sys__Guestfs_base64_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::blkdiscard", XS_Sys__Guestfs_blkdiscard, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blkdiscardzeroes", XS_Sys__Guestfs_blkdiscardzeroes, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blkid", XS_Sys__Guestfs_blkid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_flushbufs", XS_Sys__Guestfs_blockdev_flushbufs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getbsz", XS_Sys__Guestfs_blockdev_getbsz, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getro", XS_Sys__Guestfs_blockdev_getro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getsize64", XS_Sys__Guestfs_blockdev_getsize64, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getss", XS_Sys__Guestfs_blockdev_getss, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getsz", XS_Sys__Guestfs_blockdev_getsz, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_rereadpt", XS_Sys__Guestfs_blockdev_rereadpt, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setbsz", XS_Sys__Guestfs_blockdev_setbsz, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setra", XS_Sys__Guestfs_blockdev_setra, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setro", XS_Sys__Guestfs_blockdev_setro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setrw", XS_Sys__Guestfs_blockdev_setrw, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_cancel", XS_Sys__Guestfs_btrfs_balance_cancel, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_pause", XS_Sys__Guestfs_btrfs_balance_pause, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_resume", XS_Sys__Guestfs_btrfs_balance_resume, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_status", XS_Sys__Guestfs_btrfs_balance_status, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_device_add", XS_Sys__Guestfs_btrfs_device_add, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_device_delete", XS_Sys__Guestfs_btrfs_device_delete, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_balance", XS_Sys__Guestfs_btrfs_filesystem_balance, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_defragment", XS_Sys__Guestfs_btrfs_filesystem_defragment, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_resize", XS_Sys__Guestfs_btrfs_filesystem_resize, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_sync", XS_Sys__Guestfs_btrfs_filesystem_sync, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_fsck", XS_Sys__Guestfs_btrfs_fsck, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_image", XS_Sys__Guestfs_btrfs_image, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_assign", XS_Sys__Guestfs_btrfs_qgroup_assign, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_create", XS_Sys__Guestfs_btrfs_qgroup_create, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_destroy", XS_Sys__Guestfs_btrfs_qgroup_destroy, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_limit", XS_Sys__Guestfs_btrfs_qgroup_limit, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_remove", XS_Sys__Guestfs_btrfs_qgroup_remove, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_show", XS_Sys__Guestfs_btrfs_qgroup_show, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_quota_enable", XS_Sys__Guestfs_btrfs_quota_enable, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_quota_rescan", XS_Sys__Guestfs_btrfs_quota_rescan, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_replace", XS_Sys__Guestfs_btrfs_replace, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_rescue_chunk_recover", XS_Sys__Guestfs_btrfs_rescue_chunk_recover, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_rescue_super_recover", XS_Sys__Guestfs_btrfs_rescue_super_recover, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_cancel", XS_Sys__Guestfs_btrfs_scrub_cancel, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_resume", XS_Sys__Guestfs_btrfs_scrub_resume, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_start", XS_Sys__Guestfs_btrfs_scrub_start, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_status", XS_Sys__Guestfs_btrfs_scrub_status, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_set_seeding", XS_Sys__Guestfs_btrfs_set_seeding, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_create", XS_Sys__Guestfs_btrfs_subvolume_create, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_delete", XS_Sys__Guestfs_btrfs_subvolume_delete, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_get_default", XS_Sys__Guestfs_btrfs_subvolume_get_default, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_list", XS_Sys__Guestfs_btrfs_subvolume_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_set_default", XS_Sys__Guestfs_btrfs_subvolume_set_default, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_show", XS_Sys__Guestfs_btrfs_subvolume_show, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_snapshot", XS_Sys__Guestfs_btrfs_subvolume_snapshot, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfstune_enable_extended_inode_refs", XS_Sys__Guestfs_btrfstune_enable_extended_inode_refs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfstune_enable_skinny_metadata_extent_refs", XS_Sys__Guestfs_btrfstune_enable_skinny_metadata_extent_refs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfstune_seeding", XS_Sys__Guestfs_btrfstune_seeding, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::c_pointer", XS_Sys__Guestfs_c_pointer, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::canonical_device_name", XS_Sys__Guestfs_canonical_device_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::cap_get_file", XS_Sys__Guestfs_cap_get_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::cap_set_file", XS_Sys__Guestfs_cap_set_file, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::case_sensitive_path", XS_Sys__Guestfs_case_sensitive_path, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::cat", XS_Sys__Guestfs_cat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::checksum", XS_Sys__Guestfs_checksum, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::checksum_device", XS_Sys__Guestfs_checksum_device, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::checksums_out", XS_Sys__Guestfs_checksums_out, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::chmod", XS_Sys__Guestfs_chmod, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::chown", XS_Sys__Guestfs_chown, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::clear_backend_setting", XS_Sys__Guestfs_clear_backend_setting, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::command", XS_Sys__Guestfs_command, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::command_lines", XS_Sys__Guestfs_command_lines, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::compress_device_out", XS_Sys__Guestfs_compress_device_out, file, "$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::compress_out", XS_Sys__Guestfs_compress_out, file, "$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::config", XS_Sys__Guestfs_config, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::copy_attributes", XS_Sys__Guestfs_copy_attributes, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_device_to_device", XS_Sys__Guestfs_copy_device_to_device, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_device_to_file", XS_Sys__Guestfs_copy_device_to_file, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_file_to_device", XS_Sys__Guestfs_copy_file_to_device, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_file_to_file", XS_Sys__Guestfs_copy_file_to_file, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_in", XS_Sys__Guestfs_copy_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::copy_out", XS_Sys__Guestfs_copy_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::copy_size", XS_Sys__Guestfs_copy_size, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::cp", XS_Sys__Guestfs_cp, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::cp_a", XS_Sys__Guestfs_cp_a, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::cp_r", XS_Sys__Guestfs_cp_r, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::cpio_out", XS_Sys__Guestfs_cpio_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::dd", XS_Sys__Guestfs_dd, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::debug", XS_Sys__Guestfs_debug, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::debug_drives", XS_Sys__Guestfs_debug_drives, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::debug_upload", XS_Sys__Guestfs_debug_upload, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::device_index", XS_Sys__Guestfs_device_index, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::df", XS_Sys__Guestfs_df, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::df_h", XS_Sys__Guestfs_df_h, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::disk_create", XS_Sys__Guestfs_disk_create, file, "$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::disk_format", XS_Sys__Guestfs_disk_format, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::disk_has_backing_file", XS_Sys__Guestfs_disk_has_backing_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::disk_virtual_size", XS_Sys__Guestfs_disk_virtual_size, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::dmesg", XS_Sys__Guestfs_dmesg, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::download", XS_Sys__Guestfs_download, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::download_offset", XS_Sys__Guestfs_download_offset, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::drop_caches", XS_Sys__Guestfs_drop_caches, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::du", XS_Sys__Guestfs_du, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::e2fsck", XS_Sys__Guestfs_e2fsck, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::e2fsck_f", XS_Sys__Guestfs_e2fsck_f, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::echo_daemon", XS_Sys__Guestfs_echo_daemon, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::egrep", XS_Sys__Guestfs_egrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::egrepi", XS_Sys__Guestfs_egrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::equal", XS_Sys__Guestfs_equal, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::exists", XS_Sys__Guestfs_exists, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::extlinux", XS_Sys__Guestfs_extlinux, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fallocate", XS_Sys__Guestfs_fallocate, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fallocate64", XS_Sys__Guestfs_fallocate64, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::feature_available", XS_Sys__Guestfs_feature_available, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fgrep", XS_Sys__Guestfs_fgrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fgrepi", XS_Sys__Guestfs_fgrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::file", XS_Sys__Guestfs_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::file_architecture", XS_Sys__Guestfs_file_architecture, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::filesize", XS_Sys__Guestfs_filesize, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::filesystem_available", XS_Sys__Guestfs_filesystem_available, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fill", XS_Sys__Guestfs_fill, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::fill_dir", XS_Sys__Guestfs_fill_dir, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fill_pattern", XS_Sys__Guestfs_fill_pattern, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::find", XS_Sys__Guestfs_find, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::find0", XS_Sys__Guestfs_find0, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::findfs_label", XS_Sys__Guestfs_findfs_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::findfs_uuid", XS_Sys__Guestfs_findfs_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fsck", XS_Sys__Guestfs_fsck, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fstrim", XS_Sys__Guestfs_fstrim, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::get_append", XS_Sys__Guestfs_get_append, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_attach_method", XS_Sys__Guestfs_get_attach_method, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_autosync", XS_Sys__Guestfs_get_autosync, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_backend", XS_Sys__Guestfs_get_backend, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_backend_setting", XS_Sys__Guestfs_get_backend_setting, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_backend_settings", XS_Sys__Guestfs_get_backend_settings, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_cachedir", XS_Sys__Guestfs_get_cachedir, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_direct", XS_Sys__Guestfs_get_direct, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2attrs", XS_Sys__Guestfs_get_e2attrs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2generation", XS_Sys__Guestfs_get_e2generation, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2label", XS_Sys__Guestfs_get_e2label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2uuid", XS_Sys__Guestfs_get_e2uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_hv", XS_Sys__Guestfs_get_hv, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credential_challenge", XS_Sys__Guestfs_get_libvirt_requested_credential_challenge, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credential_defresult", XS_Sys__Guestfs_get_libvirt_requested_credential_defresult, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credential_prompt", XS_Sys__Guestfs_get_libvirt_requested_credential_prompt, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credentials", XS_Sys__Guestfs_get_libvirt_requested_credentials, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_memsize", XS_Sys__Guestfs_get_memsize, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_network", XS_Sys__Guestfs_get_network, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_path", XS_Sys__Guestfs_get_path, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_pgroup", XS_Sys__Guestfs_get_pgroup, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_pid", XS_Sys__Guestfs_get_pid, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_program", XS_Sys__Guestfs_get_program, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_qemu", XS_Sys__Guestfs_get_qemu, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_recovery_proc", XS_Sys__Guestfs_get_recovery_proc, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_selinux", XS_Sys__Guestfs_get_selinux, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_smp", XS_Sys__Guestfs_get_smp, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_state", XS_Sys__Guestfs_get_state, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_tmpdir", XS_Sys__Guestfs_get_tmpdir, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_trace", XS_Sys__Guestfs_get_trace, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_umask", XS_Sys__Guestfs_get_umask, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_verbose", XS_Sys__Guestfs_get_verbose, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::getcon", XS_Sys__Guestfs_getcon, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::getxattr", XS_Sys__Guestfs_getxattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::getxattrs", XS_Sys__Guestfs_getxattrs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::glob_expand", XS_Sys__Guestfs_glob_expand, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::grep", XS_Sys__Guestfs_grep, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::grepi", XS_Sys__Guestfs_grepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::grub_install", XS_Sys__Guestfs_grub_install, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::head", XS_Sys__Guestfs_head, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::head_n", XS_Sys__Guestfs_head_n, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hexdump", XS_Sys__Guestfs_hexdump, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_close", XS_Sys__Guestfs_hivex_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_commit", XS_Sys__Guestfs_hivex_commit, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_add_child", XS_Sys__Guestfs_hivex_node_add_child, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_children", XS_Sys__Guestfs_hivex_node_children, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_delete_child", XS_Sys__Guestfs_hivex_node_delete_child, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_get_child", XS_Sys__Guestfs_hivex_node_get_child, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_get_value", XS_Sys__Guestfs_hivex_node_get_value, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_name", XS_Sys__Guestfs_hivex_node_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_parent", XS_Sys__Guestfs_hivex_node_parent, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_set_value", XS_Sys__Guestfs_hivex_node_set_value, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_values", XS_Sys__Guestfs_hivex_node_values, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_open", XS_Sys__Guestfs_hivex_open, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::hivex_root", XS_Sys__Guestfs_hivex_root, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_key", XS_Sys__Guestfs_hivex_value_key, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_type", XS_Sys__Guestfs_hivex_value_type, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_utf8", XS_Sys__Guestfs_hivex_value_utf8, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_value", XS_Sys__Guestfs_hivex_value_value, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::initrd_cat", XS_Sys__Guestfs_initrd_cat, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::initrd_list", XS_Sys__Guestfs_initrd_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_add_watch", XS_Sys__Guestfs_inotify_add_watch, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_close", XS_Sys__Guestfs_inotify_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_files", XS_Sys__Guestfs_inotify_files, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_init", XS_Sys__Guestfs_inotify_init, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_read", XS_Sys__Guestfs_inotify_read, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_rm_watch", XS_Sys__Guestfs_inotify_rm_watch, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_arch", XS_Sys__Guestfs_inspect_get_arch, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_distro", XS_Sys__Guestfs_inspect_get_distro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_drive_mappings", XS_Sys__Guestfs_inspect_get_drive_mappings, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_filesystems", XS_Sys__Guestfs_inspect_get_filesystems, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_format", XS_Sys__Guestfs_inspect_get_format, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_hostname", XS_Sys__Guestfs_inspect_get_hostname, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_icon", XS_Sys__Guestfs_inspect_get_icon, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_major_version", XS_Sys__Guestfs_inspect_get_major_version, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_minor_version", XS_Sys__Guestfs_inspect_get_minor_version, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_mountpoints", XS_Sys__Guestfs_inspect_get_mountpoints, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_package_format", XS_Sys__Guestfs_inspect_get_package_format, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_package_management", XS_Sys__Guestfs_inspect_get_package_management, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_product_name", XS_Sys__Guestfs_inspect_get_product_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_product_variant", XS_Sys__Guestfs_inspect_get_product_variant, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_roots", XS_Sys__Guestfs_inspect_get_roots, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_type", XS_Sys__Guestfs_inspect_get_type, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_windows_current_control_set", XS_Sys__Guestfs_inspect_get_windows_current_control_set, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_windows_systemroot", XS_Sys__Guestfs_inspect_get_windows_systemroot, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_is_live", XS_Sys__Guestfs_inspect_is_live, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_is_multipart", XS_Sys__Guestfs_inspect_is_multipart, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_is_netinst", XS_Sys__Guestfs_inspect_is_netinst, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_list_applications", XS_Sys__Guestfs_inspect_list_applications, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_list_applications2", XS_Sys__Guestfs_inspect_list_applications2, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_os", XS_Sys__Guestfs_inspect_os, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_exit", XS_Sys__Guestfs_internal_exit, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test", XS_Sys__Guestfs_internal_test, file, "$$$$$$$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_63_optargs", XS_Sys__Guestfs_internal_test_63_optargs, file, "$;@");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_close_output", XS_Sys__Guestfs_internal_test_close_output, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_only_optargs", XS_Sys__Guestfs_internal_test_only_optargs, file, "$;@");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rbool", XS_Sys__Guestfs_internal_test_rbool, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rboolerr", XS_Sys__Guestfs_internal_test_rboolerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rbufferout", XS_Sys__Guestfs_internal_test_rbufferout, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rbufferouterr", XS_Sys__Guestfs_internal_test_rbufferouterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconstoptstring", XS_Sys__Guestfs_internal_test_rconstoptstring, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconstoptstringerr", XS_Sys__Guestfs_internal_test_rconstoptstringerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconststring", XS_Sys__Guestfs_internal_test_rconststring, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconststringerr", XS_Sys__Guestfs_internal_test_rconststringerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rhashtable", XS_Sys__Guestfs_internal_test_rhashtable, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rhashtableerr", XS_Sys__Guestfs_internal_test_rhashtableerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rint", XS_Sys__Guestfs_internal_test_rint, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rint64", XS_Sys__Guestfs_internal_test_rint64, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rint64err", XS_Sys__Guestfs_internal_test_rint64err, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rinterr", XS_Sys__Guestfs_internal_test_rinterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstring", XS_Sys__Guestfs_internal_test_rstring, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstringerr", XS_Sys__Guestfs_internal_test_rstringerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstringlist", XS_Sys__Guestfs_internal_test_rstringlist, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstringlisterr", XS_Sys__Guestfs_internal_test_rstringlisterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstruct", XS_Sys__Guestfs_internal_test_rstruct, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstructerr", XS_Sys__Guestfs_internal_test_rstructerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstructlist", XS_Sys__Guestfs_internal_test_rstructlist, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstructlisterr", XS_Sys__Guestfs_internal_test_rstructlisterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_set_output", XS_Sys__Guestfs_internal_test_set_output, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_blockdev", XS_Sys__Guestfs_is_blockdev, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_busy", XS_Sys__Guestfs_is_busy, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_chardev", XS_Sys__Guestfs_is_chardev, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_config", XS_Sys__Guestfs_is_config, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_dir", XS_Sys__Guestfs_is_dir, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_fifo", XS_Sys__Guestfs_is_fifo, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_file", XS_Sys__Guestfs_is_file, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_launching", XS_Sys__Guestfs_is_launching, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_lv", XS_Sys__Guestfs_is_lv, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_ready", XS_Sys__Guestfs_is_ready, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_socket", XS_Sys__Guestfs_is_socket, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_symlink", XS_Sys__Guestfs_is_symlink, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_whole_device", XS_Sys__Guestfs_is_whole_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_zero", XS_Sys__Guestfs_is_zero, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_zero_device", XS_Sys__Guestfs_is_zero_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::isoinfo", XS_Sys__Guestfs_isoinfo, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::isoinfo_device", XS_Sys__Guestfs_isoinfo_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::journal_close", XS_Sys__Guestfs_journal_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_get", XS_Sys__Guestfs_journal_get, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_get_data_threshold", XS_Sys__Guestfs_journal_get_data_threshold, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_get_realtime_usec", XS_Sys__Guestfs_journal_get_realtime_usec, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_next", XS_Sys__Guestfs_journal_next, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_open", XS_Sys__Guestfs_journal_open, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::journal_set_data_threshold", XS_Sys__Guestfs_journal_set_data_threshold, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::journal_skip", XS_Sys__Guestfs_journal_skip, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::kill_subprocess", XS_Sys__Guestfs_kill_subprocess, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::launch", XS_Sys__Guestfs_launch, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lchown", XS_Sys__Guestfs_lchown, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_create_all", XS_Sys__Guestfs_ldmtool_create_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_diskgroup_disks", XS_Sys__Guestfs_ldmtool_diskgroup_disks, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_diskgroup_name", XS_Sys__Guestfs_ldmtool_diskgroup_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_diskgroup_volumes", XS_Sys__Guestfs_ldmtool_diskgroup_volumes, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_remove_all", XS_Sys__Guestfs_ldmtool_remove_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_scan", XS_Sys__Guestfs_ldmtool_scan, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_scan_devices", XS_Sys__Guestfs_ldmtool_scan_devices, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_volume_hint", XS_Sys__Guestfs_ldmtool_volume_hint, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_volume_partitions", XS_Sys__Guestfs_ldmtool_volume_partitions, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_volume_type", XS_Sys__Guestfs_ldmtool_volume_type, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lgetxattr", XS_Sys__Guestfs_lgetxattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lgetxattrs", XS_Sys__Guestfs_lgetxattrs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::list_9p", XS_Sys__Guestfs_list_9p, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_devices", XS_Sys__Guestfs_list_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_disk_labels", XS_Sys__Guestfs_list_disk_labels, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_dm_devices", XS_Sys__Guestfs_list_dm_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_filesystems", XS_Sys__Guestfs_list_filesystems, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_ldm_partitions", XS_Sys__Guestfs_list_ldm_partitions, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_ldm_volumes", XS_Sys__Guestfs_list_ldm_volumes, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_md_devices", XS_Sys__Guestfs_list_md_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_partitions", XS_Sys__Guestfs_list_partitions, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ll", XS_Sys__Guestfs_ll, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::llz", XS_Sys__Guestfs_llz, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ln", XS_Sys__Guestfs_ln, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ln_f", XS_Sys__Guestfs_ln_f, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ln_s", XS_Sys__Guestfs_ln_s, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ln_sf", XS_Sys__Guestfs_ln_sf, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lremovexattr", XS_Sys__Guestfs_lremovexattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ls", XS_Sys__Guestfs_ls, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ls0", XS_Sys__Guestfs_ls0, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lsetxattr", XS_Sys__Guestfs_lsetxattr, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lstat", XS_Sys__Guestfs_lstat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lstatlist", XS_Sys__Guestfs_lstatlist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lstatns", XS_Sys__Guestfs_lstatns, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lstatnslist", XS_Sys__Guestfs_lstatnslist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_add_key", XS_Sys__Guestfs_luks_add_key, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_close", XS_Sys__Guestfs_luks_close, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_format", XS_Sys__Guestfs_luks_format, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_format_cipher", XS_Sys__Guestfs_luks_format_cipher, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_kill_slot", XS_Sys__Guestfs_luks_kill_slot, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_open", XS_Sys__Guestfs_luks_open, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_open_ro", XS_Sys__Guestfs_luks_open_ro, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvcreate", XS_Sys__Guestfs_lvcreate, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvcreate_free", XS_Sys__Guestfs_lvcreate_free, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_canonical_lv_name", XS_Sys__Guestfs_lvm_canonical_lv_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_clear_filter", XS_Sys__Guestfs_lvm_clear_filter, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_remove_all", XS_Sys__Guestfs_lvm_remove_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_set_filter", XS_Sys__Guestfs_lvm_set_filter, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lvremove", XS_Sys__Guestfs_lvremove, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lvrename", XS_Sys__Guestfs_lvrename, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvresize", XS_Sys__Guestfs_lvresize, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvresize_free", XS_Sys__Guestfs_lvresize_free, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvs", XS_Sys__Guestfs_lvs, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvs_full", XS_Sys__Guestfs_lvs_full, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvuuid", XS_Sys__Guestfs_lvuuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lxattrlist", XS_Sys__Guestfs_lxattrlist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::max_disks", XS_Sys__Guestfs_max_disks, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::md_create", XS_Sys__Guestfs_md_create, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::md_detail", XS_Sys__Guestfs_md_detail, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::md_stat", XS_Sys__Guestfs_md_stat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::md_stop", XS_Sys__Guestfs_md_stop, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdir", XS_Sys__Guestfs_mkdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdir_mode", XS_Sys__Guestfs_mkdir_mode, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdir_p", XS_Sys__Guestfs_mkdir_p, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdtemp", XS_Sys__Guestfs_mkdtemp, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs", XS_Sys__Guestfs_mke2fs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs_J", XS_Sys__Guestfs_mke2fs_J, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs_JL", XS_Sys__Guestfs_mke2fs_JL, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs_JU", XS_Sys__Guestfs_mke2fs_JU, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2journal", XS_Sys__Guestfs_mke2journal, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2journal_L", XS_Sys__Guestfs_mke2journal_L, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2journal_U", XS_Sys__Guestfs_mke2journal_U, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkfifo", XS_Sys__Guestfs_mkfifo, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkfs", XS_Sys__Guestfs_mkfs, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mkfs_b", XS_Sys__Guestfs_mkfs_b, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkfs_btrfs", XS_Sys__Guestfs_mkfs_btrfs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mklost_and_found", XS_Sys__Guestfs_mklost_and_found, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkmountpoint", XS_Sys__Guestfs_mkmountpoint, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mknod", XS_Sys__Guestfs_mknod, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mknod_b", XS_Sys__Guestfs_mknod_b, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mknod_c", XS_Sys__Guestfs_mknod_c, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkswap", XS_Sys__Guestfs_mkswap, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mkswap_L", XS_Sys__Guestfs_mkswap_L, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkswap_U", XS_Sys__Guestfs_mkswap_U, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkswap_file", XS_Sys__Guestfs_mkswap_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mktemp", XS_Sys__Guestfs_mktemp, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::modprobe", XS_Sys__Guestfs_modprobe, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mount", XS_Sys__Guestfs_mount, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_9p", XS_Sys__Guestfs_mount_9p, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mount_local", XS_Sys__Guestfs_mount_local, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mount_local_run", XS_Sys__Guestfs_mount_local_run, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::mount_loop", XS_Sys__Guestfs_mount_loop, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_options", XS_Sys__Guestfs_mount_options, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_ro", XS_Sys__Guestfs_mount_ro, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_vfs", XS_Sys__Guestfs_mount_vfs, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mountpoints", XS_Sys__Guestfs_mountpoints, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::mounts", XS_Sys__Guestfs_mounts, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::mv", XS_Sys__Guestfs_mv, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::nr_devices", XS_Sys__Guestfs_nr_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ntfs_3g_probe", XS_Sys__Guestfs_ntfs_3g_probe, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ntfsclone_in", XS_Sys__Guestfs_ntfsclone_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ntfsclone_out", XS_Sys__Guestfs_ntfsclone_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::ntfsfix", XS_Sys__Guestfs_ntfsfix, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::ntfsresize", XS_Sys__Guestfs_ntfsresize, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::ntfsresize_size", XS_Sys__Guestfs_ntfsresize_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::parse_environment", XS_Sys__Guestfs_parse_environment, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::parse_environment_list", XS_Sys__Guestfs_parse_environment_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_add", XS_Sys__Guestfs_part_add, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_del", XS_Sys__Guestfs_part_del, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_disk", XS_Sys__Guestfs_part_disk, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_bootable", XS_Sys__Guestfs_part_get_bootable, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_gpt_guid", XS_Sys__Guestfs_part_get_gpt_guid, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_gpt_type", XS_Sys__Guestfs_part_get_gpt_type, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_mbr_id", XS_Sys__Guestfs_part_get_mbr_id, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_mbr_part_type", XS_Sys__Guestfs_part_get_mbr_part_type, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_name", XS_Sys__Guestfs_part_get_name, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_parttype", XS_Sys__Guestfs_part_get_parttype, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_init", XS_Sys__Guestfs_part_init, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_list", XS_Sys__Guestfs_part_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_bootable", XS_Sys__Guestfs_part_set_bootable, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_gpt_guid", XS_Sys__Guestfs_part_set_gpt_guid, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_gpt_type", XS_Sys__Guestfs_part_set_gpt_type, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_mbr_id", XS_Sys__Guestfs_part_set_mbr_id, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_name", XS_Sys__Guestfs_part_set_name, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_to_dev", XS_Sys__Guestfs_part_to_dev, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_to_partnum", XS_Sys__Guestfs_part_to_partnum, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ping_daemon", XS_Sys__Guestfs_ping_daemon, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pread", XS_Sys__Guestfs_pread, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::pread_device", XS_Sys__Guestfs_pread_device, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::pvchange_uuid", XS_Sys__Guestfs_pvchange_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvchange_uuid_all", XS_Sys__Guestfs_pvchange_uuid_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pvcreate", XS_Sys__Guestfs_pvcreate, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvremove", XS_Sys__Guestfs_pvremove, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvresize", XS_Sys__Guestfs_pvresize, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvresize_size", XS_Sys__Guestfs_pvresize_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::pvs", XS_Sys__Guestfs_pvs, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pvs_full", XS_Sys__Guestfs_pvs_full, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pvuuid", XS_Sys__Guestfs_pvuuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pwrite", XS_Sys__Guestfs_pwrite, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::pwrite_device", XS_Sys__Guestfs_pwrite_device, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::read_file", XS_Sys__Guestfs_read_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::read_lines", XS_Sys__Guestfs_read_lines, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::readdir", XS_Sys__Guestfs_readdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::readlink", XS_Sys__Guestfs_readlink, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::readlinklist", XS_Sys__Guestfs_readlinklist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::realpath", XS_Sys__Guestfs_realpath, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::remount", XS_Sys__Guestfs_remount, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::remove_drive", XS_Sys__Guestfs_remove_drive, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::removexattr", XS_Sys__Guestfs_removexattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::rename", XS_Sys__Guestfs_rename, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::resize2fs", XS_Sys__Guestfs_resize2fs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::resize2fs_M", XS_Sys__Guestfs_resize2fs_M, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::resize2fs_size", XS_Sys__Guestfs_resize2fs_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::rm", XS_Sys__Guestfs_rm, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rm_f", XS_Sys__Guestfs_rm_f, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rm_rf", XS_Sys__Guestfs_rm_rf, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rmdir", XS_Sys__Guestfs_rmdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rmmountpoint", XS_Sys__Guestfs_rmmountpoint, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rsync", XS_Sys__Guestfs_rsync, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::rsync_in", XS_Sys__Guestfs_rsync_in, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::rsync_out", XS_Sys__Guestfs_rsync_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::scrub_device", XS_Sys__Guestfs_scrub_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::scrub_file", XS_Sys__Guestfs_scrub_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::scrub_freespace", XS_Sys__Guestfs_scrub_freespace, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_append", XS_Sys__Guestfs_set_append, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_attach_method", XS_Sys__Guestfs_set_attach_method, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_autosync", XS_Sys__Guestfs_set_autosync, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_backend", XS_Sys__Guestfs_set_backend, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_backend_setting", XS_Sys__Guestfs_set_backend_setting, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_backend_settings", XS_Sys__Guestfs_set_backend_settings, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_cachedir", XS_Sys__Guestfs_set_cachedir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_direct", XS_Sys__Guestfs_set_direct, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_e2attrs", XS_Sys__Guestfs_set_e2attrs, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::set_e2generation", XS_Sys__Guestfs_set_e2generation, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_e2label", XS_Sys__Guestfs_set_e2label, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_e2uuid", XS_Sys__Guestfs_set_e2uuid, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_hv", XS_Sys__Guestfs_set_hv, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_label", XS_Sys__Guestfs_set_label, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_libvirt_requested_credential", XS_Sys__Guestfs_set_libvirt_requested_credential, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_libvirt_supported_credentials", XS_Sys__Guestfs_set_libvirt_supported_credentials, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_memsize", XS_Sys__Guestfs_set_memsize, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_network", XS_Sys__Guestfs_set_network, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_path", XS_Sys__Guestfs_set_path, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_pgroup", XS_Sys__Guestfs_set_pgroup, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_program", XS_Sys__Guestfs_set_program, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_qemu", XS_Sys__Guestfs_set_qemu, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_recovery_proc", XS_Sys__Guestfs_set_recovery_proc, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_selinux", XS_Sys__Guestfs_set_selinux, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_smp", XS_Sys__Guestfs_set_smp, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_tmpdir", XS_Sys__Guestfs_set_tmpdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_trace", XS_Sys__Guestfs_set_trace, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_uuid", XS_Sys__Guestfs_set_uuid, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_uuid_random", XS_Sys__Guestfs_set_uuid_random, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_verbose", XS_Sys__Guestfs_set_verbose, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::setcon", XS_Sys__Guestfs_setcon, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::setxattr", XS_Sys__Guestfs_setxattr, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk", XS_Sys__Guestfs_sfdisk, file, "$$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdiskM", XS_Sys__Guestfs_sfdiskM, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_N", XS_Sys__Guestfs_sfdisk_N, file, "$$$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_disk_geometry", XS_Sys__Guestfs_sfdisk_disk_geometry, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_kernel_geometry", XS_Sys__Guestfs_sfdisk_kernel_geometry, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_l", XS_Sys__Guestfs_sfdisk_l, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sh", XS_Sys__Guestfs_sh, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sh_lines", XS_Sys__Guestfs_sh_lines, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::shutdown", XS_Sys__Guestfs_shutdown, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::sleep", XS_Sys__Guestfs_sleep, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::stat", XS_Sys__Guestfs_stat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::statns", XS_Sys__Guestfs_statns, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::statvfs", XS_Sys__Guestfs_statvfs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::strings", XS_Sys__Guestfs_strings, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::strings_e", XS_Sys__Guestfs_strings_e, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_device", XS_Sys__Guestfs_swapoff_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_file", XS_Sys__Guestfs_swapoff_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_label", XS_Sys__Guestfs_swapoff_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_uuid", XS_Sys__Guestfs_swapoff_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_device", XS_Sys__Guestfs_swapon_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_file", XS_Sys__Guestfs_swapon_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_label", XS_Sys__Guestfs_swapon_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_uuid", XS_Sys__Guestfs_swapon_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sync", XS_Sys__Guestfs_sync, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::syslinux", XS_Sys__Guestfs_syslinux, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tail", XS_Sys__Guestfs_tail, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::tail_n", XS_Sys__Guestfs_tail_n, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::tar_in", XS_Sys__Guestfs_tar_in, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tar_out", XS_Sys__Guestfs_tar_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tgz_in", XS_Sys__Guestfs_tgz_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::tgz_out", XS_Sys__Guestfs_tgz_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::touch", XS_Sys__Guestfs_touch, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::truncate", XS_Sys__Guestfs_truncate, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::truncate_size", XS_Sys__Guestfs_truncate_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::tune2fs", XS_Sys__Guestfs_tune2fs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tune2fs_l", XS_Sys__Guestfs_tune2fs_l, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::txz_in", XS_Sys__Guestfs_txz_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::txz_out", XS_Sys__Guestfs_txz_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::umask", XS_Sys__Guestfs_umask, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::umount", XS_Sys__Guestfs_umount, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::umount_all", XS_Sys__Guestfs_umount_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::umount_local", XS_Sys__Guestfs_umount_local, file, "$;@");
        (void)newXSproto_portable("Sys::Guestfs::upload", XS_Sys__Guestfs_upload, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::upload_offset", XS_Sys__Guestfs_upload_offset, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::user_cancel", XS_Sys__Guestfs_user_cancel, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::utimens", XS_Sys__Guestfs_utimens, file, "$$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::utsname", XS_Sys__Guestfs_utsname, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::version", XS_Sys__Guestfs_version, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_label", XS_Sys__Guestfs_vfs_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_type", XS_Sys__Guestfs_vfs_type, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_uuid", XS_Sys__Guestfs_vfs_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vg_activate", XS_Sys__Guestfs_vg_activate, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::vg_activate_all", XS_Sys__Guestfs_vg_activate_all, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgchange_uuid", XS_Sys__Guestfs_vgchange_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgchange_uuid_all", XS_Sys__Guestfs_vgchange_uuid_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vgcreate", XS_Sys__Guestfs_vgcreate, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::vglvuuids", XS_Sys__Guestfs_vglvuuids, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgmeta", XS_Sys__Guestfs_vgmeta, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgpvuuids", XS_Sys__Guestfs_vgpvuuids, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgremove", XS_Sys__Guestfs_vgremove, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgrename", XS_Sys__Guestfs_vgrename, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::vgs", XS_Sys__Guestfs_vgs, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vgs_full", XS_Sys__Guestfs_vgs_full, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vgscan", XS_Sys__Guestfs_vgscan, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vguuid", XS_Sys__Guestfs_vguuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wait_ready", XS_Sys__Guestfs_wait_ready, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::wc_c", XS_Sys__Guestfs_wc_c, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wc_l", XS_Sys__Guestfs_wc_l, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wc_w", XS_Sys__Guestfs_wc_w, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wipefs", XS_Sys__Guestfs_wipefs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::write", XS_Sys__Guestfs_write, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::write_append", XS_Sys__Guestfs_write_append, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::write_file", XS_Sys__Guestfs_write_file, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::xfs_admin", XS_Sys__Guestfs_xfs_admin, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::xfs_growfs", XS_Sys__Guestfs_xfs_growfs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::xfs_info", XS_Sys__Guestfs_xfs_info, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::xfs_repair", XS_Sys__Guestfs_xfs_repair, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::zegrep", XS_Sys__Guestfs_zegrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zegrepi", XS_Sys__Guestfs_zegrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zero", XS_Sys__Guestfs_zero, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zero_device", XS_Sys__Guestfs_zero_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zero_free_space", XS_Sys__Guestfs_zero_free_space, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zerofree", XS_Sys__Guestfs_zerofree, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zfgrep", XS_Sys__Guestfs_zfgrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zfgrepi", XS_Sys__Guestfs_zfgrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zfile", XS_Sys__Guestfs_zfile, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zgrep", XS_Sys__Guestfs_zgrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zgrepi", XS_Sys__Guestfs_zgrepi, file, "$$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

