/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Guestfs.xs. Do not edit this file, edit Guestfs.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Sys/Guestfs.xs"
/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED FROM:
 *   generator/ *.ml
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009-2015 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <config.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <errno.h>

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* perl CORE/config.h defines '_' to something completely bonkers. */
#ifdef _
#undef _
#endif

#include <guestfs.h>
#include "guestfs-internal-frontend.h"

static SV *
my_newSVll(long long val) {
#ifdef USE_64_BIT_ALL
  return newSViv(val);
#else
  char buf[100];
  int len;
  len = snprintf(buf, 100, "%" PRId64, val);
  return newSVpv(buf, len);
#endif
}

static SV *
my_newSVull(unsigned long long val) {
#ifdef USE_64_BIT_ALL
  return newSVuv(val);
#else
  char buf[100];
  int len;
  len = snprintf(buf, 100, "%" PRIu64, val);
  return newSVpv(buf, len);
#endif
}

/* Convert a 64 bit int on input.  To cope with the case of having
 * a 32 bit Perl interpreter, we allow the user to pass a string
 * here which is scanned as a 64 bit integer.
 */
static int64_t
my_SvIV64 (SV *sv)
{
#ifdef USE_64_BIT_ALL
  return SvIV (sv);
#else
  if (SvTYPE (sv) == SVt_PV) {
    const char *str = SvPV_nolen (sv);
    int64_t r;

    sscanf (str, "%" SCNi64, &r);
    return r;
  }
  else
    return SvIV (sv);
#endif
}

/* http://www.perlmonks.org/?node_id=680842 */
static char **
XS_unpack_charPtrPtr (SV *arg) {
  char **ret;
  AV *av;
  I32 i;

  if (!arg || !SvOK (arg) || !SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
    croak ("array reference expected");

  av = (AV *)SvRV (arg);
  ret = malloc ((av_len (av) + 1 + 1) * sizeof (char *));
  if (!ret)
    croak ("malloc failed");

  for (i = 0; i <= av_len (av); i++) {
    SV **elem = av_fetch (av, i, 0);

    if (!elem || !*elem)
      croak ("missing element in list");

    ret[i] = SvPV_nolen (*elem);
  }

  ret[i] = NULL;

  return ret;
}

/* http://www.perlmonks.org/?node=338857 */
static void
_event_callback_wrapper (guestfs_h *g,
                         void *cb,
                         uint64_t event,
                         int event_handle,
                         int flags,
                         const char *buf, size_t buf_len,
                         const uint64_t *array, size_t array_len)
{
  dSP;
  ENTER;
  SAVETMPS;
  PUSHMARK (SP);
  XPUSHs (sv_2mortal (my_newSVull (event)));
  XPUSHs (sv_2mortal (newSViv (event_handle)));
  XPUSHs (sv_2mortal (newSVpvn (buf ? buf : "", buf_len)));
  AV *av = newAV ();
  size_t i;
  for (i = 0; i < array_len; ++i)
    av_push (av, my_newSVull (array[i]));
  XPUSHs (sv_2mortal (newRV ((SV *) av)));
  PUTBACK;
  call_sv ((SV *) cb, G_VOID | G_DISCARD | G_EVAL);
  FREETMPS;
  LEAVE;
}

static SV **
get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
{
  SV **r;
  size_t i;
  const char *key;
  SV *cb;

  /* Count the length of the array that will be needed. */
  *len_rtn = 0;
  cb = guestfs_first_private (g, &key);
  while (cb != NULL) {
    if (strncmp (key, "_perl_event_", strlen ("_perl_event_")) == 0)
      (*len_rtn)++;
    cb = guestfs_next_private (g, &key);
  }

  /* Copy them into the return array. */
  r = guestfs_int_safe_malloc (g, sizeof (SV *) * (*len_rtn));

  i = 0;
  cb = guestfs_first_private (g, &key);
  while (cb != NULL) {
    if (strncmp (key, "_perl_event_", strlen ("_perl_event_")) == 0) {
      r[i] = cb;
      i++;
    }
    cb = guestfs_next_private (g, &key);
  }

  return r;
}

static void
_close_handle (guestfs_h *g)
{
  size_t i, len;
  SV **cbs;

  assert (g != NULL);

  /* As in the OCaml bindings, there is a hard to solve case where the
   * caller can delete a callback from within the callback, resulting
   * in a double-free here.  XXX
   */
  cbs = get_all_event_callbacks (g, &len);

  guestfs_close (g);

  for (i = 0; i < len; ++i)
    SvREFCNT_dec (cbs[i]);
  free (cbs);
}

#line 210 "lib/Sys/Guestfs.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 262 "lib/Sys/Guestfs.c"

XS(XS_Sys__Guestfs__create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs__create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "flags");
    {
	unsigned	flags = (unsigned)SvUV(ST(0));
	guestfs_h *	RETVAL;
	dXSTARG;
#line 208 "lib/Sys/Guestfs.xs"
      RETVAL = guestfs_create_flags (flags);
      if (!RETVAL)
        croak ("could not create guestfs handle");
      guestfs_set_error_handler (RETVAL, NULL, NULL);
#line 283 "lib/Sys/Guestfs.c"
	XSprePUSH; PUSHi(PTR2IV (RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0);
#line 219 "lib/Sys/Guestfs.xs"
      /* For the 'g' argument above we do the conversion explicitly and
       * don't rely on the typemap, because if the handle has been
       * explicitly closed we don't want the typemap conversion to
       * display an error.
       */
      HV *hv = (HV *) SvRV (sv);
      SV **svp = hv_fetch (hv, "_g", 2, 0);
      if (svp != NULL) {
        guestfs_h *g = (guestfs_h *) SvIV (*svp);
        _close_handle (g);
      }
#line 316 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::close(): g is not a blessed HV reference");
    };
#line 235 "lib/Sys/Guestfs.xs"
      _close_handle (g);
      /* Avoid double-free in DESTROY method. */
      HV *hv = (HV *) SvRV (ST(0));
      (void) hv_delete (hv, "_g", 2, G_DISCARD);
#line 354 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_event_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_event_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, cb, event_bitmask");
    {
	guestfs_h *	g;
	SV *	cb = ST(1);
	int	event_bitmask = (int)SvIV(ST(2));
#line 246 "lib/Sys/Guestfs.xs"
      int eh;
      char key[64];
#line 378 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_event_callback(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_event_callback(): g is not a blessed HV reference");
    };
#line 249 "lib/Sys/Guestfs.xs"
      eh = guestfs_set_event_callback (g, _event_callback_wrapper,
                                       event_bitmask, 0, cb);
      if (eh == -1)
        croak ("%s", guestfs_last_error (g));

      /* Increase the refcount for this callback, since we are storing
       * it in the opaque C libguestfs handle.  We need to remember that
       * we did this, so we can decrease the refcount for all undeleted
       * callbacks left around at close time (see _close_handle).
       */
      SvREFCNT_inc (cb);

      snprintf (key, sizeof key, "_perl_event_%d", eh);
      guestfs_set_private (g, key, cb);

      RETVAL = newSViv (eh);
#line 409 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_delete_event_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_delete_event_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, event_handle");
    {
	guestfs_h *	g;
	int	event_handle = (int)SvIV(ST(1));
#line 273 "lib/Sys/Guestfs.xs"
      char key[64];
      SV *cb;
#line 433 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::delete_event_callback(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::delete_event_callback(): g is not a blessed HV reference");
    };
#line 276 "lib/Sys/Guestfs.xs"
      snprintf (key, sizeof key, "_perl_event_%d", event_handle);
      cb = guestfs_get_private (g, key);
      if (cb) {
        SvREFCNT_dec (cb);
        guestfs_set_private (g, key, NULL);
        guestfs_delete_event_callback (g, event_handle);
      }
#line 454 "lib/Sys/Guestfs.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Sys__Guestfs_event_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_event_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "event_bitmask");
    {
	int	event_bitmask = (int)SvIV(ST(0));
#line 288 "lib/Sys/Guestfs.xs"
      char *str;
#line 474 "lib/Sys/Guestfs.c"
	SV *	RETVAL;
#line 290 "lib/Sys/Guestfs.xs"
      str = guestfs_event_to_string (event_bitmask);
      if (str == NULL)
        croak ("%s", strerror (errno));
      RETVAL = newSVpv (str, 0);
      free (str);
#line 482 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_last_errno); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_last_errno)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 302 "lib/Sys/Guestfs.xs"
      int errnum;
#line 504 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::last_errno(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::last_errno(): g is not a blessed HV reference");
    };
#line 304 "lib/Sys/Guestfs.xs"
      errnum = guestfs_last_errno (g);
      RETVAL = newSViv (errnum);
#line 521 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_acl_delete_def_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_acl_delete_def_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
#line 314 "lib/Sys/Guestfs.xs"
      int r;
#line 546 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::acl_delete_def_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::acl_delete_def_file(): g is not a blessed HV reference");
    };
#line 316 "lib/Sys/Guestfs.xs"
      r = guestfs_acl_delete_def_file (g, dir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 563 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_acl_get_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_acl_get_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, acltype");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	acltype = (char *)SvPV_nolen(ST(2));
#line 326 "lib/Sys/Guestfs.xs"
      char *r;
#line 586 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::acl_get_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::acl_get_file(): g is not a blessed HV reference");
    };
#line 328 "lib/Sys/Guestfs.xs"
      r = guestfs_acl_get_file (g, path, acltype);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 606 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_acl_set_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_acl_set_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, acltype, acl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	acltype = (char *)SvPV_nolen(ST(2));
	char *	acl = (char *)SvPV_nolen(ST(3));
#line 343 "lib/Sys/Guestfs.xs"
      int r;
#line 633 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::acl_set_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::acl_set_file(): g is not a blessed HV reference");
    };
#line 345 "lib/Sys/Guestfs.xs"
      r = guestfs_acl_set_file (g, path, acltype, acl);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 650 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_cdrom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_cdrom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 354 "lib/Sys/Guestfs.xs"
      int r;
#line 674 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_cdrom(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_cdrom(): g is not a blessed HV reference");
    };
#line 356 "lib/Sys/Guestfs.xs"
      r = guestfs_add_cdrom (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 691 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_domain); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_domain)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, dom, ...");
    {
	guestfs_h *	g;
	char *	dom = (char *)SvPV_nolen(ST(1));
#line 365 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_add_domain_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_domain_argv *optargs = &optargs_s;
      size_t items_i;
#line 716 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_domain(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_domain(): g is not a blessed HV reference");
    };
#line 370 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "libvirturi")) {
          optargs_s.libvirturi = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_LIBVIRTURI_BITMASK;
        }
        else if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "iface")) {
          optargs_s.iface = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_IFACE_BITMASK;
        }
        else if (STREQ (this_arg, "live")) {
          optargs_s.live = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_LIVE_BITMASK;
        }
        else if (STREQ (this_arg, "allowuuid")) {
          optargs_s.allowuuid = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_ALLOWUUID_BITMASK;
        }
        else if (STREQ (this_arg, "readonlydisk")) {
          optargs_s.readonlydisk = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_READONLYDISK_BITMASK;
        }
        else if (STREQ (this_arg, "cachemode")) {
          optargs_s.cachemode = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_CACHEMODE_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "copyonread")) {
          optargs_s.copyonread = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DOMAIN_COPYONREAD_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_domain_argv (g, dom, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 785 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_add_drive); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, filename, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 432 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_add_drive_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_drive_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 813 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive(): g is not a blessed HV reference");
    };
#line 437 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "format")) {
          optargs_s.format = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK;
        }
        else if (STREQ (this_arg, "iface")) {
          optargs_s.iface = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_IFACE_BITMASK;
        }
        else if (STREQ (this_arg, "name")) {
          optargs_s.name = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_NAME_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "protocol")) {
          optargs_s.protocol = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_PROTOCOL_BITMASK;
        }
        else if (STREQ (this_arg, "server")) {
          size_t i, len;
          char **r;
          SV *arg;
          AV *av;
          SV **svp;

          arg = ST (items_i+1);
          if (!SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
            croak ("array reference expected for '%s' argument", "server");
          av = (AV *) SvRV (ST (items_i+1));

          /* Note av_len returns index of final element. */
          len = av_len (av) + 1;

          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));
          for (i = 0; i < len; ++i) {
            svp = av_fetch (av, i, 0);
            r[i] = SvPV_nolen (*svp);
          }
          r[i] = NULL;
          optargs_s.server = r;
          this_mask = GUESTFS_ADD_DRIVE_OPTS_SERVER_BITMASK;
        }
        else if (STREQ (this_arg, "username")) {
          optargs_s.username = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_USERNAME_BITMASK;
        }
        else if (STREQ (this_arg, "secret")) {
          optargs_s.secret = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_SECRET_BITMASK;
        }
        else if (STREQ (this_arg, "cachemode")) {
          optargs_s.cachemode = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_CACHEMODE_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "copyonread")) {
          optargs_s.copyonread = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_OPTS_COPYONREAD_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_drive_opts_argv (g, filename, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 912 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_ro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_ro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 528 "lib/Sys/Guestfs.xs"
      int r;
#line 936 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_ro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_ro(): g is not a blessed HV reference");
    };
#line 530 "lib/Sys/Guestfs.xs"
      r = guestfs_add_drive_ro (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 953 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_ro_with_if); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_ro_with_if)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, iface");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	iface = (char *)SvPV_nolen(ST(2));
#line 540 "lib/Sys/Guestfs.xs"
      int r;
#line 978 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_ro_with_if(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_ro_with_if(): g is not a blessed HV reference");
    };
#line 542 "lib/Sys/Guestfs.xs"
      r = guestfs_add_drive_ro_with_if (g, filename, iface);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 995 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_scratch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_scratch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, size, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    size = my_SvIV64 (ST(1));
#line 551 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_add_drive_scratch_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_drive_scratch_argv *optargs = &optargs_s;
      size_t items_i;
#line 1022 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_scratch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_scratch(): g is not a blessed HV reference");
    };
#line 556 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "name")) {
          optargs_s.name = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_SCRATCH_NAME_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_DRIVE_SCRATCH_LABEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_drive_scratch_argv (g, size, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1061 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_drive_with_if); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_drive_with_if)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, iface");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	iface = (char *)SvPV_nolen(ST(2));
#line 588 "lib/Sys/Guestfs.xs"
      int r;
#line 1086 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_drive_with_if(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_drive_with_if(): g is not a blessed HV reference");
    };
#line 590 "lib/Sys/Guestfs.xs"
      r = guestfs_add_drive_with_if (g, filename, iface);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1103 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_add_libvirt_dom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_add_libvirt_dom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, dom, ...");
    {
	guestfs_h *	g;
	void * /* virDomainPtr */	dom;
#line 599 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_add_libvirt_dom_argv optargs_s = { .bitmask = 0 };
      struct guestfs_add_libvirt_dom_argv *optargs = &optargs_s;
      size_t items_i;
#line 1128 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::add_libvirt_dom(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::add_libvirt_dom(): g is not a blessed HV reference");
    };

    /* This is copied directly from the Sys::Virt typemap.  Dan has assured
     * me that he doesn't intend to change this implementation!
     */
    if (sv_isobject (ST(1)) && SvTYPE (SvRV (ST(1))) == SVt_PVMG)
        dom = INT2PTR (void *, SvIV ((SV*) SvRV (ST(1))));
    else {
        warn ("Sys::Guestfs::add_libvirt_dom() -- dom is not a blessed SV reference");
        XSRETURN_UNDEF;
    };
#line 604 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "iface")) {
          optargs_s.iface = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_IFACE_BITMASK;
        }
        else if (STREQ (this_arg, "live")) {
          optargs_s.live = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_LIVE_BITMASK;
        }
        else if (STREQ (this_arg, "readonlydisk")) {
          optargs_s.readonlydisk = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_READONLYDISK_BITMASK;
        }
        else if (STREQ (this_arg, "cachemode")) {
          optargs_s.cachemode = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_CACHEMODE_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "copyonread")) {
          optargs_s.copyonread = SvIV (ST (items_i+1));
          this_mask = GUESTFS_ADD_LIBVIRT_DOM_COPYONREAD_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_add_libvirt_dom_argv (g, dom, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1199 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_clear); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_clear)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 658 "lib/Sys/Guestfs.xs"
      int r;
#line 1224 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_clear(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_clear(): g is not a blessed HV reference");
    };
#line 660 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_clear (g, augpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1241 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 668 "lib/Sys/Guestfs.xs"
      int r;
#line 1264 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_close(): g is not a blessed HV reference");
    };
#line 670 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1281 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_defnode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_defnode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, name, expr, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char *	expr = (char *)SvPV_nolen(ST(2));
	char *	val = (char *)SvPV_nolen(ST(3));
#line 681 "lib/Sys/Guestfs.xs"
      struct guestfs_int_bool *r;
#line 1307 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_defnode(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_defnode(): g is not a blessed HV reference");
    };
#line 683 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_defnode (g, name, expr, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 2);
      PUSHs (sv_2mortal (newSVpv ("i", 0)));
      PUSHs (sv_2mortal (newSVnv (r->i)));
      PUSHs (sv_2mortal (newSVpv ("b", 0)));
      PUSHs (sv_2mortal (newSVnv (r->b)));
      free (r);
#line 1330 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_defvar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_defvar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, name, expr");
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char *	expr = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
#line 699 "lib/Sys/Guestfs.xs"
      int r;
#line 1353 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_defvar(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_defvar(): g is not a blessed HV reference");
    };
#line 701 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_defvar (g, name, expr);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1372 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 713 "lib/Sys/Guestfs.xs"
      char *r;
#line 1395 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_get(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_get(): g is not a blessed HV reference");
    };
#line 715 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_get (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 1415 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, root, flags");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
	int	flags = (int)SvIV(ST(2));
#line 729 "lib/Sys/Guestfs.xs"
      int r;
#line 1441 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_init(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_init(): g is not a blessed HV reference");
    };
#line 731 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_init (g, root, flags);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1458 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_insert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_insert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, augpath, label, before");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
	int	before = (int)SvIV(ST(3));
#line 742 "lib/Sys/Guestfs.xs"
      int r;
#line 1484 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_insert(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_insert(): g is not a blessed HV reference");
    };
#line 744 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_insert (g, augpath, label, before);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1501 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 753 "lib/Sys/Guestfs.xs"
      char *r;
#line 1523 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_label(): g is not a blessed HV reference");
    };
#line 755 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_label (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 1543 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_load); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_load)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 767 "lib/Sys/Guestfs.xs"
      int r;
#line 1567 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_load(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_load(): g is not a blessed HV reference");
    };
#line 769 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_load (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1584 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_ls); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_ls)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 778 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 1609 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_ls(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_ls(): g is not a blessed HV reference");
    };
#line 781 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_ls (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 1633 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_match); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_match)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 797 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 1658 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_match(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_match(): g is not a blessed HV reference");
    };
#line 800 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_match (g, augpath);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 1682 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_mv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_mv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 817 "lib/Sys/Guestfs.xs"
      int r;
#line 1707 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_mv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_mv(): g is not a blessed HV reference");
    };
#line 819 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_mv (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1724 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_rm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_rm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, augpath");
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
#line 828 "lib/Sys/Guestfs.xs"
      int r;
#line 1746 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_rm(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_rm(): g is not a blessed HV reference");
    };
#line 830 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_rm (g, augpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1765 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_aug_save); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_save)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 841 "lib/Sys/Guestfs.xs"
      int r;
#line 1789 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_save(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_save(): g is not a blessed HV reference");
    };
#line 843 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_save (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1806 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, augpath, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	augpath = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
#line 853 "lib/Sys/Guestfs.xs"
      int r;
#line 1831 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_set(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_set(): g is not a blessed HV reference");
    };
#line 855 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_set (g, augpath, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1848 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_aug_setm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_aug_setm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, base, sub, val");
    {
	guestfs_h *	g;
	char *	base = (char *)SvPV_nolen(ST(1));
	char *	sub = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
	char *	val = (char *)SvPV_nolen(ST(3));
#line 866 "lib/Sys/Guestfs.xs"
      int r;
#line 1872 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::aug_setm(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::aug_setm(): g is not a blessed HV reference");
    };
#line 868 "lib/Sys/Guestfs.xs"
      r = guestfs_aug_setm (g, base, sub, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 1891 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_available); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_available)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, groups");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	groups = XS_unpack_charPtrPtr(ST(1));
#line 880 "lib/Sys/Guestfs.xs"
      int r;
#line 1916 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::available(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::available(): g is not a blessed HV reference");
    };
#line 882 "lib/Sys/Guestfs.xs"
      r = guestfs_available (g, groups);
      free (groups);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 1934 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_available_all_groups); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_available_all_groups)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 891 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 1958 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::available_all_groups(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::available_all_groups(): g is not a blessed HV reference");
    };
#line 894 "lib/Sys/Guestfs.xs"
      r = guestfs_available_all_groups (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 1982 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_base64_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_base64_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, base64file, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	base64file = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
#line 911 "lib/Sys/Guestfs.xs"
      int r;
#line 2007 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::base64_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::base64_in(): g is not a blessed HV reference");
    };
#line 913 "lib/Sys/Guestfs.xs"
      r = guestfs_base64_in (g, base64file, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2024 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_base64_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_base64_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, base64file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	base64file = (char *)SvPV_nolen(ST(2));
#line 923 "lib/Sys/Guestfs.xs"
      int r;
#line 2049 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::base64_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::base64_out(): g is not a blessed HV reference");
    };
#line 925 "lib/Sys/Guestfs.xs"
      r = guestfs_base64_out (g, filename, base64file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2066 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blkdiscard); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blkdiscard)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 934 "lib/Sys/Guestfs.xs"
      int r;
#line 2090 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blkdiscard(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blkdiscard(): g is not a blessed HV reference");
    };
#line 936 "lib/Sys/Guestfs.xs"
      r = guestfs_blkdiscard (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2107 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blkdiscardzeroes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blkdiscardzeroes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 945 "lib/Sys/Guestfs.xs"
      int r;
#line 2129 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blkdiscardzeroes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blkdiscardzeroes(): g is not a blessed HV reference");
    };
#line 947 "lib/Sys/Guestfs.xs"
      r = guestfs_blkdiscardzeroes (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2148 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blkid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blkid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 959 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 2174 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blkid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blkid(): g is not a blessed HV reference");
    };
#line 962 "lib/Sys/Guestfs.xs"
      r = guestfs_blkid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 2198 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_flushbufs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_flushbufs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 978 "lib/Sys/Guestfs.xs"
      int r;
#line 2222 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_flushbufs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_flushbufs(): g is not a blessed HV reference");
    };
#line 980 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_flushbufs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2239 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_getbsz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getbsz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 989 "lib/Sys/Guestfs.xs"
      int r;
#line 2261 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getbsz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getbsz(): g is not a blessed HV reference");
    };
#line 991 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_getbsz (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2280 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1003 "lib/Sys/Guestfs.xs"
      int r;
#line 2303 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getro(): g is not a blessed HV reference");
    };
#line 1005 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_getro (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2322 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getsize64); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getsize64)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1017 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 2345 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getsize64(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getsize64(): g is not a blessed HV reference");
    };
#line 1019 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_getsize64 (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 2364 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getss); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getss)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1031 "lib/Sys/Guestfs.xs"
      int r;
#line 2387 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getss(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getss(): g is not a blessed HV reference");
    };
#line 1033 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_getss (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 2406 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_getsz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_getsz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1045 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 2429 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_getsz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_getsz(): g is not a blessed HV reference");
    };
#line 1047 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_getsz (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 2448 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_blockdev_rereadpt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_rereadpt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1059 "lib/Sys/Guestfs.xs"
      int r;
#line 2473 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_rereadpt(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_rereadpt(): g is not a blessed HV reference");
    };
#line 1061 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_rereadpt (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2490 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setbsz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setbsz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, blocksize");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
#line 1071 "lib/Sys/Guestfs.xs"
      int r;
#line 2515 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setbsz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setbsz(): g is not a blessed HV reference");
    };
#line 1073 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_setbsz (g, device, blocksize);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2532 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setra); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setra)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, sectors");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	sectors = (int)SvIV(ST(2));
#line 1083 "lib/Sys/Guestfs.xs"
      int r;
#line 2557 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setra(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setra(): g is not a blessed HV reference");
    };
#line 1085 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_setra (g, device, sectors);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2574 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1094 "lib/Sys/Guestfs.xs"
      int r;
#line 2598 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setro(): g is not a blessed HV reference");
    };
#line 1096 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_setro (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2615 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_blockdev_setrw); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_blockdev_setrw)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1105 "lib/Sys/Guestfs.xs"
      int r;
#line 2639 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::blockdev_setrw(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::blockdev_setrw(): g is not a blessed HV reference");
    };
#line 1107 "lib/Sys/Guestfs.xs"
      r = guestfs_blockdev_setrw (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2656 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1116 "lib/Sys/Guestfs.xs"
      int r;
#line 2680 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_cancel(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_cancel(): g is not a blessed HV reference");
    };
#line 1118 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_balance_cancel (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2697 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_pause); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_pause)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1127 "lib/Sys/Guestfs.xs"
      int r;
#line 2721 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_pause(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_pause(): g is not a blessed HV reference");
    };
#line 1129 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_balance_pause (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2738 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_resume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_resume)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1138 "lib/Sys/Guestfs.xs"
      int r;
#line 2762 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_resume(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_resume(): g is not a blessed HV reference");
    };
#line 1140 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_balance_resume (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2779 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_balance_status); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_balance_status)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1149 "lib/Sys/Guestfs.xs"
      struct guestfs_btrfsbalance *r;
#line 2803 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_balance_status(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_balance_status(): g is not a blessed HV reference");
    };
#line 1151 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_balance_status (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 5);
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_status", 0)));
      PUSHs (sv_2mortal (newSVpv (r->btrfsbalance_status, 0)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_total", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_total)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_balanced", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_balanced)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_considered", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_considered)));
      PUSHs (sv_2mortal (newSVpv ("btrfsbalance_left", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsbalance_left)));
      free (r);
#line 2832 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_device_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_device_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, devices, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
	char *	fs = (char *)SvPV_nolen(ST(2));
#line 1173 "lib/Sys/Guestfs.xs"
      int r;
#line 2857 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_device_add(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_device_add(): g is not a blessed HV reference");
    };
#line 1175 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_device_add (g, devices, fs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2875 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_device_delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_device_delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, devices, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
	char *	fs = (char *)SvPV_nolen(ST(2));
#line 1186 "lib/Sys/Guestfs.xs"
      int r;
#line 2900 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_device_delete(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_device_delete(): g is not a blessed HV reference");
    };
#line 1188 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_device_delete (g, devices, fs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2918 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_balance); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_balance)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1198 "lib/Sys/Guestfs.xs"
      int r;
#line 2942 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_balance(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_balance(): g is not a blessed HV reference");
    };
#line 1200 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_filesystem_balance (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 2959 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_defragment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_defragment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1209 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_btrfs_filesystem_defragment_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_filesystem_defragment_argv *optargs = &optargs_s;
      size_t items_i;
#line 2986 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_defragment(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_defragment(): g is not a blessed HV reference");
    };
#line 1214 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "flush")) {
          optargs_s.flush = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_FLUSH_BITMASK;
        }
        else if (STREQ (this_arg, "compress")) {
          optargs_s.compress = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_COMPRESS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_filesystem_defragment_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3025 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_resize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_resize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 1245 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_btrfs_filesystem_resize_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_filesystem_resize_argv *optargs = &optargs_s;
      size_t items_i;
#line 3052 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_resize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_resize(): g is not a blessed HV reference");
    };
#line 1250 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_filesystem_resize_argv (g, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3087 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_filesystem_sync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_filesystem_sync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1277 "lib/Sys/Guestfs.xs"
      int r;
#line 3111 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_filesystem_sync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_filesystem_sync(): g is not a blessed HV reference");
    };
#line 1279 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_filesystem_sync (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3128 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_fsck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_fsck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1288 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_btrfs_fsck_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_fsck_argv *optargs = &optargs_s;
      size_t items_i;
#line 3155 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_fsck(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_fsck(): g is not a blessed HV reference");
    };
#line 1293 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "superblock")) {
          optargs_s.superblock = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FSCK_SUPERBLOCK_BITMASK;
        }
        else if (STREQ (this_arg, "repair")) {
          optargs_s.repair = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_FSCK_REPAIR_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_fsck_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3194 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_image); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_image)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, source, image, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	source = XS_unpack_charPtrPtr(ST(1));
	char *	image = (char *)SvPV_nolen(ST(2));
#line 1325 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_btrfs_image_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_image_argv *optargs = &optargs_s;
      size_t items_i;
#line 3222 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_image(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_image(): g is not a blessed HV reference");
    };
#line 1330 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "compresslevel")) {
          optargs_s.compresslevel = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_IMAGE_COMPRESSLEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_image_argv (g, source, image, optargs);
      free (source);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3258 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_assign); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_assign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, src, dst, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dst = (char *)SvPV_nolen(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 1360 "lib/Sys/Guestfs.xs"
      int r;
#line 3284 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_assign(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_assign(): g is not a blessed HV reference");
    };
#line 1362 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_qgroup_assign (g, src, dst, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3301 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, qgroupid, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	qgroupid = (char *)SvPV_nolen(ST(1));
	char *	subvolume = (char *)SvPV_nolen(ST(2));
#line 1372 "lib/Sys/Guestfs.xs"
      int r;
#line 3326 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_create(): g is not a blessed HV reference");
    };
#line 1374 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_qgroup_create (g, qgroupid, subvolume);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3343 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, qgroupid, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	qgroupid = (char *)SvPV_nolen(ST(1));
	char *	subvolume = (char *)SvPV_nolen(ST(2));
#line 1384 "lib/Sys/Guestfs.xs"
      int r;
#line 3368 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_destroy(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_destroy(): g is not a blessed HV reference");
    };
#line 1386 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_qgroup_destroy (g, qgroupid, subvolume);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3385 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_limit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_limit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, subvolume, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	subvolume = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 1396 "lib/Sys/Guestfs.xs"
      int r;
#line 3410 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_limit(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_limit(): g is not a blessed HV reference");
    };
#line 1398 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_qgroup_limit (g, subvolume, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3427 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_remove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_remove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, src, dst, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dst = (char *)SvPV_nolen(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 1409 "lib/Sys/Guestfs.xs"
      int r;
#line 3453 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_remove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_remove(): g is not a blessed HV reference");
    };
#line 1411 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_qgroup_remove (g, src, dst, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3470 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_qgroup_show); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_qgroup_show)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1420 "lib/Sys/Guestfs.xs"
      struct guestfs_btrfsqgroup_list *r;
      size_t i;
      HV *hv;
#line 3496 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_qgroup_show(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_qgroup_show(): g is not a blessed HV reference");
    };
#line 1424 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_qgroup_show (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "btrfsqgroup_id", 14, newSVpv (r->val[i].btrfsqgroup_id, 0), 0);
        (void) hv_store (hv, "btrfsqgroup_rfer", 16, my_newSVull (r->val[i].btrfsqgroup_rfer), 0);
        (void) hv_store (hv, "btrfsqgroup_excl", 16, my_newSVull (r->val[i].btrfsqgroup_excl), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_btrfsqgroup_list (r);
#line 3522 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_quota_enable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_quota_enable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, fs, enable");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
	int	enable = (int)SvIV(ST(2));
#line 1443 "lib/Sys/Guestfs.xs"
      int r;
#line 3547 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_quota_enable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_quota_enable(): g is not a blessed HV reference");
    };
#line 1445 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_quota_enable (g, fs, enable);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3564 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_quota_rescan); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_quota_rescan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1454 "lib/Sys/Guestfs.xs"
      int r;
#line 3588 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_quota_rescan(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_quota_rescan(): g is not a blessed HV reference");
    };
#line 1456 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_quota_rescan (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3605 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_replace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_replace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, srcdev, targetdev, mntpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	srcdev = (char *)SvPV_nolen(ST(1));
	char *	targetdev = (char *)SvPV_nolen(ST(2));
	char *	mntpoint = (char *)SvPV_nolen(ST(3));
#line 1467 "lib/Sys/Guestfs.xs"
      int r;
#line 3631 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_replace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_replace(): g is not a blessed HV reference");
    };
#line 1469 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_replace (g, srcdev, targetdev, mntpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3648 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_rescue_chunk_recover); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_rescue_chunk_recover)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1478 "lib/Sys/Guestfs.xs"
      int r;
#line 3672 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_rescue_chunk_recover(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_rescue_chunk_recover(): g is not a blessed HV reference");
    };
#line 1480 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_rescue_chunk_recover (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3689 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_rescue_super_recover); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_rescue_super_recover)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1489 "lib/Sys/Guestfs.xs"
      int r;
#line 3713 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_rescue_super_recover(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_rescue_super_recover(): g is not a blessed HV reference");
    };
#line 1491 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_rescue_super_recover (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3730 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1500 "lib/Sys/Guestfs.xs"
      int r;
#line 3754 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_cancel(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_cancel(): g is not a blessed HV reference");
    };
#line 1502 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_scrub_cancel (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3771 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_resume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_resume)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1511 "lib/Sys/Guestfs.xs"
      int r;
#line 3795 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_resume(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_resume(): g is not a blessed HV reference");
    };
#line 1513 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_scrub_resume (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3812 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_start)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1522 "lib/Sys/Guestfs.xs"
      int r;
#line 3836 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_start(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_start(): g is not a blessed HV reference");
    };
#line 1524 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_scrub_start (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3853 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_scrub_status); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_scrub_status)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1533 "lib/Sys/Guestfs.xs"
      struct guestfs_btrfsscrub *r;
#line 3877 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_scrub_status(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_scrub_status(): g is not a blessed HV reference");
    };
#line 1535 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_scrub_status (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 15);
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_data_extents_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_data_extents_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_tree_extents_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_tree_extents_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_data_bytes_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_data_bytes_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_tree_bytes_scrubbed", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_tree_bytes_scrubbed)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_read_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_read_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_csum_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_csum_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_verify_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_verify_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_no_csum", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_no_csum)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_csum_discards", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_csum_discards)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_super_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_super_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_malloc_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_malloc_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_uncorrectable_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_uncorrectable_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_unverified_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_unverified_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_corrected_errors", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_corrected_errors)));
      PUSHs (sv_2mortal (newSVpv ("btrfsscrub_last_physical", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->btrfsscrub_last_physical)));
      free (r);
#line 3926 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_set_seeding); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_set_seeding)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, seeding");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	seeding = (int)SvIV(ST(2));
#line 1577 "lib/Sys/Guestfs.xs"
      int r;
#line 3951 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_set_seeding(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_set_seeding(): g is not a blessed HV reference");
    };
#line 1579 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_set_seeding (g, device, seeding);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 3968 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dest = (char *)SvPV_nolen(ST(1));
#line 1588 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_btrfs_subvolume_create_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_subvolume_create_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 3995 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_create(): g is not a blessed HV reference");
    };
#line 1593 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "qgroupid")) {
          optargs_s.qgroupid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_SUBVOLUME_CREATE_OPTS_QGROUPID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_subvolume_create_opts_argv (g, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4030 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	subvolume = (char *)SvPV_nolen(ST(1));
#line 1620 "lib/Sys/Guestfs.xs"
      int r;
#line 4054 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_delete(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_delete(): g is not a blessed HV reference");
    };
#line 1622 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_subvolume_delete (g, subvolume);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4071 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_get_default); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_get_default)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1631 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 4093 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_get_default(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_get_default(): g is not a blessed HV reference");
    };
#line 1633 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_subvolume_get_default (g, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 4112 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_btrfs_subvolume_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fs = (char *)SvPV_nolen(ST(1));
#line 1645 "lib/Sys/Guestfs.xs"
      struct guestfs_btrfssubvolume_list *r;
      size_t i;
      HV *hv;
#line 4139 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_list(): g is not a blessed HV reference");
    };
#line 1649 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_subvolume_list (g, fs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "btrfssubvolume_id", 17, my_newSVull (r->val[i].btrfssubvolume_id), 0);
        (void) hv_store (hv, "btrfssubvolume_top_level_id", 27, my_newSVull (r->val[i].btrfssubvolume_top_level_id), 0);
        (void) hv_store (hv, "btrfssubvolume_path", 19, newSVpv (r->val[i].btrfssubvolume_path, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_btrfssubvolume_list (r);
#line 4165 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_set_default); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_set_default)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, id, fs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    id = my_SvIV64 (ST(1));
	char *	fs = (char *)SvPV_nolen(ST(2));
#line 1668 "lib/Sys/Guestfs.xs"
      int r;
#line 4190 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_set_default(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_set_default(): g is not a blessed HV reference");
    };
#line 1670 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_subvolume_set_default (g, id, fs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4207 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_show); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_show)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, subvolume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	subvolume = (char *)SvPV_nolen(ST(1));
#line 1679 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 4232 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_show(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_show(): g is not a blessed HV reference");
    };
#line 1682 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfs_subvolume_show (g, subvolume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 4256 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfs_subvolume_snapshot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfs_subvolume_snapshot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, source, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	source = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 1699 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_btrfs_subvolume_snapshot_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_btrfs_subvolume_snapshot_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 4284 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfs_subvolume_snapshot(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfs_subvolume_snapshot(): g is not a blessed HV reference");
    };
#line 1704 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "ro")) {
          optargs_s.ro = SvIV (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_RO_BITMASK;
        }
        else if (STREQ (this_arg, "qgroupid")) {
          optargs_s.qgroupid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_QGROUPID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_btrfs_subvolume_snapshot_opts_argv (g, source, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4323 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfstune_enable_extended_inode_refs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfstune_enable_extended_inode_refs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1735 "lib/Sys/Guestfs.xs"
      int r;
#line 4347 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfstune_enable_extended_inode_refs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfstune_enable_extended_inode_refs(): g is not a blessed HV reference");
    };
#line 1737 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfstune_enable_extended_inode_refs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4364 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfstune_enable_skinny_metadata_extent_refs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfstune_enable_skinny_metadata_extent_refs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1746 "lib/Sys/Guestfs.xs"
      int r;
#line 4388 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfstune_enable_skinny_metadata_extent_refs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfstune_enable_skinny_metadata_extent_refs(): g is not a blessed HV reference");
    };
#line 1748 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfstune_enable_skinny_metadata_extent_refs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4405 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_btrfstune_seeding); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_btrfstune_seeding)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, seeding");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	seeding = (int)SvIV(ST(2));
#line 1758 "lib/Sys/Guestfs.xs"
      int r;
#line 4430 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::btrfstune_seeding(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::btrfstune_seeding(): g is not a blessed HV reference");
    };
#line 1760 "lib/Sys/Guestfs.xs"
      r = guestfs_btrfstune_seeding (g, device, seeding);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4447 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_c_pointer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_c_pointer)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 1768 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 4468 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::c_pointer(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::c_pointer(): g is not a blessed HV reference");
    };
#line 1770 "lib/Sys/Guestfs.xs"
      r = guestfs_c_pointer (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 4487 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_canonical_device_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_canonical_device_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 1782 "lib/Sys/Guestfs.xs"
      char *r;
#line 4510 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::canonical_device_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::canonical_device_name(): g is not a blessed HV reference");
    };
#line 1784 "lib/Sys/Guestfs.xs"
      r = guestfs_canonical_device_name (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4530 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_cap_get_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cap_get_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1797 "lib/Sys/Guestfs.xs"
      char *r;
#line 4553 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cap_get_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cap_get_file(): g is not a blessed HV reference");
    };
#line 1799 "lib/Sys/Guestfs.xs"
      r = guestfs_cap_get_file (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4573 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_cap_set_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cap_set_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, cap");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	cap = (char *)SvPV_nolen(ST(2));
#line 1813 "lib/Sys/Guestfs.xs"
      int r;
#line 4599 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cap_set_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cap_set_file(): g is not a blessed HV reference");
    };
#line 1815 "lib/Sys/Guestfs.xs"
      r = guestfs_cap_set_file (g, path, cap);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4616 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_case_sensitive_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_case_sensitive_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1824 "lib/Sys/Guestfs.xs"
      char *r;
#line 4638 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::case_sensitive_path(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::case_sensitive_path(): g is not a blessed HV reference");
    };
#line 1826 "lib/Sys/Guestfs.xs"
      r = guestfs_case_sensitive_path (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4658 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_cat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 1839 "lib/Sys/Guestfs.xs"
      char *r;
#line 4681 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cat(): g is not a blessed HV reference");
    };
#line 1841 "lib/Sys/Guestfs.xs"
      r = guestfs_cat (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4701 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_checksum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_checksum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, csumtype, path");
    {
	guestfs_h *	g;
	char *	csumtype = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 1855 "lib/Sys/Guestfs.xs"
      char *r;
#line 4725 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::checksum(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::checksum(): g is not a blessed HV reference");
    };
#line 1857 "lib/Sys/Guestfs.xs"
      r = guestfs_checksum (g, csumtype, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4745 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_checksum_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_checksum_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, csumtype, device");
    {
	guestfs_h *	g;
	char *	csumtype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 1871 "lib/Sys/Guestfs.xs"
      char *r;
#line 4769 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::checksum_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::checksum_device(): g is not a blessed HV reference");
    };
#line 1873 "lib/Sys/Guestfs.xs"
      r = guestfs_checksum_device (g, csumtype, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 4789 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_checksums_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_checksums_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, csumtype, directory, sumsfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	csumtype = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
	char *	sumsfile = (char *)SvPV_nolen(ST(3));
#line 1888 "lib/Sys/Guestfs.xs"
      int r;
#line 4816 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::checksums_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::checksums_out(): g is not a blessed HV reference");
    };
#line 1890 "lib/Sys/Guestfs.xs"
      r = guestfs_checksums_out (g, csumtype, directory, sumsfile);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4833 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_chmod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_chmod)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mode, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 1900 "lib/Sys/Guestfs.xs"
      int r;
#line 4858 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::chmod(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::chmod(): g is not a blessed HV reference");
    };
#line 1902 "lib/Sys/Guestfs.xs"
      r = guestfs_chmod (g, mode, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4875 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_chown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_chown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, owner, group, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	owner = (int)SvIV(ST(1));
	int	group = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 1913 "lib/Sys/Guestfs.xs"
      int r;
#line 4901 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::chown(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::chown(): g is not a blessed HV reference");
    };
#line 1915 "lib/Sys/Guestfs.xs"
      r = guestfs_chown (g, owner, group, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 4918 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_clear_backend_setting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_clear_backend_setting)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, name");
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
#line 1924 "lib/Sys/Guestfs.xs"
      int r;
#line 4940 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::clear_backend_setting(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::clear_backend_setting(): g is not a blessed HV reference");
    };
#line 1926 "lib/Sys/Guestfs.xs"
      r = guestfs_clear_backend_setting (g, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 4959 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_command); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_command)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, arguments");
    {
	guestfs_h *	g;
	char **	arguments = XS_unpack_charPtrPtr(ST(1));
#line 1938 "lib/Sys/Guestfs.xs"
      char *r;
#line 4982 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::command(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::command(): g is not a blessed HV reference");
    };
#line 1940 "lib/Sys/Guestfs.xs"
      r = guestfs_command (g, arguments);
      free (arguments);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 5003 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_command_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_command_lines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, arguments");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	arguments = XS_unpack_charPtrPtr(ST(1));
#line 1954 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 5029 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::command_lines(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::command_lines(): g is not a blessed HV reference");
    };
#line 1957 "lib/Sys/Guestfs.xs"
      r = guestfs_command_lines (g, arguments);
      free (arguments);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 5054 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_compress_device_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_compress_device_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4)
       croak_xs_usage(cv,  "g, ctype, device, zdevice, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	ctype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
	char *	zdevice = (char *)SvPV_nolen(ST(3));
#line 1976 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_compress_device_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_compress_device_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 5083 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::compress_device_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::compress_device_out(): g is not a blessed HV reference");
    };
#line 1981 "lib/Sys/Guestfs.xs"
      if (((items - 4) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 4; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "level")) {
          optargs_s.level = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COMPRESS_DEVICE_OUT_LEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_compress_device_out_argv (g, ctype, device, zdevice, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5118 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_compress_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_compress_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4)
       croak_xs_usage(cv,  "g, ctype, file, zfile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	ctype = (char *)SvPV_nolen(ST(1));
	char *	file = (char *)SvPV_nolen(ST(2));
	char *	zfile = (char *)SvPV_nolen(ST(3));
#line 2010 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_compress_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_compress_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 5147 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::compress_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::compress_out(): g is not a blessed HV reference");
    };
#line 2015 "lib/Sys/Guestfs.xs"
      if (((items - 4) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 4; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "level")) {
          optargs_s.level = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COMPRESS_OUT_LEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_compress_out_argv (g, ctype, file, zfile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5182 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_config); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_config)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, hvparam, hvvalue");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	hvparam = (char *)SvPV_nolen(ST(1));
	char *	hvvalue = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
#line 2043 "lib/Sys/Guestfs.xs"
      int r;
#line 5207 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::config(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::config(): g is not a blessed HV reference");
    };
#line 2045 "lib/Sys/Guestfs.xs"
      r = guestfs_config (g, hvparam, hvvalue);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5224 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_attributes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_attributes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2055 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_copy_attributes_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_attributes_argv *optargs = &optargs_s;
      size_t items_i;
#line 5252 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_attributes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_attributes(): g is not a blessed HV reference");
    };
#line 2060 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "all")) {
          optargs_s.all = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_ALL_BITMASK;
        }
        else if (STREQ (this_arg, "mode")) {
          optargs_s.mode = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_MODE_BITMASK;
        }
        else if (STREQ (this_arg, "xattributes")) {
          optargs_s.xattributes = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_XATTRIBUTES_BITMASK;
        }
        else if (STREQ (this_arg, "ownership")) {
          optargs_s.ownership = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_ATTRIBUTES_OWNERSHIP_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_attributes_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5299 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_device_to_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_device_to_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2100 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_copy_device_to_device_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_device_to_device_argv *optargs = &optargs_s;
      size_t items_i;
#line 5327 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_device_to_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_device_to_device(): g is not a blessed HV reference");
    };
#line 2105 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_DEVICE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_device_to_device_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5378 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_device_to_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_device_to_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2149 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_copy_device_to_file_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_device_to_file_argv *optargs = &optargs_s;
      size_t items_i;
#line 5406 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_device_to_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_device_to_file(): g is not a blessed HV reference");
    };
#line 2154 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_DEVICE_TO_FILE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_device_to_file_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5457 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_file_to_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_file_to_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2198 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_copy_file_to_device_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_file_to_device_argv *optargs = &optargs_s;
      size_t items_i;
#line 5485 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_file_to_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_file_to_device(): g is not a blessed HV reference");
    };
#line 2203 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_DEVICE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_file_to_device_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5536 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_file_to_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_file_to_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2247 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_copy_file_to_file_argv optargs_s = { .bitmask = 0 };
      struct guestfs_copy_file_to_file_argv *optargs = &optargs_s;
      size_t items_i;
#line 5564 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_file_to_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_file_to_file(): g is not a blessed HV reference");
    };
#line 2252 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "srcoffset")) {
          optargs_s.srcoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "destoffset")) {
          optargs_s.destoffset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sparse")) {
          optargs_s.sparse = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_SPARSE_BITMASK;
        }
        else if (STREQ (this_arg, "append")) {
          optargs_s.append = SvIV (ST (items_i+1));
          this_mask = GUESTFS_COPY_FILE_TO_FILE_APPEND_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_copy_file_to_file_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5615 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, localpath, remotedir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	localpath = (char *)SvPV_nolen(ST(1));
	char *	remotedir = (char *)SvPV_nolen(ST(2));
#line 2296 "lib/Sys/Guestfs.xs"
      int r;
#line 5640 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_in(): g is not a blessed HV reference");
    };
#line 2298 "lib/Sys/Guestfs.xs"
      r = guestfs_copy_in (g, localpath, remotedir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5657 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, remotepath, localdir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remotepath = (char *)SvPV_nolen(ST(1));
	char *	localdir = (char *)SvPV_nolen(ST(2));
#line 2308 "lib/Sys/Guestfs.xs"
      int r;
#line 5682 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_out(): g is not a blessed HV reference");
    };
#line 2310 "lib/Sys/Guestfs.xs"
      r = guestfs_copy_out (g, remotepath, localdir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5699 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_copy_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_copy_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, src, dest, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
	int64_t    size = my_SvIV64 (ST(3));
#line 2321 "lib/Sys/Guestfs.xs"
      int r;
#line 5725 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::copy_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::copy_size(): g is not a blessed HV reference");
    };
#line 2323 "lib/Sys/Guestfs.xs"
      r = guestfs_copy_size (g, src, dest, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5742 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2333 "lib/Sys/Guestfs.xs"
      int r;
#line 5767 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cp(): g is not a blessed HV reference");
    };
#line 2335 "lib/Sys/Guestfs.xs"
      r = guestfs_cp (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5784 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cp_a); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cp_a)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2345 "lib/Sys/Guestfs.xs"
      int r;
#line 5809 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cp_a(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cp_a(): g is not a blessed HV reference");
    };
#line 2347 "lib/Sys/Guestfs.xs"
      r = guestfs_cp_a (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5826 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cp_r); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cp_r)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2357 "lib/Sys/Guestfs.xs"
      int r;
#line 5851 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cp_r(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cp_r(): g is not a blessed HV reference");
    };
#line 2359 "lib/Sys/Guestfs.xs"
      r = guestfs_cp_r (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5868 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_cpio_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_cpio_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, directory, cpiofile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	cpiofile = (char *)SvPV_nolen(ST(2));
#line 2369 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_cpio_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_cpio_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 5896 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::cpio_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::cpio_out(): g is not a blessed HV reference");
    };
#line 2374 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "format")) {
          optargs_s.format = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_CPIO_OUT_FORMAT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_cpio_out_argv (g, directory, cpiofile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5931 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_dd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_dd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 2402 "lib/Sys/Guestfs.xs"
      int r;
#line 5956 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::dd(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::dd(): g is not a blessed HV reference");
    };
#line 2404 "lib/Sys/Guestfs.xs"
      r = guestfs_dd (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 5973 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_debug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, subcmd, extraargs");
    {
	guestfs_h *	g;
	char *	subcmd = (char *)SvPV_nolen(ST(1));
	char **	extraargs = XS_unpack_charPtrPtr(ST(2));
#line 2414 "lib/Sys/Guestfs.xs"
      char *r;
#line 5996 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::debug(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::debug(): g is not a blessed HV reference");
    };
#line 2416 "lib/Sys/Guestfs.xs"
      r = guestfs_debug (g, subcmd, extraargs);
      free (extraargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6017 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_debug_drives); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_debug_drives)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 2429 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 6042 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::debug_drives(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::debug_drives(): g is not a blessed HV reference");
    };
#line 2432 "lib/Sys/Guestfs.xs"
      r = guestfs_debug_drives (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 6066 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_debug_upload); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_debug_upload)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, filename, tmpname, mode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	tmpname = (char *)SvPV_nolen(ST(2));
	int	mode = (int)SvIV(ST(3));
#line 2450 "lib/Sys/Guestfs.xs"
      int r;
#line 6092 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::debug_upload(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::debug_upload(): g is not a blessed HV reference");
    };
#line 2452 "lib/Sys/Guestfs.xs"
      r = guestfs_debug_upload (g, filename, tmpname, mode);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6109 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_device_index); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_device_index)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 2461 "lib/Sys/Guestfs.xs"
      int r;
#line 6131 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::device_index(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::device_index(): g is not a blessed HV reference");
    };
#line 2463 "lib/Sys/Guestfs.xs"
      r = guestfs_device_index (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6150 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_df); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_df)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 2474 "lib/Sys/Guestfs.xs"
      char *r;
#line 6172 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::df(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::df(): g is not a blessed HV reference");
    };
#line 2476 "lib/Sys/Guestfs.xs"
      r = guestfs_df (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6192 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_df_h); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_df_h)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 2488 "lib/Sys/Guestfs.xs"
      char *r;
#line 6214 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::df_h(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::df_h(): g is not a blessed HV reference");
    };
#line 2490 "lib/Sys/Guestfs.xs"
      r = guestfs_df_h (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6234 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_disk_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4)
       croak_xs_usage(cv,  "g, filename, format, size, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	format = (char *)SvPV_nolen(ST(2));
	int64_t    size = my_SvIV64 (ST(3));
#line 2505 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_disk_create_argv optargs_s = { .bitmask = 0 };
      struct guestfs_disk_create_argv *optargs = &optargs_s;
      size_t items_i;
#line 6264 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_create(): g is not a blessed HV reference");
    };
#line 2510 "lib/Sys/Guestfs.xs"
      if (((items - 4) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 4; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "backingfile")) {
          optargs_s.backingfile = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_BACKINGFILE_BITMASK;
        }
        else if (STREQ (this_arg, "backingformat")) {
          optargs_s.backingformat = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_BACKINGFORMAT_BITMASK;
        }
        else if (STREQ (this_arg, "preallocation")) {
          optargs_s.preallocation = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_PREALLOCATION_BITMASK;
        }
        else if (STREQ (this_arg, "compat")) {
          optargs_s.compat = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_COMPAT_BITMASK;
        }
        else if (STREQ (this_arg, "clustersize")) {
          optargs_s.clustersize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_DISK_CREATE_CLUSTERSIZE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_disk_create_argv (g, filename, format, size, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6315 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_disk_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2553 "lib/Sys/Guestfs.xs"
      char *r;
#line 6337 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_format(): g is not a blessed HV reference");
    };
#line 2555 "lib/Sys/Guestfs.xs"
      r = guestfs_disk_format (g, filename);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6357 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_disk_has_backing_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_has_backing_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2568 "lib/Sys/Guestfs.xs"
      int r;
#line 6380 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_has_backing_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_has_backing_file(): g is not a blessed HV reference");
    };
#line 2570 "lib/Sys/Guestfs.xs"
      r = guestfs_disk_has_backing_file (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6399 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_disk_virtual_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_disk_virtual_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2582 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 6422 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::disk_virtual_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::disk_virtual_size(): g is not a blessed HV reference");
    };
#line 2584 "lib/Sys/Guestfs.xs"
      r = guestfs_disk_virtual_size (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 6441 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_dmesg); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_dmesg)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 2595 "lib/Sys/Guestfs.xs"
      char *r;
#line 6463 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::dmesg(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::dmesg(): g is not a blessed HV reference");
    };
#line 2597 "lib/Sys/Guestfs.xs"
      r = guestfs_dmesg (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6483 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_download); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_download)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, remotefilename, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remotefilename = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
#line 2611 "lib/Sys/Guestfs.xs"
      int r;
#line 6509 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::download(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::download(): g is not a blessed HV reference");
    };
#line 2613 "lib/Sys/Guestfs.xs"
      r = guestfs_download (g, remotefilename, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6526 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_download_offset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_download_offset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, remotefilename, filename, offset, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remotefilename = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
	int64_t    size = my_SvIV64 (ST(4));
#line 2625 "lib/Sys/Guestfs.xs"
      int r;
#line 6553 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::download_offset(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::download_offset(): g is not a blessed HV reference");
    };
#line 2627 "lib/Sys/Guestfs.xs"
      r = guestfs_download_offset (g, remotefilename, filename, offset, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6570 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_drop_caches); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_drop_caches)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, whattodrop");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	whattodrop = (int)SvIV(ST(1));
#line 2636 "lib/Sys/Guestfs.xs"
      int r;
#line 6594 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::drop_caches(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::drop_caches(): g is not a blessed HV reference");
    };
#line 2638 "lib/Sys/Guestfs.xs"
      r = guestfs_drop_caches (g, whattodrop);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6611 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_du); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_du)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 2647 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 6633 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::du(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::du(): g is not a blessed HV reference");
    };
#line 2649 "lib/Sys/Guestfs.xs"
      r = guestfs_du (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 6652 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_e2fsck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_e2fsck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 2661 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_e2fsck_argv optargs_s = { .bitmask = 0 };
      struct guestfs_e2fsck_argv *optargs = &optargs_s;
      size_t items_i;
#line 6680 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::e2fsck(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::e2fsck(): g is not a blessed HV reference");
    };
#line 2666 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "correct")) {
          optargs_s.correct = SvIV (ST (items_i+1));
          this_mask = GUESTFS_E2FSCK_CORRECT_BITMASK;
        }
        else if (STREQ (this_arg, "forceall")) {
          optargs_s.forceall = SvIV (ST (items_i+1));
          this_mask = GUESTFS_E2FSCK_FORCEALL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_e2fsck_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6719 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_e2fsck_f); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_e2fsck_f)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 2697 "lib/Sys/Guestfs.xs"
      int r;
#line 6743 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::e2fsck_f(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::e2fsck_f(): g is not a blessed HV reference");
    };
#line 2699 "lib/Sys/Guestfs.xs"
      r = guestfs_e2fsck_f (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 6760 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_echo_daemon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_echo_daemon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, words");
    {
	guestfs_h *	g;
	char **	words = XS_unpack_charPtrPtr(ST(1));
#line 2708 "lib/Sys/Guestfs.xs"
      char *r;
#line 6782 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::echo_daemon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::echo_daemon(): g is not a blessed HV reference");
    };
#line 2710 "lib/Sys/Guestfs.xs"
      r = guestfs_echo_daemon (g, words);
      free (words);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 6803 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_egrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_egrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2725 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 6830 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::egrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::egrep(): g is not a blessed HV reference");
    };
#line 2728 "lib/Sys/Guestfs.xs"
      r = guestfs_egrep (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 6854 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_egrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_egrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2745 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 6880 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::egrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::egrepi(): g is not a blessed HV reference");
    };
#line 2748 "lib/Sys/Guestfs.xs"
      r = guestfs_egrepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 6904 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_equal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_equal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, file1, file2");
    {
	guestfs_h *	g;
	char *	file1 = (char *)SvPV_nolen(ST(1));
	char *	file2 = (char *)SvPV_nolen(ST(2));
#line 2765 "lib/Sys/Guestfs.xs"
      int r;
#line 6927 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::equal(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::equal(): g is not a blessed HV reference");
    };
#line 2767 "lib/Sys/Guestfs.xs"
      r = guestfs_equal (g, file1, file2);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6946 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_exists); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_exists)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 2779 "lib/Sys/Guestfs.xs"
      int r;
#line 6969 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::exists(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::exists(): g is not a blessed HV reference");
    };
#line 2781 "lib/Sys/Guestfs.xs"
      r = guestfs_exists (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 6988 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_extlinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_extlinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 2793 "lib/Sys/Guestfs.xs"
      int r;
#line 7013 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::extlinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::extlinux(): g is not a blessed HV reference");
    };
#line 2795 "lib/Sys/Guestfs.xs"
      r = guestfs_extlinux (g, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7030 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fallocate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fallocate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, len");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	len = (int)SvIV(ST(2));
#line 2805 "lib/Sys/Guestfs.xs"
      int r;
#line 7055 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fallocate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fallocate(): g is not a blessed HV reference");
    };
#line 2807 "lib/Sys/Guestfs.xs"
      r = guestfs_fallocate (g, path, len);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7072 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fallocate64); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fallocate64)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, len");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int64_t    len = my_SvIV64 (ST(2));
#line 2817 "lib/Sys/Guestfs.xs"
      int r;
#line 7097 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fallocate64(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fallocate64(): g is not a blessed HV reference");
    };
#line 2819 "lib/Sys/Guestfs.xs"
      r = guestfs_fallocate64 (g, path, len);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7114 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_feature_available); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_feature_available)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, groups");
    {
	guestfs_h *	g;
	char **	groups = XS_unpack_charPtrPtr(ST(1));
#line 2828 "lib/Sys/Guestfs.xs"
      int r;
#line 7136 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::feature_available(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::feature_available(): g is not a blessed HV reference");
    };
#line 2830 "lib/Sys/Guestfs.xs"
      r = guestfs_feature_available (g, groups);
      free (groups);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7156 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fgrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fgrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2844 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 7183 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fgrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fgrep(): g is not a blessed HV reference");
    };
#line 2847 "lib/Sys/Guestfs.xs"
      r = guestfs_fgrep (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 7207 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fgrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fgrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 2864 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 7233 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fgrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fgrepi(): g is not a blessed HV reference");
    };
#line 2867 "lib/Sys/Guestfs.xs"
      r = guestfs_fgrepi (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 7257 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 2883 "lib/Sys/Guestfs.xs"
      char *r;
#line 7279 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::file(): g is not a blessed HV reference");
    };
#line 2885 "lib/Sys/Guestfs.xs"
      r = guestfs_file (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7299 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_file_architecture); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_file_architecture)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 2898 "lib/Sys/Guestfs.xs"
      char *r;
#line 7322 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::file_architecture(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::file_architecture(): g is not a blessed HV reference");
    };
#line 2900 "lib/Sys/Guestfs.xs"
      r = guestfs_file_architecture (g, filename);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7342 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_filesize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_filesize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 2913 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 7365 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::filesize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::filesize(): g is not a blessed HV reference");
    };
#line 2915 "lib/Sys/Guestfs.xs"
      r = guestfs_filesize (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 7384 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_filesystem_available); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_filesystem_available)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filesystem");
    {
	guestfs_h *	g;
	char *	filesystem = (char *)SvPV_nolen(ST(1));
#line 2927 "lib/Sys/Guestfs.xs"
      int r;
#line 7407 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::filesystem_available(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::filesystem_available(): g is not a blessed HV reference");
    };
#line 2929 "lib/Sys/Guestfs.xs"
      r = guestfs_filesystem_available (g, filesystem);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7426 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fill)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, c, len, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	c = (int)SvIV(ST(1));
	int	len = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 2943 "lib/Sys/Guestfs.xs"
      int r;
#line 7453 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fill(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fill(): g is not a blessed HV reference");
    };
#line 2945 "lib/Sys/Guestfs.xs"
      r = guestfs_fill (g, c, len, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7470 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fill_dir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fill_dir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, dir, nr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
	int	nr = (int)SvIV(ST(2));
#line 2955 "lib/Sys/Guestfs.xs"
      int r;
#line 7495 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fill_dir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fill_dir(): g is not a blessed HV reference");
    };
#line 2957 "lib/Sys/Guestfs.xs"
      r = guestfs_fill_dir (g, dir, nr);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7512 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_fill_pattern); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fill_pattern)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, pattern, len, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	int	len = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 2968 "lib/Sys/Guestfs.xs"
      int r;
#line 7538 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fill_pattern(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fill_pattern(): g is not a blessed HV reference");
    };
#line 2970 "lib/Sys/Guestfs.xs"
      r = guestfs_fill_pattern (g, pattern, len, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7555 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_find); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_find)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 2979 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 7580 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::find(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::find(): g is not a blessed HV reference");
    };
#line 2982 "lib/Sys/Guestfs.xs"
      r = guestfs_find (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 7604 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_find0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_find0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, directory, files");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	files = (char *)SvPV_nolen(ST(2));
#line 2999 "lib/Sys/Guestfs.xs"
      int r;
#line 7629 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::find0(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::find0(): g is not a blessed HV reference");
    };
#line 3001 "lib/Sys/Guestfs.xs"
      r = guestfs_find0 (g, directory, files);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7646 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_findfs_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_findfs_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 3010 "lib/Sys/Guestfs.xs"
      char *r;
#line 7668 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::findfs_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::findfs_label(): g is not a blessed HV reference");
    };
#line 3012 "lib/Sys/Guestfs.xs"
      r = guestfs_findfs_label (g, label);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7688 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_findfs_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_findfs_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, uuid");
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
#line 3025 "lib/Sys/Guestfs.xs"
      char *r;
#line 7711 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::findfs_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::findfs_uuid(): g is not a blessed HV reference");
    };
#line 3027 "lib/Sys/Guestfs.xs"
      r = guestfs_findfs_uuid (g, uuid);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7731 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fsck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fsck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, fstype, device");
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 3041 "lib/Sys/Guestfs.xs"
      int r;
#line 7755 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fsck(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fsck(): g is not a blessed HV reference");
    };
#line 3043 "lib/Sys/Guestfs.xs"
      r = guestfs_fsck (g, fstype, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7774 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_fstrim); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_fstrim)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 3055 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_fstrim_argv optargs_s = { .bitmask = 0 };
      struct guestfs_fstrim_argv *optargs = &optargs_s;
      size_t items_i;
#line 7802 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::fstrim(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::fstrim(): g is not a blessed HV reference");
    };
#line 3060 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "offset")) {
          optargs_s.offset = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_FSTRIM_OFFSET_BITMASK;
        }
        else if (STREQ (this_arg, "length")) {
          optargs_s.length = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_FSTRIM_LENGTH_BITMASK;
        }
        else if (STREQ (this_arg, "minimumfreeextent")) {
          optargs_s.minimumfreeextent = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_FSTRIM_MINIMUMFREEEXTENT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_fstrim_argv (g, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 7845 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_get_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3094 "lib/Sys/Guestfs.xs"
      const char *r;
#line 7866 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_append(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_append(): g is not a blessed HV reference");
    };
#line 3096 "lib/Sys/Guestfs.xs"
      r = guestfs_get_append (g);
      if (r == NULL)
        RETVAL = &PL_sv_undef;
      else
        RETVAL = newSVpv (r, 0);
#line 7886 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_attach_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_attach_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3108 "lib/Sys/Guestfs.xs"
      char *r;
#line 7908 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_attach_method(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_attach_method(): g is not a blessed HV reference");
    };
#line 3110 "lib/Sys/Guestfs.xs"
      r = guestfs_get_attach_method (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 7928 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_autosync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_autosync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3122 "lib/Sys/Guestfs.xs"
      int r;
#line 7950 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_autosync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_autosync(): g is not a blessed HV reference");
    };
#line 3124 "lib/Sys/Guestfs.xs"
      r = guestfs_get_autosync (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 7969 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_backend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_backend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3135 "lib/Sys/Guestfs.xs"
      char *r;
#line 7991 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_backend(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_backend(): g is not a blessed HV reference");
    };
#line 3137 "lib/Sys/Guestfs.xs"
      r = guestfs_get_backend (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8011 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_backend_setting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_backend_setting)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, name");
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
#line 3150 "lib/Sys/Guestfs.xs"
      char *r;
#line 8034 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_backend_setting(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_backend_setting(): g is not a blessed HV reference");
    };
#line 3152 "lib/Sys/Guestfs.xs"
      r = guestfs_get_backend_setting (g, name);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8054 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_backend_settings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_backend_settings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 3164 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 8079 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_backend_settings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_backend_settings(): g is not a blessed HV reference");
    };
#line 3167 "lib/Sys/Guestfs.xs"
      r = guestfs_get_backend_settings (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 8103 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_get_cachedir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_cachedir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3182 "lib/Sys/Guestfs.xs"
      char *r;
#line 8124 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_cachedir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_cachedir(): g is not a blessed HV reference");
    };
#line 3184 "lib/Sys/Guestfs.xs"
      r = guestfs_get_cachedir (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8144 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_direct); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_direct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3196 "lib/Sys/Guestfs.xs"
      int r;
#line 8166 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_direct(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_direct(): g is not a blessed HV reference");
    };
#line 3198 "lib/Sys/Guestfs.xs"
      r = guestfs_get_direct (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8185 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2attrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2attrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 3210 "lib/Sys/Guestfs.xs"
      char *r;
#line 8208 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2attrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2attrs(): g is not a blessed HV reference");
    };
#line 3212 "lib/Sys/Guestfs.xs"
      r = guestfs_get_e2attrs (g, file);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8228 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 3225 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 8251 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2generation(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2generation(): g is not a blessed HV reference");
    };
#line 3227 "lib/Sys/Guestfs.xs"
      r = guestfs_get_e2generation (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 8270 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 3239 "lib/Sys/Guestfs.xs"
      char *r;
#line 8293 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2label(): g is not a blessed HV reference");
    };
#line 3241 "lib/Sys/Guestfs.xs"
      r = guestfs_get_e2label (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8313 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_e2uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_e2uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 3254 "lib/Sys/Guestfs.xs"
      char *r;
#line 8336 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_e2uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_e2uuid(): g is not a blessed HV reference");
    };
#line 3256 "lib/Sys/Guestfs.xs"
      r = guestfs_get_e2uuid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8356 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_hv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_hv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3268 "lib/Sys/Guestfs.xs"
      char *r;
#line 8378 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_hv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_hv(): g is not a blessed HV reference");
    };
#line 3270 "lib/Sys/Guestfs.xs"
      r = guestfs_get_hv (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8398 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_identifier); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_identifier)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3282 "lib/Sys/Guestfs.xs"
      const char *r;
#line 8420 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_identifier(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_identifier(): g is not a blessed HV reference");
    };
#line 3284 "lib/Sys/Guestfs.xs"
      r = guestfs_get_identifier (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8439 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credential_challenge); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credential_challenge)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, index");
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
#line 3296 "lib/Sys/Guestfs.xs"
      char *r;
#line 8462 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credential_challenge(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credential_challenge(): g is not a blessed HV reference");
    };
#line 3298 "lib/Sys/Guestfs.xs"
      r = guestfs_get_libvirt_requested_credential_challenge (g, index);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8482 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credential_defresult); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credential_defresult)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, index");
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
#line 3311 "lib/Sys/Guestfs.xs"
      char *r;
#line 8505 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credential_defresult(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credential_defresult(): g is not a blessed HV reference");
    };
#line 3313 "lib/Sys/Guestfs.xs"
      r = guestfs_get_libvirt_requested_credential_defresult (g, index);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8525 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credential_prompt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credential_prompt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, index");
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
#line 3326 "lib/Sys/Guestfs.xs"
      char *r;
#line 8548 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credential_prompt(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credential_prompt(): g is not a blessed HV reference");
    };
#line 3328 "lib/Sys/Guestfs.xs"
      r = guestfs_get_libvirt_requested_credential_prompt (g, index);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 8568 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_libvirt_requested_credentials); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_libvirt_requested_credentials)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 3340 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 8593 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_libvirt_requested_credentials(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_libvirt_requested_credentials(): g is not a blessed HV reference");
    };
#line 3343 "lib/Sys/Guestfs.xs"
      r = guestfs_get_libvirt_requested_credentials (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 8617 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_get_memsize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_memsize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3358 "lib/Sys/Guestfs.xs"
      int r;
#line 8638 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_memsize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_memsize(): g is not a blessed HV reference");
    };
#line 3360 "lib/Sys/Guestfs.xs"
      r = guestfs_get_memsize (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8657 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_network); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_network)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3371 "lib/Sys/Guestfs.xs"
      int r;
#line 8679 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_network(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_network(): g is not a blessed HV reference");
    };
#line 3373 "lib/Sys/Guestfs.xs"
      r = guestfs_get_network (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8698 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3384 "lib/Sys/Guestfs.xs"
      const char *r;
#line 8720 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_path(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_path(): g is not a blessed HV reference");
    };
#line 3386 "lib/Sys/Guestfs.xs"
      r = guestfs_get_path (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8739 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_pgroup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_pgroup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3397 "lib/Sys/Guestfs.xs"
      int r;
#line 8761 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_pgroup(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_pgroup(): g is not a blessed HV reference");
    };
#line 3399 "lib/Sys/Guestfs.xs"
      r = guestfs_get_pgroup (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8780 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_pid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_pid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3410 "lib/Sys/Guestfs.xs"
      int r;
#line 8802 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_pid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_pid(): g is not a blessed HV reference");
    };
#line 3412 "lib/Sys/Guestfs.xs"
      r = guestfs_get_pid (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8821 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_program); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_program)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3423 "lib/Sys/Guestfs.xs"
      const char *r;
#line 8843 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_program(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_program(): g is not a blessed HV reference");
    };
#line 3425 "lib/Sys/Guestfs.xs"
      r = guestfs_get_program (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8862 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_qemu); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_qemu)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3436 "lib/Sys/Guestfs.xs"
      const char *r;
#line 8884 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_qemu(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_qemu(): g is not a blessed HV reference");
    };
#line 3438 "lib/Sys/Guestfs.xs"
      r = guestfs_get_qemu (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 8903 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_recovery_proc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_recovery_proc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3449 "lib/Sys/Guestfs.xs"
      int r;
#line 8925 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_recovery_proc(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_recovery_proc(): g is not a blessed HV reference");
    };
#line 3451 "lib/Sys/Guestfs.xs"
      r = guestfs_get_recovery_proc (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8944 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_selinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_selinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3462 "lib/Sys/Guestfs.xs"
      int r;
#line 8966 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_selinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_selinux(): g is not a blessed HV reference");
    };
#line 3464 "lib/Sys/Guestfs.xs"
      r = guestfs_get_selinux (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 8985 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_smp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_smp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3475 "lib/Sys/Guestfs.xs"
      int r;
#line 9007 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_smp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_smp(): g is not a blessed HV reference");
    };
#line 3477 "lib/Sys/Guestfs.xs"
      r = guestfs_get_smp (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9026 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_state); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_state)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3488 "lib/Sys/Guestfs.xs"
      int r;
#line 9048 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_state(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_state(): g is not a blessed HV reference");
    };
#line 3490 "lib/Sys/Guestfs.xs"
      r = guestfs_get_state (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9067 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_tmpdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_tmpdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3501 "lib/Sys/Guestfs.xs"
      char *r;
#line 9089 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_tmpdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_tmpdir(): g is not a blessed HV reference");
    };
#line 3503 "lib/Sys/Guestfs.xs"
      r = guestfs_get_tmpdir (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 9109 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_trace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_trace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3515 "lib/Sys/Guestfs.xs"
      int r;
#line 9131 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_trace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_trace(): g is not a blessed HV reference");
    };
#line 3517 "lib/Sys/Guestfs.xs"
      r = guestfs_get_trace (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9150 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_umask); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_umask)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3528 "lib/Sys/Guestfs.xs"
      int r;
#line 9172 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_umask(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_umask(): g is not a blessed HV reference");
    };
#line 3530 "lib/Sys/Guestfs.xs"
      r = guestfs_get_umask (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9191 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_get_verbose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_get_verbose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3541 "lib/Sys/Guestfs.xs"
      int r;
#line 9213 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::get_verbose(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::get_verbose(): g is not a blessed HV reference");
    };
#line 3543 "lib/Sys/Guestfs.xs"
      r = guestfs_get_verbose (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 9232 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_getcon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_getcon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3554 "lib/Sys/Guestfs.xs"
      char *r;
#line 9254 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::getcon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::getcon(): g is not a blessed HV reference");
    };
#line 3556 "lib/Sys/Guestfs.xs"
      r = guestfs_getcon (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 9274 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_getxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_getxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, name");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 3570 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 9299 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::getxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::getxattr(): g is not a blessed HV reference");
    };
#line 3573 "lib/Sys/Guestfs.xs"
      r = guestfs_getxattr (g, path, name, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 9319 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_getxattrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_getxattrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 3586 "lib/Sys/Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 9346 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::getxattrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::getxattrs(): g is not a blessed HV reference");
    };
#line 3590 "lib/Sys/Guestfs.xs"
      r = guestfs_getxattrs (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 9371 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_glob_expand); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_glob_expand)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, pattern");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
#line 3607 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 9396 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::glob_expand(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::glob_expand(): g is not a blessed HV reference");
    };
#line 3610 "lib/Sys/Guestfs.xs"
      r = guestfs_glob_expand (g, pattern);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9420 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_grep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_grep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, regex, path, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 3627 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
      struct guestfs_grep_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_grep_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 9449 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::grep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::grep(): g is not a blessed HV reference");
    };
#line 3633 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "extended")) {
          optargs_s.extended = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_EXTENDED_BITMASK;
        }
        else if (STREQ (this_arg, "fixed")) {
          optargs_s.fixed = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_FIXED_BITMASK;
        }
        else if (STREQ (this_arg, "insensitive")) {
          optargs_s.insensitive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_INSENSITIVE_BITMASK;
        }
        else if (STREQ (this_arg, "compressed")) {
          optargs_s.compressed = SvIV (ST (items_i+1));
          this_mask = GUESTFS_GREP_OPTS_COMPRESSED_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_grep_opts_argv (g, regex, path, optargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9503 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_grepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_grepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 3680 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 9529 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::grepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::grepi(): g is not a blessed HV reference");
    };
#line 3683 "lib/Sys/Guestfs.xs"
      r = guestfs_grepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9553 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_grub_install); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_grub_install)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, root, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 3700 "lib/Sys/Guestfs.xs"
      int r;
#line 9578 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::grub_install(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::grub_install(): g is not a blessed HV reference");
    };
#line 3702 "lib/Sys/Guestfs.xs"
      r = guestfs_grub_install (g, root, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9595 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_head); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_head)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 3711 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 9620 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::head(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::head(): g is not a blessed HV reference");
    };
#line 3714 "lib/Sys/Guestfs.xs"
      r = guestfs_head (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9644 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_head_n); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_head_n)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nrlines, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	nrlines = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 3731 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 9670 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::head_n(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::head_n(): g is not a blessed HV reference");
    };
#line 3734 "lib/Sys/Guestfs.xs"
      r = guestfs_head_n (g, nrlines, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 9694 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hexdump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hexdump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 3750 "lib/Sys/Guestfs.xs"
      char *r;
#line 9716 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hexdump(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hexdump(): g is not a blessed HV reference");
    };
#line 3752 "lib/Sys/Guestfs.xs"
      r = guestfs_hexdump (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 9736 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 3764 "lib/Sys/Guestfs.xs"
      int r;
#line 9760 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_close(): g is not a blessed HV reference");
    };
#line 3766 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9777 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_commit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 3775 "lib/Sys/Guestfs.xs"
      int r;
#line 9801 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_commit(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_commit(): g is not a blessed HV reference");
    };
#line 3777 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_commit (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9818 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_add_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_add_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, parent, name");
    {
	guestfs_h *	g;
	int64_t    parent = my_SvIV64 (ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 3787 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 9841 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_add_child(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_add_child(): g is not a blessed HV reference");
    };
#line 3789 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_add_child (g, parent, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 9860 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_children)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3801 "lib/Sys/Guestfs.xs"
      struct guestfs_hivex_node_list *r;
      size_t i;
      HV *hv;
#line 9887 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_children(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_children(): g is not a blessed HV reference");
    };
#line 3805 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_children (g, nodeh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "hivex_node_h", 12, my_newSVll (r->val[i].hivex_node_h), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_hivex_node_list (r);
#line 9911 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_delete_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_delete_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3821 "lib/Sys/Guestfs.xs"
      int r;
#line 9935 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_delete_child(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_delete_child(): g is not a blessed HV reference");
    };
#line 3823 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_delete_child (g, nodeh);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 9952 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_get_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_get_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nodeh, name");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 3833 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 9975 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_get_child(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_get_child(): g is not a blessed HV reference");
    };
#line 3835 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_get_child (g, nodeh, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 9994 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_get_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_get_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nodeh, key");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
#line 3848 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 10018 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_get_value(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_get_value(): g is not a blessed HV reference");
    };
#line 3850 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_get_value (g, nodeh, key);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10037 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3862 "lib/Sys/Guestfs.xs"
      char *r;
#line 10060 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_name(): g is not a blessed HV reference");
    };
#line 3864 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_name (g, nodeh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10080 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_parent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_parent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3877 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 10103 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_parent(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_parent(): g is not a blessed HV reference");
    };
#line 3879 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_parent (g, nodeh);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10122 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_node_set_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_set_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, nodeh, key, t, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int64_t    t = my_SvIV64 (ST(3));
	char *	val = (char *)SvPV_nolen(ST(4));
	size_t	val_size = SvCUR (ST(4));
#line 3895 "lib/Sys/Guestfs.xs"
      int r;
#line 10151 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_set_value(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_set_value(): g is not a blessed HV reference");
    };
#line 3897 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_set_value (g, nodeh, key, t, val, val_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10168 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_node_values); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_node_values)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, nodeh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    nodeh = my_SvIV64 (ST(1));
#line 3906 "lib/Sys/Guestfs.xs"
      struct guestfs_hivex_value_list *r;
      size_t i;
      HV *hv;
#line 10194 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_node_values(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_node_values(): g is not a blessed HV reference");
    };
#line 3910 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_node_values (g, nodeh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "hivex_value_h", 13, my_newSVll (r->val[i].hivex_value_h), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_hivex_value_list (r);
#line 10218 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, filename, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 3926 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_hivex_open_argv optargs_s = { .bitmask = 0 };
      struct guestfs_hivex_open_argv *optargs = &optargs_s;
      size_t items_i;
#line 10245 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_open(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_open(): g is not a blessed HV reference");
    };
#line 3931 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "verbose")) {
          optargs_s.verbose = SvIV (ST (items_i+1));
          this_mask = GUESTFS_HIVEX_OPEN_VERBOSE_BITMASK;
        }
        else if (STREQ (this_arg, "debug")) {
          optargs_s.debug = SvIV (ST (items_i+1));
          this_mask = GUESTFS_HIVEX_OPEN_DEBUG_BITMASK;
        }
        else if (STREQ (this_arg, "write")) {
          optargs_s.write = SvIV (ST (items_i+1));
          this_mask = GUESTFS_HIVEX_OPEN_WRITE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_hivex_open_argv (g, filename, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10288 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_hivex_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_root)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 3965 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 10309 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_root(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_root(): g is not a blessed HV reference");
    };
#line 3967 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_root (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10328 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 3979 "lib/Sys/Guestfs.xs"
      char *r;
#line 10351 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_key(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_key(): g is not a blessed HV reference");
    };
#line 3981 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_value_key (g, valueh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10371 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 3994 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 10394 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_type(): g is not a blessed HV reference");
    };
#line 3996 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_value_type (g, valueh);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10413 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_utf8); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_utf8)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 4008 "lib/Sys/Guestfs.xs"
      char *r;
#line 10436 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_utf8(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_utf8(): g is not a blessed HV reference");
    };
#line 4010 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_value_utf8 (g, valueh);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10456 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_hivex_value_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_hivex_value_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, valueh");
    {
	guestfs_h *	g;
	int64_t    valueh = my_SvIV64 (ST(1));
#line 4023 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 10480 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::hivex_value_value(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::hivex_value_value(): g is not a blessed HV reference");
    };
#line 4026 "lib/Sys/Guestfs.xs"
      r = guestfs_hivex_value_value (g, valueh, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 10500 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_initrd_cat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_initrd_cat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, initrdpath, filename");
    {
	guestfs_h *	g;
	char *	initrdpath = (char *)SvPV_nolen(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
#line 4040 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 10525 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::initrd_cat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::initrd_cat(): g is not a blessed HV reference");
    };
#line 4043 "lib/Sys/Guestfs.xs"
      r = guestfs_initrd_cat (g, initrdpath, filename, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 10545 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_initrd_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_initrd_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 4056 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 10571 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::initrd_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::initrd_list(): g is not a blessed HV reference");
    };
#line 4059 "lib/Sys/Guestfs.xs"
      r = guestfs_initrd_list (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 10595 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_add_watch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_add_watch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, mask");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	mask = (int)SvIV(ST(2));
#line 4076 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 10618 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_add_watch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_add_watch(): g is not a blessed HV reference");
    };
#line 4078 "lib/Sys/Guestfs.xs"
      r = guestfs_inotify_add_watch (g, path, mask);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 10637 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inotify_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4089 "lib/Sys/Guestfs.xs"
      int r;
#line 10661 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_close(): g is not a blessed HV reference");
    };
#line 4091 "lib/Sys/Guestfs.xs"
      r = guestfs_inotify_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10678 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_files); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_files)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4099 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 10702 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_files(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_files(): g is not a blessed HV reference");
    };
#line 4102 "lib/Sys/Guestfs.xs"
      r = guestfs_inotify_files (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 10726 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, maxevents");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	maxevents = (int)SvIV(ST(1));
#line 4118 "lib/Sys/Guestfs.xs"
      int r;
#line 10750 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_init(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_init(): g is not a blessed HV reference");
    };
#line 4120 "lib/Sys/Guestfs.xs"
      r = guestfs_inotify_init (g, maxevents);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10767 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4128 "lib/Sys/Guestfs.xs"
      struct guestfs_inotify_event_list *r;
      size_t i;
      HV *hv;
#line 10792 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_read(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_read(): g is not a blessed HV reference");
    };
#line 4132 "lib/Sys/Guestfs.xs"
      r = guestfs_inotify_read (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "in_wd", 5, my_newSVll (r->val[i].in_wd), 0);
        (void) hv_store (hv, "in_mask", 7, newSVnv (r->val[i].in_mask), 0);
        (void) hv_store (hv, "in_cookie", 9, newSVnv (r->val[i].in_cookie), 0);
        (void) hv_store (hv, "in_name", 7, newSVpv (r->val[i].in_name, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_inotify_event_list (r);
#line 10819 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inotify_rm_watch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inotify_rm_watch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, wd");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	wd = (int)SvIV(ST(1));
#line 4151 "lib/Sys/Guestfs.xs"
      int r;
#line 10843 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inotify_rm_watch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inotify_rm_watch(): g is not a blessed HV reference");
    };
#line 4153 "lib/Sys/Guestfs.xs"
      r = guestfs_inotify_rm_watch (g, wd);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 10860 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_arch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_arch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4162 "lib/Sys/Guestfs.xs"
      char *r;
#line 10882 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_arch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_arch(): g is not a blessed HV reference");
    };
#line 4164 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_arch (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10902 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_distro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_distro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4177 "lib/Sys/Guestfs.xs"
      char *r;
#line 10925 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_distro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_distro(): g is not a blessed HV reference");
    };
#line 4179 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_distro (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 10945 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_drive_mappings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_drive_mappings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4192 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 10971 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_drive_mappings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_drive_mappings(): g is not a blessed HV reference");
    };
#line 4195 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_drive_mappings (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 10995 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_filesystems); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_filesystems)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4211 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 11020 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_filesystems(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_filesystems(): g is not a blessed HV reference");
    };
#line 4214 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_filesystems (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11044 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4230 "lib/Sys/Guestfs.xs"
      char *r;
#line 11066 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_format(): g is not a blessed HV reference");
    };
#line 4232 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_format (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11086 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_hostname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_hostname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4245 "lib/Sys/Guestfs.xs"
      char *r;
#line 11109 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_hostname(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_hostname(): g is not a blessed HV reference");
    };
#line 4247 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_hostname (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11129 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_icon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_icon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, root, ...");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4260 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
      struct guestfs_inspect_get_icon_argv optargs_s = { .bitmask = 0 };
      struct guestfs_inspect_get_icon_argv *optargs = &optargs_s;
      size_t items_i;
#line 11156 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_icon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_icon(): g is not a blessed HV reference");
    };
#line 4266 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "favicon")) {
          optargs_s.favicon = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INSPECT_GET_ICON_FAVICON_BITMASK;
        }
        else if (STREQ (this_arg, "highquality")) {
          optargs_s.highquality = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INSPECT_GET_ICON_HIGHQUALITY_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_inspect_get_icon_argv (g, root, &size, optargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 11198 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_major_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_major_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4301 "lib/Sys/Guestfs.xs"
      int r;
#line 11221 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_major_version(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_major_version(): g is not a blessed HV reference");
    };
#line 4303 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_major_version (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11240 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_minor_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_minor_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4315 "lib/Sys/Guestfs.xs"
      int r;
#line 11263 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_minor_version(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_minor_version(): g is not a blessed HV reference");
    };
#line 4317 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_minor_version (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11282 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_mountpoints); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_mountpoints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4329 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 11308 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_mountpoints(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_mountpoints(): g is not a blessed HV reference");
    };
#line 4332 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_mountpoints (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11332 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_package_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_package_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4348 "lib/Sys/Guestfs.xs"
      char *r;
#line 11354 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_package_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_package_format(): g is not a blessed HV reference");
    };
#line 4350 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_package_format (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11374 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_package_management); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_package_management)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4363 "lib/Sys/Guestfs.xs"
      char *r;
#line 11397 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_package_management(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_package_management(): g is not a blessed HV reference");
    };
#line 4365 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_package_management (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11417 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_product_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_product_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4378 "lib/Sys/Guestfs.xs"
      char *r;
#line 11440 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_product_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_product_name(): g is not a blessed HV reference");
    };
#line 4380 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_product_name (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11460 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_product_variant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_product_variant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4393 "lib/Sys/Guestfs.xs"
      char *r;
#line 11483 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_product_variant(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_product_variant(): g is not a blessed HV reference");
    };
#line 4395 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_product_variant (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11503 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_roots); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_roots)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4407 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 11528 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_roots(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_roots(): g is not a blessed HV reference");
    };
#line 4410 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_roots (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11552 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_get_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4426 "lib/Sys/Guestfs.xs"
      char *r;
#line 11574 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_type(): g is not a blessed HV reference");
    };
#line 4428 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_type (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11594 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_windows_current_control_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_windows_current_control_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4441 "lib/Sys/Guestfs.xs"
      char *r;
#line 11617 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_windows_current_control_set(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_windows_current_control_set(): g is not a blessed HV reference");
    };
#line 4443 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_windows_current_control_set (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11637 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_get_windows_systemroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_get_windows_systemroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4456 "lib/Sys/Guestfs.xs"
      char *r;
#line 11660 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_get_windows_systemroot(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_get_windows_systemroot(): g is not a blessed HV reference");
    };
#line 4458 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_get_windows_systemroot (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 11680 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_is_live); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_is_live)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4471 "lib/Sys/Guestfs.xs"
      int r;
#line 11703 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_is_live(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_is_live(): g is not a blessed HV reference");
    };
#line 4473 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_is_live (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11722 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_is_multipart); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_is_multipart)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4485 "lib/Sys/Guestfs.xs"
      int r;
#line 11745 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_is_multipart(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_is_multipart(): g is not a blessed HV reference");
    };
#line 4487 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_is_multipart (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11764 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_is_netinst); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_is_netinst)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4499 "lib/Sys/Guestfs.xs"
      int r;
#line 11787 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_is_netinst(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_is_netinst(): g is not a blessed HV reference");
    };
#line 4501 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_is_netinst (g, root);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 11806 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_inspect_list_applications); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_list_applications)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4513 "lib/Sys/Guestfs.xs"
      struct guestfs_application_list *r;
      size_t i;
      HV *hv;
#line 11833 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_list_applications(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_list_applications(): g is not a blessed HV reference");
    };
#line 4517 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_list_applications (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "app_name", 8, newSVpv (r->val[i].app_name, 0), 0);
        (void) hv_store (hv, "app_display_name", 16, newSVpv (r->val[i].app_display_name, 0), 0);
        (void) hv_store (hv, "app_epoch", 9, newSVnv (r->val[i].app_epoch), 0);
        (void) hv_store (hv, "app_version", 11, newSVpv (r->val[i].app_version, 0), 0);
        (void) hv_store (hv, "app_release", 11, newSVpv (r->val[i].app_release, 0), 0);
        (void) hv_store (hv, "app_install_path", 16, newSVpv (r->val[i].app_install_path, 0), 0);
        (void) hv_store (hv, "app_trans_path", 14, newSVpv (r->val[i].app_trans_path, 0), 0);
        (void) hv_store (hv, "app_publisher", 13, newSVpv (r->val[i].app_publisher, 0), 0);
        (void) hv_store (hv, "app_url", 7, newSVpv (r->val[i].app_url, 0), 0);
        (void) hv_store (hv, "app_source_package", 18, newSVpv (r->val[i].app_source_package, 0), 0);
        (void) hv_store (hv, "app_summary", 11, newSVpv (r->val[i].app_summary, 0), 0);
        (void) hv_store (hv, "app_description", 15, newSVpv (r->val[i].app_description, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_application_list (r);
#line 11868 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_list_applications2); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_list_applications2)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, root");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	root = (char *)SvPV_nolen(ST(1));
#line 4544 "lib/Sys/Guestfs.xs"
      struct guestfs_application2_list *r;
      size_t i;
      HV *hv;
#line 11894 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_list_applications2(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_list_applications2(): g is not a blessed HV reference");
    };
#line 4548 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_list_applications2 (g, root);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "app2_name", 9, newSVpv (r->val[i].app2_name, 0), 0);
        (void) hv_store (hv, "app2_display_name", 17, newSVpv (r->val[i].app2_display_name, 0), 0);
        (void) hv_store (hv, "app2_epoch", 10, newSVnv (r->val[i].app2_epoch), 0);
        (void) hv_store (hv, "app2_version", 12, newSVpv (r->val[i].app2_version, 0), 0);
        (void) hv_store (hv, "app2_release", 12, newSVpv (r->val[i].app2_release, 0), 0);
        (void) hv_store (hv, "app2_arch", 9, newSVpv (r->val[i].app2_arch, 0), 0);
        (void) hv_store (hv, "app2_install_path", 17, newSVpv (r->val[i].app2_install_path, 0), 0);
        (void) hv_store (hv, "app2_trans_path", 15, newSVpv (r->val[i].app2_trans_path, 0), 0);
        (void) hv_store (hv, "app2_publisher", 14, newSVpv (r->val[i].app2_publisher, 0), 0);
        (void) hv_store (hv, "app2_url", 8, newSVpv (r->val[i].app2_url, 0), 0);
        (void) hv_store (hv, "app2_source_package", 19, newSVpv (r->val[i].app2_source_package, 0), 0);
        (void) hv_store (hv, "app2_summary", 12, newSVpv (r->val[i].app2_summary, 0), 0);
        (void) hv_store (hv, "app2_description", 16, newSVpv (r->val[i].app2_description, 0), 0);
        (void) hv_store (hv, "app2_spare1", 11, newSVpv (r->val[i].app2_spare1, 0), 0);
        (void) hv_store (hv, "app2_spare2", 11, newSVpv (r->val[i].app2_spare2, 0), 0);
        (void) hv_store (hv, "app2_spare3", 11, newSVpv (r->val[i].app2_spare3, 0), 0);
        (void) hv_store (hv, "app2_spare4", 11, newSVpv (r->val[i].app2_spare4, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_application2_list (r);
#line 11934 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_inspect_os); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_inspect_os)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4579 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 11958 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::inspect_os(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::inspect_os(): g is not a blessed HV reference");
    };
#line 4582 "lib/Sys/Guestfs.xs"
      r = guestfs_inspect_os (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 11982 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_exit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_exit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4597 "lib/Sys/Guestfs.xs"
      int r;
#line 12005 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_exit(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_exit(): g is not a blessed HV reference");
    };
#line 4599 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_exit (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12022 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 10)
       croak_xs_usage(cv,  "g, str, optstr, strlist, b, integer, integer64, filein, fileout, bufferin, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	str = (char *)SvPV_nolen(ST(1));
	char *	optstr = SvOK(ST(2)) ? SvPV_nolen(ST(2)) : NULL;
	char **	strlist = XS_unpack_charPtrPtr(ST(3));
	int	b = (int)SvIV(ST(4));
	int	integer = (int)SvIV(ST(5));
	int64_t    integer64 = my_SvIV64 (ST(6));
	char *	filein = (char *)SvPV_nolen(ST(7));
	char *	fileout = (char *)SvPV_nolen(ST(8));
	char *	bufferin = (char *)SvPV_nolen(ST(9));
	size_t	bufferin_size = SvCUR (ST(9));
#line 4617 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_internal_test_argv optargs_s = { .bitmask = 0 };
      struct guestfs_internal_test_argv *optargs = &optargs_s;
      size_t items_i;
#line 12058 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test(): g is not a blessed HV reference");
    };
#line 4622 "lib/Sys/Guestfs.xs"
      if (((items - 10) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 10; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "obool")) {
          optargs_s.obool = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OBOOL_BITMASK;
        }
        else if (STREQ (this_arg, "oint")) {
          optargs_s.oint = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OINT_BITMASK;
        }
        else if (STREQ (this_arg, "oint64")) {
          optargs_s.oint64 = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OINT64_BITMASK;
        }
        else if (STREQ (this_arg, "ostring")) {
          optargs_s.ostring = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_OSTRING_BITMASK;
        }
        else if (STREQ (this_arg, "ostringlist")) {
          size_t i, len;
          char **r;
          SV *arg;
          AV *av;
          SV **svp;

          arg = ST (items_i+1);
          if (!SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
            croak ("array reference expected for '%s' argument", "ostringlist");
          av = (AV *) SvRV (ST (items_i+1));

          /* Note av_len returns index of final element. */
          len = av_len (av) + 1;

          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));
          for (i = 0; i < len; ++i) {
            svp = av_fetch (av, i, 0);
            r[i] = SvPV_nolen (*svp);
          }
          r[i] = NULL;
          optargs_s.ostringlist = r;
          this_mask = GUESTFS_INTERNAL_TEST_OSTRINGLIST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_internal_test_argv (g, str, optstr, strlist, b, integer, integer64, filein, fileout, bufferin, bufferin_size, optargs);
      free (strlist);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12130 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_63_optargs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_63_optargs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "g, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4685 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_internal_test_63_optargs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_internal_test_63_optargs_argv *optargs = &optargs_s;
      size_t items_i;
#line 12156 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_63_optargs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_63_optargs(): g is not a blessed HV reference");
    };
#line 4690 "lib/Sys/Guestfs.xs"
      if (((items - 1) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 1; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "opt1")) {
          optargs_s.opt1 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT1_BITMASK;
        }
        else if (STREQ (this_arg, "opt2")) {
          optargs_s.opt2 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT2_BITMASK;
        }
        else if (STREQ (this_arg, "opt3")) {
          optargs_s.opt3 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT3_BITMASK;
        }
        else if (STREQ (this_arg, "opt4")) {
          optargs_s.opt4 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT4_BITMASK;
        }
        else if (STREQ (this_arg, "opt5")) {
          optargs_s.opt5 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT5_BITMASK;
        }
        else if (STREQ (this_arg, "opt6")) {
          optargs_s.opt6 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT6_BITMASK;
        }
        else if (STREQ (this_arg, "opt7")) {
          optargs_s.opt7 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT7_BITMASK;
        }
        else if (STREQ (this_arg, "opt8")) {
          optargs_s.opt8 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT8_BITMASK;
        }
        else if (STREQ (this_arg, "opt9")) {
          optargs_s.opt9 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT9_BITMASK;
        }
        else if (STREQ (this_arg, "opt10")) {
          optargs_s.opt10 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT10_BITMASK;
        }
        else if (STREQ (this_arg, "opt11")) {
          optargs_s.opt11 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT11_BITMASK;
        }
        else if (STREQ (this_arg, "opt12")) {
          optargs_s.opt12 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT12_BITMASK;
        }
        else if (STREQ (this_arg, "opt13")) {
          optargs_s.opt13 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT13_BITMASK;
        }
        else if (STREQ (this_arg, "opt14")) {
          optargs_s.opt14 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT14_BITMASK;
        }
        else if (STREQ (this_arg, "opt15")) {
          optargs_s.opt15 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT15_BITMASK;
        }
        else if (STREQ (this_arg, "opt16")) {
          optargs_s.opt16 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT16_BITMASK;
        }
        else if (STREQ (this_arg, "opt17")) {
          optargs_s.opt17 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT17_BITMASK;
        }
        else if (STREQ (this_arg, "opt18")) {
          optargs_s.opt18 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT18_BITMASK;
        }
        else if (STREQ (this_arg, "opt19")) {
          optargs_s.opt19 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT19_BITMASK;
        }
        else if (STREQ (this_arg, "opt20")) {
          optargs_s.opt20 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT20_BITMASK;
        }
        else if (STREQ (this_arg, "opt21")) {
          optargs_s.opt21 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT21_BITMASK;
        }
        else if (STREQ (this_arg, "opt22")) {
          optargs_s.opt22 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT22_BITMASK;
        }
        else if (STREQ (this_arg, "opt23")) {
          optargs_s.opt23 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT23_BITMASK;
        }
        else if (STREQ (this_arg, "opt24")) {
          optargs_s.opt24 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT24_BITMASK;
        }
        else if (STREQ (this_arg, "opt25")) {
          optargs_s.opt25 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT25_BITMASK;
        }
        else if (STREQ (this_arg, "opt26")) {
          optargs_s.opt26 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT26_BITMASK;
        }
        else if (STREQ (this_arg, "opt27")) {
          optargs_s.opt27 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT27_BITMASK;
        }
        else if (STREQ (this_arg, "opt28")) {
          optargs_s.opt28 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT28_BITMASK;
        }
        else if (STREQ (this_arg, "opt29")) {
          optargs_s.opt29 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT29_BITMASK;
        }
        else if (STREQ (this_arg, "opt30")) {
          optargs_s.opt30 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT30_BITMASK;
        }
        else if (STREQ (this_arg, "opt31")) {
          optargs_s.opt31 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT31_BITMASK;
        }
        else if (STREQ (this_arg, "opt32")) {
          optargs_s.opt32 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT32_BITMASK;
        }
        else if (STREQ (this_arg, "opt33")) {
          optargs_s.opt33 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT33_BITMASK;
        }
        else if (STREQ (this_arg, "opt34")) {
          optargs_s.opt34 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT34_BITMASK;
        }
        else if (STREQ (this_arg, "opt35")) {
          optargs_s.opt35 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT35_BITMASK;
        }
        else if (STREQ (this_arg, "opt36")) {
          optargs_s.opt36 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT36_BITMASK;
        }
        else if (STREQ (this_arg, "opt37")) {
          optargs_s.opt37 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT37_BITMASK;
        }
        else if (STREQ (this_arg, "opt38")) {
          optargs_s.opt38 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT38_BITMASK;
        }
        else if (STREQ (this_arg, "opt39")) {
          optargs_s.opt39 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT39_BITMASK;
        }
        else if (STREQ (this_arg, "opt40")) {
          optargs_s.opt40 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT40_BITMASK;
        }
        else if (STREQ (this_arg, "opt41")) {
          optargs_s.opt41 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT41_BITMASK;
        }
        else if (STREQ (this_arg, "opt42")) {
          optargs_s.opt42 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT42_BITMASK;
        }
        else if (STREQ (this_arg, "opt43")) {
          optargs_s.opt43 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT43_BITMASK;
        }
        else if (STREQ (this_arg, "opt44")) {
          optargs_s.opt44 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT44_BITMASK;
        }
        else if (STREQ (this_arg, "opt45")) {
          optargs_s.opt45 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT45_BITMASK;
        }
        else if (STREQ (this_arg, "opt46")) {
          optargs_s.opt46 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT46_BITMASK;
        }
        else if (STREQ (this_arg, "opt47")) {
          optargs_s.opt47 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT47_BITMASK;
        }
        else if (STREQ (this_arg, "opt48")) {
          optargs_s.opt48 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT48_BITMASK;
        }
        else if (STREQ (this_arg, "opt49")) {
          optargs_s.opt49 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT49_BITMASK;
        }
        else if (STREQ (this_arg, "opt50")) {
          optargs_s.opt50 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT50_BITMASK;
        }
        else if (STREQ (this_arg, "opt51")) {
          optargs_s.opt51 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT51_BITMASK;
        }
        else if (STREQ (this_arg, "opt52")) {
          optargs_s.opt52 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT52_BITMASK;
        }
        else if (STREQ (this_arg, "opt53")) {
          optargs_s.opt53 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT53_BITMASK;
        }
        else if (STREQ (this_arg, "opt54")) {
          optargs_s.opt54 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT54_BITMASK;
        }
        else if (STREQ (this_arg, "opt55")) {
          optargs_s.opt55 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT55_BITMASK;
        }
        else if (STREQ (this_arg, "opt56")) {
          optargs_s.opt56 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT56_BITMASK;
        }
        else if (STREQ (this_arg, "opt57")) {
          optargs_s.opt57 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT57_BITMASK;
        }
        else if (STREQ (this_arg, "opt58")) {
          optargs_s.opt58 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT58_BITMASK;
        }
        else if (STREQ (this_arg, "opt59")) {
          optargs_s.opt59 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT59_BITMASK;
        }
        else if (STREQ (this_arg, "opt60")) {
          optargs_s.opt60 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT60_BITMASK;
        }
        else if (STREQ (this_arg, "opt61")) {
          optargs_s.opt61 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT61_BITMASK;
        }
        else if (STREQ (this_arg, "opt62")) {
          optargs_s.opt62 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT62_BITMASK;
        }
        else if (STREQ (this_arg, "opt63")) {
          optargs_s.opt63 = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_63_OPTARGS_OPT63_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_internal_test_63_optargs_argv (g, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12439 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_close_output); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_close_output)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4964 "lib/Sys/Guestfs.xs"
      int r;
#line 12462 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_close_output(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_close_output(): g is not a blessed HV reference");
    };
#line 4966 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_close_output (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12479 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_only_optargs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_only_optargs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "g, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 4974 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_internal_test_only_optargs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_internal_test_only_optargs_argv *optargs = &optargs_s;
      size_t items_i;
#line 12505 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_only_optargs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_only_optargs(): g is not a blessed HV reference");
    };
#line 4979 "lib/Sys/Guestfs.xs"
      if (((items - 1) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 1; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "test")) {
          optargs_s.test = SvIV (ST (items_i+1));
          this_mask = GUESTFS_INTERNAL_TEST_ONLY_OPTARGS_TEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_internal_test_only_optargs_argv (g, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 12540 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rbool); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rbool)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5006 "lib/Sys/Guestfs.xs"
      int r;
#line 12562 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rbool(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rbool(): g is not a blessed HV reference");
    };
#line 5008 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rbool (g, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 12581 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rboolerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rboolerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5019 "lib/Sys/Guestfs.xs"
      int r;
#line 12603 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rboolerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rboolerr(): g is not a blessed HV reference");
    };
#line 5021 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rboolerr (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 12622 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rbufferout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rbufferout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5033 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 12646 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rbufferout(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rbufferout(): g is not a blessed HV reference");
    };
#line 5036 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rbufferout (g, val, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 12666 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rbufferouterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rbufferouterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5048 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 12689 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rbufferouterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rbufferouterr(): g is not a blessed HV reference");
    };
#line 5051 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rbufferouterr (g, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 12709 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconstoptstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconstoptstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5064 "lib/Sys/Guestfs.xs"
      const char *r;
#line 12732 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconstoptstring(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconstoptstring(): g is not a blessed HV reference");
    };
#line 5066 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rconstoptstring (g, val);
      if (r == NULL)
        RETVAL = &PL_sv_undef;
      else
        RETVAL = newSVpv (r, 0);
#line 12752 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconstoptstringerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconstoptstringerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5078 "lib/Sys/Guestfs.xs"
      const char *r;
#line 12774 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconstoptstringerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconstoptstringerr(): g is not a blessed HV reference");
    };
#line 5080 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rconstoptstringerr (g);
      if (r == NULL)
        RETVAL = &PL_sv_undef;
      else
        RETVAL = newSVpv (r, 0);
#line 12794 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconststring); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconststring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5093 "lib/Sys/Guestfs.xs"
      const char *r;
#line 12817 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconststring(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconststring(): g is not a blessed HV reference");
    };
#line 5095 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rconststring (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 12836 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rconststringerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rconststringerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5106 "lib/Sys/Guestfs.xs"
      const char *r;
#line 12858 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rconststringerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rconststringerr(): g is not a blessed HV reference");
    };
#line 5108 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rconststringerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
#line 12877 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rhashtable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rhashtable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5120 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 12903 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rhashtable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rhashtable(): g is not a blessed HV reference");
    };
#line 5123 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rhashtable (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 12927 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rhashtableerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rhashtableerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5138 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 12951 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rhashtableerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rhashtableerr(): g is not a blessed HV reference");
    };
#line 5141 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rhashtableerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 12975 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5157 "lib/Sys/Guestfs.xs"
      int r;
#line 12997 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rint(): g is not a blessed HV reference");
    };
#line 5159 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rint (g, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13016 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rint64); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rint64)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5171 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 13039 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rint64(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rint64(): g is not a blessed HV reference");
    };
#line 5173 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rint64 (g, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 13058 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rint64err); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rint64err)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5184 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 13080 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rint64err(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rint64err(): g is not a blessed HV reference");
    };
#line 5186 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rint64err (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 13099 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rinterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rinterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5197 "lib/Sys/Guestfs.xs"
      int r;
#line 13121 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rinterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rinterr(): g is not a blessed HV reference");
    };
#line 5199 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rinterr (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13140 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5211 "lib/Sys/Guestfs.xs"
      char *r;
#line 13163 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstring(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstring(): g is not a blessed HV reference");
    };
#line 5213 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstring (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 13183 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rstringerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstringerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5225 "lib/Sys/Guestfs.xs"
      char *r;
#line 13205 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstringerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstringerr(): g is not a blessed HV reference");
    };
#line 5227 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstringerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 13225 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_internal_test_rstringlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstringlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5240 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 13251 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstringlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstringlist(): g is not a blessed HV reference");
    };
#line 5243 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstringlist (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 13275 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstringlisterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstringlisterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5258 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 13299 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstringlisterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstringlisterr(): g is not a blessed HV reference");
    };
#line 5261 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstringlisterr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 13323 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstruct); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstruct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5277 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_pv *r;
#line 13347 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstruct(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstruct(): g is not a blessed HV reference");
    };
#line 5279 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstruct (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 14);
      PUSHs (sv_2mortal (newSVpv ("pv_name", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_name, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_uuid", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_uuid, 32)));
      PUSHs (sv_2mortal (newSVpv ("pv_fmt", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_fmt, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_size)));
      PUSHs (sv_2mortal (newSVpv ("dev_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->dev_size)));
      PUSHs (sv_2mortal (newSVpv ("pv_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_free)));
      PUSHs (sv_2mortal (newSVpv ("pv_used", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_used)));
      PUSHs (sv_2mortal (newSVpv ("pv_attr", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_attr, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_alloc_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_alloc_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_tags", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_tags, 0)));
      PUSHs (sv_2mortal (newSVpv ("pe_start", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pe_start)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_mda_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_mda_free)));
      free (r);
#line 13394 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstructerr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstructerr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5317 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_pv *r;
#line 13417 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstructerr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstructerr(): g is not a blessed HV reference");
    };
#line 5319 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstructerr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 14);
      PUSHs (sv_2mortal (newSVpv ("pv_name", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_name, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_uuid", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_uuid, 32)));
      PUSHs (sv_2mortal (newSVpv ("pv_fmt", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_fmt, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_size)));
      PUSHs (sv_2mortal (newSVpv ("dev_size", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->dev_size)));
      PUSHs (sv_2mortal (newSVpv ("pv_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_free)));
      PUSHs (sv_2mortal (newSVpv ("pv_used", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_used)));
      PUSHs (sv_2mortal (newSVpv ("pv_attr", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_attr, 0)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_pe_alloc_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_pe_alloc_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_tags", 0)));
      PUSHs (sv_2mortal (newSVpv (r->pv_tags, 0)));
      PUSHs (sv_2mortal (newSVpv ("pe_start", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pe_start)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_count", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->pv_mda_count)));
      PUSHs (sv_2mortal (newSVpv ("pv_mda_free", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->pv_mda_free)));
      free (r);
#line 13464 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstructlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstructlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 5358 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_pv_list *r;
      size_t i;
      HV *hv;
#line 13490 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstructlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstructlist(): g is not a blessed HV reference");
    };
#line 5362 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstructlist (g, val);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "pv_name", 7, newSVpv (r->val[i].pv_name, 0), 0);
        (void) hv_store (hv, "pv_uuid", 7, newSVpv (r->val[i].pv_uuid, 32), 0);
        (void) hv_store (hv, "pv_fmt", 6, newSVpv (r->val[i].pv_fmt, 0), 0);
        (void) hv_store (hv, "pv_size", 7, my_newSVull (r->val[i].pv_size), 0);
        (void) hv_store (hv, "dev_size", 8, my_newSVull (r->val[i].dev_size), 0);
        (void) hv_store (hv, "pv_free", 7, my_newSVull (r->val[i].pv_free), 0);
        (void) hv_store (hv, "pv_used", 7, my_newSVull (r->val[i].pv_used), 0);
        (void) hv_store (hv, "pv_attr", 7, newSVpv (r->val[i].pv_attr, 0), 0);
        (void) hv_store (hv, "pv_pe_count", 11, my_newSVll (r->val[i].pv_pe_count), 0);
        (void) hv_store (hv, "pv_pe_alloc_count", 17, my_newSVll (r->val[i].pv_pe_alloc_count), 0);
        (void) hv_store (hv, "pv_tags", 7, newSVpv (r->val[i].pv_tags, 0), 0);
        (void) hv_store (hv, "pe_start", 8, my_newSVull (r->val[i].pe_start), 0);
        (void) hv_store (hv, "pv_mda_count", 12, my_newSVll (r->val[i].pv_mda_count), 0);
        (void) hv_store (hv, "pv_mda_free", 11, my_newSVull (r->val[i].pv_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_pv_list (r);
#line 13527 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_rstructlisterr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_rstructlisterr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5390 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_pv_list *r;
      size_t i;
      HV *hv;
#line 13552 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_rstructlisterr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_rstructlisterr(): g is not a blessed HV reference");
    };
#line 5394 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_rstructlisterr (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "pv_name", 7, newSVpv (r->val[i].pv_name, 0), 0);
        (void) hv_store (hv, "pv_uuid", 7, newSVpv (r->val[i].pv_uuid, 32), 0);
        (void) hv_store (hv, "pv_fmt", 6, newSVpv (r->val[i].pv_fmt, 0), 0);
        (void) hv_store (hv, "pv_size", 7, my_newSVull (r->val[i].pv_size), 0);
        (void) hv_store (hv, "dev_size", 8, my_newSVull (r->val[i].dev_size), 0);
        (void) hv_store (hv, "pv_free", 7, my_newSVull (r->val[i].pv_free), 0);
        (void) hv_store (hv, "pv_used", 7, my_newSVull (r->val[i].pv_used), 0);
        (void) hv_store (hv, "pv_attr", 7, newSVpv (r->val[i].pv_attr, 0), 0);
        (void) hv_store (hv, "pv_pe_count", 11, my_newSVll (r->val[i].pv_pe_count), 0);
        (void) hv_store (hv, "pv_pe_alloc_count", 17, my_newSVll (r->val[i].pv_pe_alloc_count), 0);
        (void) hv_store (hv, "pv_tags", 7, newSVpv (r->val[i].pv_tags, 0), 0);
        (void) hv_store (hv, "pe_start", 8, my_newSVull (r->val[i].pe_start), 0);
        (void) hv_store (hv, "pv_mda_count", 12, my_newSVll (r->val[i].pv_mda_count), 0);
        (void) hv_store (hv, "pv_mda_free", 11, my_newSVull (r->val[i].pv_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_pv_list (r);
#line 13589 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_internal_test_set_output); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_internal_test_set_output)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, filename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
#line 5423 "lib/Sys/Guestfs.xs"
      int r;
#line 13613 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::internal_test_set_output(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::internal_test_set_output(): g is not a blessed HV reference");
    };
#line 5425 "lib/Sys/Guestfs.xs"
      r = guestfs_internal_test_set_output (g, filename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 13630 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_is_blockdev); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_blockdev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5434 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_is_blockdev_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_blockdev_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13655 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_blockdev(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_blockdev(): g is not a blessed HV reference");
    };
#line 5439 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_BLOCKDEV_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_blockdev_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13692 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_busy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_busy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5468 "lib/Sys/Guestfs.xs"
      int r;
#line 13714 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_busy(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_busy(): g is not a blessed HV reference");
    };
#line 5470 "lib/Sys/Guestfs.xs"
      r = guestfs_is_busy (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13733 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_chardev); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_chardev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5482 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_is_chardev_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_chardev_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13759 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_chardev(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_chardev(): g is not a blessed HV reference");
    };
#line 5487 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_CHARDEV_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_chardev_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13796 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_config); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_config)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5516 "lib/Sys/Guestfs.xs"
      int r;
#line 13818 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_config(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_config(): g is not a blessed HV reference");
    };
#line 5518 "lib/Sys/Guestfs.xs"
      r = guestfs_is_config (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13837 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_dir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_dir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5530 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_is_dir_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_dir_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13863 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_dir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_dir(): g is not a blessed HV reference");
    };
#line 5535 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_DIR_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_dir_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13900 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_fifo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_fifo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5565 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_is_fifo_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_fifo_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13926 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_fifo(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_fifo(): g is not a blessed HV reference");
    };
#line 5570 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_FIFO_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_fifo_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 13963 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5600 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_is_file_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_file_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 13989 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_file(): g is not a blessed HV reference");
    };
#line 5605 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_file_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14026 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_launching); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_launching)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5634 "lib/Sys/Guestfs.xs"
      int r;
#line 14048 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_launching(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_launching(): g is not a blessed HV reference");
    };
#line 5636 "lib/Sys/Guestfs.xs"
      r = guestfs_is_launching (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14067 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_lv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_lv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5648 "lib/Sys/Guestfs.xs"
      int r;
#line 14090 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_lv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_lv(): g is not a blessed HV reference");
    };
#line 5650 "lib/Sys/Guestfs.xs"
      r = guestfs_is_lv (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14109 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_ready); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_ready)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5661 "lib/Sys/Guestfs.xs"
      int r;
#line 14131 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_ready(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_ready(): g is not a blessed HV reference");
    };
#line 5663 "lib/Sys/Guestfs.xs"
      r = guestfs_is_ready (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14150 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_socket); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_socket)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5675 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_is_socket_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_is_socket_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 14176 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_socket(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_socket(): g is not a blessed HV reference");
    };
#line 5680 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "followsymlinks")) {
          optargs_s.followsymlinks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_IS_SOCKET_OPTS_FOLLOWSYMLINKS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_is_socket_opts_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14213 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_symlink); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_symlink)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5710 "lib/Sys/Guestfs.xs"
      int r;
#line 14236 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_symlink(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_symlink(): g is not a blessed HV reference");
    };
#line 5712 "lib/Sys/Guestfs.xs"
      r = guestfs_is_symlink (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14255 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_whole_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_whole_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5724 "lib/Sys/Guestfs.xs"
      int r;
#line 14278 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_whole_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_whole_device(): g is not a blessed HV reference");
    };
#line 5726 "lib/Sys/Guestfs.xs"
      r = guestfs_is_whole_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14297 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_zero); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_zero)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 5738 "lib/Sys/Guestfs.xs"
      int r;
#line 14320 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_zero(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_zero(): g is not a blessed HV reference");
    };
#line 5740 "lib/Sys/Guestfs.xs"
      r = guestfs_is_zero (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14339 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_is_zero_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_is_zero_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5752 "lib/Sys/Guestfs.xs"
      int r;
#line 14362 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::is_zero_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::is_zero_device(): g is not a blessed HV reference");
    };
#line 5754 "lib/Sys/Guestfs.xs"
      r = guestfs_is_zero_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14381 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_isoinfo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_isoinfo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, isofile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	isofile = (char *)SvPV_nolen(ST(1));
#line 5766 "lib/Sys/Guestfs.xs"
      struct guestfs_isoinfo *r;
#line 14406 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::isoinfo(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::isoinfo(): g is not a blessed HV reference");
    };
#line 5768 "lib/Sys/Guestfs.xs"
      r = guestfs_isoinfo (g, isofile);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 17);
      PUSHs (sv_2mortal (newSVpv ("iso_system_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_system_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_space_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_space_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_set_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_sequence_number", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_sequence_number)));
      PUSHs (sv_2mortal (newSVpv ("iso_logical_block_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_logical_block_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_set_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_publisher_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_publisher_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_data_preparer_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_data_preparer_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_application_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_application_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_copyright_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_copyright_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_abstract_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_abstract_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_bibliographic_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_bibliographic_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_creation_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_creation_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_modification_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_modification_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_expiration_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_expiration_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_effective_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_effective_t)));
      free (r);
#line 14459 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_isoinfo_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_isoinfo_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 5813 "lib/Sys/Guestfs.xs"
      struct guestfs_isoinfo *r;
#line 14483 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::isoinfo_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::isoinfo_device(): g is not a blessed HV reference");
    };
#line 5815 "lib/Sys/Guestfs.xs"
      r = guestfs_isoinfo_device (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 17);
      PUSHs (sv_2mortal (newSVpv ("iso_system_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_system_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_space_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_space_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_set_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_sequence_number", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_volume_sequence_number)));
      PUSHs (sv_2mortal (newSVpv ("iso_logical_block_size", 0)));
      PUSHs (sv_2mortal (newSVnv (r->iso_logical_block_size)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_set_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_volume_set_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_publisher_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_publisher_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_data_preparer_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_data_preparer_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_application_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_application_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_copyright_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_copyright_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_abstract_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_abstract_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_bibliographic_file_id", 0)));
      PUSHs (sv_2mortal (newSVpv (r->iso_bibliographic_file_id, 0)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_creation_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_creation_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_modification_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_modification_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_expiration_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_expiration_t)));
      PUSHs (sv_2mortal (newSVpv ("iso_volume_effective_t", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->iso_volume_effective_t)));
      free (r);
#line 14536 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5859 "lib/Sys/Guestfs.xs"
      int r;
#line 14559 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_close(): g is not a blessed HV reference");
    };
#line 5861 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_close (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14576 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5869 "lib/Sys/Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 14601 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_get(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_get(): g is not a blessed HV reference");
    };
#line 5873 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_get (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 14626 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_get_data_threshold); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_get_data_threshold)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5889 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 14647 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_get_data_threshold(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_get_data_threshold(): g is not a blessed HV reference");
    };
#line 5891 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_get_data_threshold (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 14666 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_journal_get_realtime_usec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_get_realtime_usec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5902 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 14688 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_get_realtime_usec(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_get_realtime_usec(): g is not a blessed HV reference");
    };
#line 5904 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_get_realtime_usec (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 14707 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_journal_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 5915 "lib/Sys/Guestfs.xs"
      int r;
#line 14729 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_next(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_next(): g is not a blessed HV reference");
    };
#line 5917 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_next (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 14748 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_journal_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 5929 "lib/Sys/Guestfs.xs"
      int r;
#line 14773 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_open(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_open(): g is not a blessed HV reference");
    };
#line 5931 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_open (g, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14790 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_set_data_threshold); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_set_data_threshold)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, threshold");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int64_t    threshold = my_SvIV64 (ST(1));
#line 5940 "lib/Sys/Guestfs.xs"
      int r;
#line 14814 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_set_data_threshold(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_set_data_threshold(): g is not a blessed HV reference");
    };
#line 5942 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_set_data_threshold (g, threshold);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14831 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_journal_skip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_journal_skip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, skip");
    {
	guestfs_h *	g;
	int64_t    skip = my_SvIV64 (ST(1));
#line 5951 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 14853 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::journal_skip(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::journal_skip(): g is not a blessed HV reference");
    };
#line 5953 "lib/Sys/Guestfs.xs"
      r = guestfs_journal_skip (g, skip);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 14872 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_kill_subprocess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_kill_subprocess)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5964 "lib/Sys/Guestfs.xs"
      int r;
#line 14896 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::kill_subprocess(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::kill_subprocess(): g is not a blessed HV reference");
    };
#line 5966 "lib/Sys/Guestfs.xs"
      r = guestfs_kill_subprocess (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14913 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_launch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_launch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5974 "lib/Sys/Guestfs.xs"
      int r;
#line 14936 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::launch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::launch(): g is not a blessed HV reference");
    };
#line 5976 "lib/Sys/Guestfs.xs"
      r = guestfs_launch (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14953 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lchown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lchown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, owner, group, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	owner = (int)SvIV(ST(1));
	int	group = (int)SvIV(ST(2));
	char *	path = (char *)SvPV_nolen(ST(3));
#line 5987 "lib/Sys/Guestfs.xs"
      int r;
#line 14979 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lchown(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lchown(): g is not a blessed HV reference");
    };
#line 5989 "lib/Sys/Guestfs.xs"
      r = guestfs_lchown (g, owner, group, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 14996 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_create_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_create_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 5997 "lib/Sys/Guestfs.xs"
      int r;
#line 15019 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_create_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_create_all(): g is not a blessed HV reference");
    };
#line 5999 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_create_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 15036 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_diskgroup_disks); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_diskgroup_disks)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, diskgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
#line 6008 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15061 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_diskgroup_disks(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_diskgroup_disks(): g is not a blessed HV reference");
    };
#line 6011 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_diskgroup_disks (g, diskgroup);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15085 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_diskgroup_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_diskgroup_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, diskgroup");
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
#line 6027 "lib/Sys/Guestfs.xs"
      char *r;
#line 15107 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_diskgroup_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_diskgroup_name(): g is not a blessed HV reference");
    };
#line 6029 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_diskgroup_name (g, diskgroup);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15127 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ldmtool_diskgroup_volumes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_diskgroup_volumes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, diskgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
#line 6042 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15153 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_diskgroup_volumes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_diskgroup_volumes(): g is not a blessed HV reference");
    };
#line 6045 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_diskgroup_volumes (g, diskgroup);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15177 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_remove_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_remove_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6060 "lib/Sys/Guestfs.xs"
      int r;
#line 15200 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_remove_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_remove_all(): g is not a blessed HV reference");
    };
#line 6062 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_remove_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 15217 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_scan); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_scan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6070 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15241 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_scan(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_scan(): g is not a blessed HV reference");
    };
#line 6073 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_scan (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15265 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_scan_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_scan_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, devices");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
#line 6089 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15290 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_scan_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_scan_devices(): g is not a blessed HV reference");
    };
#line 6092 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_scan_devices (g, devices);
      free (devices);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15315 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_volume_hint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_volume_hint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, diskgroup, volume");
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
	char *	volume = (char *)SvPV_nolen(ST(2));
#line 6110 "lib/Sys/Guestfs.xs"
      char *r;
#line 15338 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_volume_hint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_volume_hint(): g is not a blessed HV reference");
    };
#line 6112 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_volume_hint (g, diskgroup, volume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15358 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ldmtool_volume_partitions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_volume_partitions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, diskgroup, volume");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
	char *	volume = (char *)SvPV_nolen(ST(2));
#line 6126 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15385 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_volume_partitions(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_volume_partitions(): g is not a blessed HV reference");
    };
#line 6129 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_volume_partitions (g, diskgroup, volume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15409 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ldmtool_volume_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ldmtool_volume_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, diskgroup, volume");
    {
	guestfs_h *	g;
	char *	diskgroup = (char *)SvPV_nolen(ST(1));
	char *	volume = (char *)SvPV_nolen(ST(2));
#line 6146 "lib/Sys/Guestfs.xs"
      char *r;
#line 15432 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ldmtool_volume_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ldmtool_volume_type(): g is not a blessed HV reference");
    };
#line 6148 "lib/Sys/Guestfs.xs"
      r = guestfs_ldmtool_volume_type (g, diskgroup, volume);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 15452 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lgetxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lgetxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, name");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
#line 6162 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 15477 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lgetxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lgetxattr(): g is not a blessed HV reference");
    };
#line 6165 "lib/Sys/Guestfs.xs"
      r = guestfs_lgetxattr (g, path, name, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 15497 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lgetxattrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lgetxattrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 6178 "lib/Sys/Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 15524 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lgetxattrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lgetxattrs(): g is not a blessed HV reference");
    };
#line 6182 "lib/Sys/Guestfs.xs"
      r = guestfs_lgetxattrs (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 15549 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_9p); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_9p)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6198 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15573 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_9p(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_9p(): g is not a blessed HV reference");
    };
#line 6201 "lib/Sys/Guestfs.xs"
      r = guestfs_list_9p (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15597 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6216 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15621 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_devices(): g is not a blessed HV reference");
    };
#line 6219 "lib/Sys/Guestfs.xs"
      r = guestfs_list_devices (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15645 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_disk_labels); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_disk_labels)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6234 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15669 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_disk_labels(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_disk_labels(): g is not a blessed HV reference");
    };
#line 6237 "lib/Sys/Guestfs.xs"
      r = guestfs_list_disk_labels (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15693 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_dm_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_dm_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6252 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15717 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_dm_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_dm_devices(): g is not a blessed HV reference");
    };
#line 6255 "lib/Sys/Guestfs.xs"
      r = guestfs_list_dm_devices (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15741 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_filesystems); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_filesystems)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6270 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15765 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_filesystems(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_filesystems(): g is not a blessed HV reference");
    };
#line 6273 "lib/Sys/Guestfs.xs"
      r = guestfs_list_filesystems (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15789 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_ldm_partitions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_ldm_partitions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6288 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15813 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_ldm_partitions(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_ldm_partitions(): g is not a blessed HV reference");
    };
#line 6291 "lib/Sys/Guestfs.xs"
      r = guestfs_list_ldm_partitions (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15837 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_ldm_volumes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_ldm_volumes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6306 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15861 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_ldm_volumes(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_ldm_volumes(): g is not a blessed HV reference");
    };
#line 6309 "lib/Sys/Guestfs.xs"
      r = guestfs_list_ldm_volumes (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15885 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_md_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_md_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6324 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15909 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_md_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_md_devices(): g is not a blessed HV reference");
    };
#line 6327 "lib/Sys/Guestfs.xs"
      r = guestfs_list_md_devices (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15933 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_list_partitions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_list_partitions)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6342 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 15957 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::list_partitions(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::list_partitions(): g is not a blessed HV reference");
    };
#line 6345 "lib/Sys/Guestfs.xs"
      r = guestfs_list_partitions (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 15981 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ll); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ll)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 6361 "lib/Sys/Guestfs.xs"
      char *r;
#line 16003 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ll(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ll(): g is not a blessed HV reference");
    };
#line 6363 "lib/Sys/Guestfs.xs"
      r = guestfs_ll (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 16023 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_llz); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_llz)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 6376 "lib/Sys/Guestfs.xs"
      char *r;
#line 16046 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::llz(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::llz(): g is not a blessed HV reference");
    };
#line 6378 "lib/Sys/Guestfs.xs"
      r = guestfs_llz (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 16066 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ln); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6392 "lib/Sys/Guestfs.xs"
      int r;
#line 16092 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln(): g is not a blessed HV reference");
    };
#line 6394 "lib/Sys/Guestfs.xs"
      r = guestfs_ln (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16109 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ln_f); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln_f)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6404 "lib/Sys/Guestfs.xs"
      int r;
#line 16134 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln_f(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln_f(): g is not a blessed HV reference");
    };
#line 6406 "lib/Sys/Guestfs.xs"
      r = guestfs_ln_f (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16151 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ln_s); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln_s)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6416 "lib/Sys/Guestfs.xs"
      int r;
#line 16176 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln_s(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln_s(): g is not a blessed HV reference");
    };
#line 6418 "lib/Sys/Guestfs.xs"
      r = guestfs_ln_s (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16193 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ln_sf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ln_sf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, target, linkname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	target = (char *)SvPV_nolen(ST(1));
	char *	linkname = (char *)SvPV_nolen(ST(2));
#line 6428 "lib/Sys/Guestfs.xs"
      int r;
#line 16218 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ln_sf(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ln_sf(): g is not a blessed HV reference");
    };
#line 6430 "lib/Sys/Guestfs.xs"
      r = guestfs_ln_sf (g, target, linkname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16235 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lremovexattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lremovexattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, xattr, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 6440 "lib/Sys/Guestfs.xs"
      int r;
#line 16260 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lremovexattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lremovexattr(): g is not a blessed HV reference");
    };
#line 6442 "lib/Sys/Guestfs.xs"
      r = guestfs_lremovexattr (g, xattr, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16277 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ls); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ls)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 6451 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 16302 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ls(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ls(): g is not a blessed HV reference");
    };
#line 6454 "lib/Sys/Guestfs.xs"
      r = guestfs_ls (g, directory);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 16326 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ls0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ls0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, dir, filenames");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
	char *	filenames = (char *)SvPV_nolen(ST(2));
#line 6471 "lib/Sys/Guestfs.xs"
      int r;
#line 16351 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ls0(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ls0(): g is not a blessed HV reference");
    };
#line 6473 "lib/Sys/Guestfs.xs"
      r = guestfs_ls0 (g, dir, filenames);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16368 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lsetxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lsetxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, xattr, val, vallen, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
	int	vallen = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 6485 "lib/Sys/Guestfs.xs"
      int r;
#line 16395 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lsetxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lsetxattr(): g is not a blessed HV reference");
    };
#line 6487 "lib/Sys/Guestfs.xs"
      r = guestfs_lsetxattr (g, xattr, val, vallen, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16412 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 6496 "lib/Sys/Guestfs.xs"
      struct guestfs_stat *r;
#line 16436 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstat(): g is not a blessed HV reference");
    };
#line 6498 "lib/Sys/Guestfs.xs"
      r = guestfs_lstat (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 13);
      PUSHs (sv_2mortal (newSVpv ("dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->dev)));
      PUSHs (sv_2mortal (newSVpv ("ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ino)));
      PUSHs (sv_2mortal (newSVpv ("mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mode)));
      PUSHs (sv_2mortal (newSVpv ("nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->nlink)));
      PUSHs (sv_2mortal (newSVpv ("uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->uid)));
      PUSHs (sv_2mortal (newSVpv ("gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->gid)));
      PUSHs (sv_2mortal (newSVpv ("rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->rdev)));
      PUSHs (sv_2mortal (newSVpv ("size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->size)));
      PUSHs (sv_2mortal (newSVpv ("blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blksize)));
      PUSHs (sv_2mortal (newSVpv ("blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blocks)));
      PUSHs (sv_2mortal (newSVpv ("atime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->atime)));
      PUSHs (sv_2mortal (newSVpv ("mtime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mtime)));
      PUSHs (sv_2mortal (newSVpv ("ctime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ctime)));
      free (r);
#line 16481 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstatlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstatlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 6536 "lib/Sys/Guestfs.xs"
      struct guestfs_stat_list *r;
      size_t i;
      HV *hv;
#line 16508 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstatlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstatlist(): g is not a blessed HV reference");
    };
#line 6540 "lib/Sys/Guestfs.xs"
      r = guestfs_lstatlist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "dev", 3, my_newSVll (r->val[i].dev), 0);
        (void) hv_store (hv, "ino", 3, my_newSVll (r->val[i].ino), 0);
        (void) hv_store (hv, "mode", 4, my_newSVll (r->val[i].mode), 0);
        (void) hv_store (hv, "nlink", 5, my_newSVll (r->val[i].nlink), 0);
        (void) hv_store (hv, "uid", 3, my_newSVll (r->val[i].uid), 0);
        (void) hv_store (hv, "gid", 3, my_newSVll (r->val[i].gid), 0);
        (void) hv_store (hv, "rdev", 4, my_newSVll (r->val[i].rdev), 0);
        (void) hv_store (hv, "size", 4, my_newSVll (r->val[i].size), 0);
        (void) hv_store (hv, "blksize", 7, my_newSVll (r->val[i].blksize), 0);
        (void) hv_store (hv, "blocks", 6, my_newSVll (r->val[i].blocks), 0);
        (void) hv_store (hv, "atime", 5, my_newSVll (r->val[i].atime), 0);
        (void) hv_store (hv, "mtime", 5, my_newSVll (r->val[i].mtime), 0);
        (void) hv_store (hv, "ctime", 5, my_newSVll (r->val[i].ctime), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_stat_list (r);
#line 16545 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstatns); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstatns)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 6569 "lib/Sys/Guestfs.xs"
      struct guestfs_statns *r;
#line 16569 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstatns(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstatns(): g is not a blessed HV reference");
    };
#line 6571 "lib/Sys/Guestfs.xs"
      r = guestfs_lstatns (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 22);
      PUSHs (sv_2mortal (newSVpv ("st_dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_dev)));
      PUSHs (sv_2mortal (newSVpv ("st_ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ino)));
      PUSHs (sv_2mortal (newSVpv ("st_mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mode)));
      PUSHs (sv_2mortal (newSVpv ("st_nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_nlink)));
      PUSHs (sv_2mortal (newSVpv ("st_uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_uid)));
      PUSHs (sv_2mortal (newSVpv ("st_gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_gid)));
      PUSHs (sv_2mortal (newSVpv ("st_rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_rdev)));
      PUSHs (sv_2mortal (newSVpv ("st_size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_size)));
      PUSHs (sv_2mortal (newSVpv ("st_blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blksize)));
      PUSHs (sv_2mortal (newSVpv ("st_blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blocks)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_spare1", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare1)));
      PUSHs (sv_2mortal (newSVpv ("st_spare2", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare2)));
      PUSHs (sv_2mortal (newSVpv ("st_spare3", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare3)));
      PUSHs (sv_2mortal (newSVpv ("st_spare4", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare4)));
      PUSHs (sv_2mortal (newSVpv ("st_spare5", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare5)));
      PUSHs (sv_2mortal (newSVpv ("st_spare6", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare6)));
      free (r);
#line 16632 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lstatnslist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lstatnslist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 6627 "lib/Sys/Guestfs.xs"
      struct guestfs_statns_list *r;
      size_t i;
      HV *hv;
#line 16659 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lstatnslist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lstatnslist(): g is not a blessed HV reference");
    };
#line 6631 "lib/Sys/Guestfs.xs"
      r = guestfs_lstatnslist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "st_dev", 6, my_newSVll (r->val[i].st_dev), 0);
        (void) hv_store (hv, "st_ino", 6, my_newSVll (r->val[i].st_ino), 0);
        (void) hv_store (hv, "st_mode", 7, my_newSVll (r->val[i].st_mode), 0);
        (void) hv_store (hv, "st_nlink", 8, my_newSVll (r->val[i].st_nlink), 0);
        (void) hv_store (hv, "st_uid", 6, my_newSVll (r->val[i].st_uid), 0);
        (void) hv_store (hv, "st_gid", 6, my_newSVll (r->val[i].st_gid), 0);
        (void) hv_store (hv, "st_rdev", 7, my_newSVll (r->val[i].st_rdev), 0);
        (void) hv_store (hv, "st_size", 7, my_newSVll (r->val[i].st_size), 0);
        (void) hv_store (hv, "st_blksize", 10, my_newSVll (r->val[i].st_blksize), 0);
        (void) hv_store (hv, "st_blocks", 9, my_newSVll (r->val[i].st_blocks), 0);
        (void) hv_store (hv, "st_atime_sec", 12, my_newSVll (r->val[i].st_atime_sec), 0);
        (void) hv_store (hv, "st_atime_nsec", 13, my_newSVll (r->val[i].st_atime_nsec), 0);
        (void) hv_store (hv, "st_mtime_sec", 12, my_newSVll (r->val[i].st_mtime_sec), 0);
        (void) hv_store (hv, "st_mtime_nsec", 13, my_newSVll (r->val[i].st_mtime_nsec), 0);
        (void) hv_store (hv, "st_ctime_sec", 12, my_newSVll (r->val[i].st_ctime_sec), 0);
        (void) hv_store (hv, "st_ctime_nsec", 13, my_newSVll (r->val[i].st_ctime_nsec), 0);
        (void) hv_store (hv, "st_spare1", 9, my_newSVll (r->val[i].st_spare1), 0);
        (void) hv_store (hv, "st_spare2", 9, my_newSVll (r->val[i].st_spare2), 0);
        (void) hv_store (hv, "st_spare3", 9, my_newSVll (r->val[i].st_spare3), 0);
        (void) hv_store (hv, "st_spare4", 9, my_newSVll (r->val[i].st_spare4), 0);
        (void) hv_store (hv, "st_spare5", 9, my_newSVll (r->val[i].st_spare5), 0);
        (void) hv_store (hv, "st_spare6", 9, my_newSVll (r->val[i].st_spare6), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_statns_list (r);
#line 16705 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_add_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_add_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, device, key, newkey, keyslot");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	char *	newkey = (char *)SvPV_nolen(ST(3));
	int	keyslot = (int)SvIV(ST(4));
#line 6672 "lib/Sys/Guestfs.xs"
      int r;
#line 16732 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_add_key(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_add_key(): g is not a blessed HV reference");
    };
#line 6674 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_add_key (g, device, key, newkey, keyslot);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16749 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 6683 "lib/Sys/Guestfs.xs"
      int r;
#line 16773 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_close(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_close(): g is not a blessed HV reference");
    };
#line 6685 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_close (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16790 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, keyslot");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int	keyslot = (int)SvIV(ST(3));
#line 6696 "lib/Sys/Guestfs.xs"
      int r;
#line 16816 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_format(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_format(): g is not a blessed HV reference");
    };
#line 6698 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_format (g, device, key, keyslot);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16833 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_format_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_format_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, device, key, keyslot, cipher");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int	keyslot = (int)SvIV(ST(3));
	char *	cipher = (char *)SvPV_nolen(ST(4));
#line 6710 "lib/Sys/Guestfs.xs"
      int r;
#line 16860 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_format_cipher(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_format_cipher(): g is not a blessed HV reference");
    };
#line 6712 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_format_cipher (g, device, key, keyslot, cipher);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16877 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_kill_slot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_kill_slot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, keyslot");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	int	keyslot = (int)SvIV(ST(3));
#line 6723 "lib/Sys/Guestfs.xs"
      int r;
#line 16903 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_kill_slot(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_kill_slot(): g is not a blessed HV reference");
    };
#line 6725 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_kill_slot (g, device, key, keyslot);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16920 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, mapname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	char *	mapname = (char *)SvPV_nolen(ST(3));
#line 6736 "lib/Sys/Guestfs.xs"
      int r;
#line 16946 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_open(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_open(): g is not a blessed HV reference");
    };
#line 6738 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_open (g, device, key, mapname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 16963 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_luks_open_ro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_luks_open_ro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, key, mapname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	key = (char *)SvPV_nolen(ST(2));
	char *	mapname = (char *)SvPV_nolen(ST(3));
#line 6749 "lib/Sys/Guestfs.xs"
      int r;
#line 16989 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::luks_open_ro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::luks_open_ro(): g is not a blessed HV reference");
    };
#line 6751 "lib/Sys/Guestfs.xs"
      r = guestfs_luks_open_ro (g, device, key, mapname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17006 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvcreate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvcreate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, logvol, volgroup, mbytes");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	logvol = (char *)SvPV_nolen(ST(1));
	char *	volgroup = (char *)SvPV_nolen(ST(2));
	int	mbytes = (int)SvIV(ST(3));
#line 6762 "lib/Sys/Guestfs.xs"
      int r;
#line 17032 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvcreate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvcreate(): g is not a blessed HV reference");
    };
#line 6764 "lib/Sys/Guestfs.xs"
      r = guestfs_lvcreate (g, logvol, volgroup, mbytes);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17049 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvcreate_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvcreate_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, logvol, volgroup, percent");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	logvol = (char *)SvPV_nolen(ST(1));
	char *	volgroup = (char *)SvPV_nolen(ST(2));
	int	percent = (int)SvIV(ST(3));
#line 6775 "lib/Sys/Guestfs.xs"
      int r;
#line 17075 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvcreate_free(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvcreate_free(): g is not a blessed HV reference");
    };
#line 6777 "lib/Sys/Guestfs.xs"
      r = guestfs_lvcreate_free (g, logvol, volgroup, percent);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17092 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvm_canonical_lv_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_canonical_lv_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, lvname");
    {
	guestfs_h *	g;
	char *	lvname = (char *)SvPV_nolen(ST(1));
#line 6786 "lib/Sys/Guestfs.xs"
      char *r;
#line 17114 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_canonical_lv_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_canonical_lv_name(): g is not a blessed HV reference");
    };
#line 6788 "lib/Sys/Guestfs.xs"
      r = guestfs_lvm_canonical_lv_name (g, lvname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 17134 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lvm_clear_filter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_clear_filter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6800 "lib/Sys/Guestfs.xs"
      int r;
#line 17158 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_clear_filter(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_clear_filter(): g is not a blessed HV reference");
    };
#line 6802 "lib/Sys/Guestfs.xs"
      r = guestfs_lvm_clear_filter (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17175 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvm_remove_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_remove_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6810 "lib/Sys/Guestfs.xs"
      int r;
#line 17198 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_remove_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_remove_all(): g is not a blessed HV reference");
    };
#line 6812 "lib/Sys/Guestfs.xs"
      r = guestfs_lvm_remove_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17215 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvm_set_filter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvm_set_filter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, devices");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
#line 6821 "lib/Sys/Guestfs.xs"
      int r;
#line 17239 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvm_set_filter(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvm_set_filter(): g is not a blessed HV reference");
    };
#line 6823 "lib/Sys/Guestfs.xs"
      r = guestfs_lvm_set_filter (g, devices);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17257 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvremove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvremove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 6833 "lib/Sys/Guestfs.xs"
      int r;
#line 17281 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvremove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvremove(): g is not a blessed HV reference");
    };
#line 6835 "lib/Sys/Guestfs.xs"
      r = guestfs_lvremove (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17298 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvrename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvrename)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, logvol, newlogvol");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	logvol = (char *)SvPV_nolen(ST(1));
	char *	newlogvol = (char *)SvPV_nolen(ST(2));
#line 6845 "lib/Sys/Guestfs.xs"
      int r;
#line 17323 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvrename(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvrename(): g is not a blessed HV reference");
    };
#line 6847 "lib/Sys/Guestfs.xs"
      r = guestfs_lvrename (g, logvol, newlogvol);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17340 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvresize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvresize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, mbytes");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	mbytes = (int)SvIV(ST(2));
#line 6857 "lib/Sys/Guestfs.xs"
      int r;
#line 17365 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvresize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvresize(): g is not a blessed HV reference");
    };
#line 6859 "lib/Sys/Guestfs.xs"
      r = guestfs_lvresize (g, device, mbytes);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17382 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvresize_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvresize_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, lv, percent");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	lv = (char *)SvPV_nolen(ST(1));
	int	percent = (int)SvIV(ST(2));
#line 6869 "lib/Sys/Guestfs.xs"
      int r;
#line 17407 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvresize_free(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvresize_free(): g is not a blessed HV reference");
    };
#line 6871 "lib/Sys/Guestfs.xs"
      r = guestfs_lvresize_free (g, lv, percent);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17424 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6879 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 17448 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvs(): g is not a blessed HV reference");
    };
#line 6882 "lib/Sys/Guestfs.xs"
      r = guestfs_lvs (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 17472 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvs_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvs_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 6897 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_lv_list *r;
      size_t i;
      HV *hv;
#line 17497 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvs_full(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvs_full(): g is not a blessed HV reference");
    };
#line 6901 "lib/Sys/Guestfs.xs"
      r = guestfs_lvs_full (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "lv_name", 7, newSVpv (r->val[i].lv_name, 0), 0);
        (void) hv_store (hv, "lv_uuid", 7, newSVpv (r->val[i].lv_uuid, 32), 0);
        (void) hv_store (hv, "lv_attr", 7, newSVpv (r->val[i].lv_attr, 0), 0);
        (void) hv_store (hv, "lv_major", 8, my_newSVll (r->val[i].lv_major), 0);
        (void) hv_store (hv, "lv_minor", 8, my_newSVll (r->val[i].lv_minor), 0);
        (void) hv_store (hv, "lv_kernel_major", 15, my_newSVll (r->val[i].lv_kernel_major), 0);
        (void) hv_store (hv, "lv_kernel_minor", 15, my_newSVll (r->val[i].lv_kernel_minor), 0);
        (void) hv_store (hv, "lv_size", 7, my_newSVull (r->val[i].lv_size), 0);
        (void) hv_store (hv, "seg_count", 9, my_newSVll (r->val[i].seg_count), 0);
        (void) hv_store (hv, "origin", 6, newSVpv (r->val[i].origin, 0), 0);
        (void) hv_store (hv, "snap_percent", 12, newSVnv (r->val[i].snap_percent), 0);
        (void) hv_store (hv, "copy_percent", 12, newSVnv (r->val[i].copy_percent), 0);
        (void) hv_store (hv, "move_pv", 7, newSVpv (r->val[i].move_pv, 0), 0);
        (void) hv_store (hv, "lv_tags", 7, newSVpv (r->val[i].lv_tags, 0), 0);
        (void) hv_store (hv, "mirror_log", 10, newSVpv (r->val[i].mirror_log, 0), 0);
        (void) hv_store (hv, "modules", 7, newSVpv (r->val[i].modules, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_lv_list (r);
#line 17536 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_lvuuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lvuuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 6932 "lib/Sys/Guestfs.xs"
      char *r;
#line 17558 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lvuuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lvuuid(): g is not a blessed HV reference");
    };
#line 6934 "lib/Sys/Guestfs.xs"
      r = guestfs_lvuuid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 17578 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_lxattrlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_lxattrlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 6948 "lib/Sys/Guestfs.xs"
      struct guestfs_xattr_list *r;
      size_t i;
      HV *hv;
#line 17606 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::lxattrlist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::lxattrlist(): g is not a blessed HV reference");
    };
#line 6952 "lib/Sys/Guestfs.xs"
      r = guestfs_lxattrlist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "attrname", 8, newSVpv (r->val[i].attrname, 0), 0);
        (void) hv_store (hv, "attrval", 7, newSVpvn (r->val[i].attrval, r->val[i].attrval_len), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_xattr_list (r);
#line 17632 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_max_disks); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_max_disks)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 6969 "lib/Sys/Guestfs.xs"
      int r;
#line 17653 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::max_disks(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::max_disks(): g is not a blessed HV reference");
    };
#line 6971 "lib/Sys/Guestfs.xs"
      r = guestfs_max_disks (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 17672 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_md_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, name, devices, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char **	devices = XS_unpack_charPtrPtr(ST(2));
#line 6984 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_md_create_argv optargs_s = { .bitmask = 0 };
      struct guestfs_md_create_argv *optargs = &optargs_s;
      size_t items_i;
#line 17701 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_create(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_create(): g is not a blessed HV reference");
    };
#line 6989 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "missingbitmap")) {
          optargs_s.missingbitmap = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_MISSINGBITMAP_BITMASK;
        }
        else if (STREQ (this_arg, "nrdevices")) {
          optargs_s.nrdevices = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_NRDEVICES_BITMASK;
        }
        else if (STREQ (this_arg, "spare")) {
          optargs_s.spare = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_SPARE_BITMASK;
        }
        else if (STREQ (this_arg, "chunk")) {
          optargs_s.chunk = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_CHUNK_BITMASK;
        }
        else if (STREQ (this_arg, "level")) {
          optargs_s.level = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MD_CREATE_LEVEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_md_create_argv (g, name, devices, optargs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17753 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_md_detail); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_detail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, md");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	md = (char *)SvPV_nolen(ST(1));
#line 7033 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 17778 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_detail(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_detail(): g is not a blessed HV reference");
    };
#line 7036 "lib/Sys/Guestfs.xs"
      r = guestfs_md_detail (g, md);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 17802 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_md_stat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_stat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, md");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	md = (char *)SvPV_nolen(ST(1));
#line 7052 "lib/Sys/Guestfs.xs"
      struct guestfs_mdstat_list *r;
      size_t i;
      HV *hv;
#line 17828 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_stat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_stat(): g is not a blessed HV reference");
    };
#line 7056 "lib/Sys/Guestfs.xs"
      r = guestfs_md_stat (g, md);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "mdstat_device", 13, newSVpv (r->val[i].mdstat_device, 0), 0);
        (void) hv_store (hv, "mdstat_index", 12, newSVnv (r->val[i].mdstat_index), 0);
        (void) hv_store (hv, "mdstat_flags", 12, newSVpv (r->val[i].mdstat_flags, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_mdstat_list (r);
#line 17854 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_md_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_md_stop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, md");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	md = (char *)SvPV_nolen(ST(1));
#line 7074 "lib/Sys/Guestfs.xs"
      int r;
#line 17878 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::md_stop(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::md_stop(): g is not a blessed HV reference");
    };
#line 7076 "lib/Sys/Guestfs.xs"
      r = guestfs_md_stop (g, md);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17895 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 7085 "lib/Sys/Guestfs.xs"
      int r;
#line 17919 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdir(): g is not a blessed HV reference");
    };
#line 7087 "lib/Sys/Guestfs.xs"
      r = guestfs_mkdir (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17936 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdir_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdir_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, mode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	mode = (int)SvIV(ST(2));
#line 7097 "lib/Sys/Guestfs.xs"
      int r;
#line 17961 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdir_mode(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdir_mode(): g is not a blessed HV reference");
    };
#line 7099 "lib/Sys/Guestfs.xs"
      r = guestfs_mkdir_mode (g, path, mode);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 17978 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdir_p); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdir_p)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 7108 "lib/Sys/Guestfs.xs"
      int r;
#line 18002 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdir_p(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdir_p(): g is not a blessed HV reference");
    };
#line 7110 "lib/Sys/Guestfs.xs"
      r = guestfs_mkdir_p (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18019 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkdtemp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkdtemp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, tmpl");
    {
	guestfs_h *	g;
	char *	tmpl = (char *)SvPV_nolen(ST(1));
#line 7119 "lib/Sys/Guestfs.xs"
      char *r;
#line 18041 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkdtemp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkdtemp(): g is not a blessed HV reference");
    };
#line 7121 "lib/Sys/Guestfs.xs"
      r = guestfs_mkdtemp (g, tmpl);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 18061 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_mke2fs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 7134 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_mke2fs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mke2fs_argv *optargs = &optargs_s;
      size_t items_i;
#line 18089 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs(): g is not a blessed HV reference");
    };
#line 7139 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "blockscount")) {
          optargs_s.blockscount = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BLOCKSCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "blocksize")) {
          optargs_s.blocksize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BLOCKSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "fragsize")) {
          optargs_s.fragsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FRAGSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "blockspergroup")) {
          optargs_s.blockspergroup = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BLOCKSPERGROUP_BITMASK;
        }
        else if (STREQ (this_arg, "numberofgroups")) {
          optargs_s.numberofgroups = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_NUMBEROFGROUPS_BITMASK;
        }
        else if (STREQ (this_arg, "bytesperinode")) {
          optargs_s.bytesperinode = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_BYTESPERINODE_BITMASK;
        }
        else if (STREQ (this_arg, "inodesize")) {
          optargs_s.inodesize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_INODESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "journalsize")) {
          optargs_s.journalsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_JOURNALSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "numberofinodes")) {
          optargs_s.numberofinodes = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_NUMBEROFINODES_BITMASK;
        }
        else if (STREQ (this_arg, "stridesize")) {
          optargs_s.stridesize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_STRIDESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "stripewidth")) {
          optargs_s.stripewidth = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_STRIPEWIDTH_BITMASK;
        }
        else if (STREQ (this_arg, "maxonlineresize")) {
          optargs_s.maxonlineresize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_MAXONLINERESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "reservedblockspercentage")) {
          optargs_s.reservedblockspercentage = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_RESERVEDBLOCKSPERCENTAGE_BITMASK;
        }
        else if (STREQ (this_arg, "mmpupdateinterval")) {
          optargs_s.mmpupdateinterval = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_MMPUPDATEINTERVAL_BITMASK;
        }
        else if (STREQ (this_arg, "journaldevice")) {
          optargs_s.journaldevice = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_JOURNALDEVICE_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "lastmounteddir")) {
          optargs_s.lastmounteddir = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LASTMOUNTEDDIR_BITMASK;
        }
        else if (STREQ (this_arg, "creatoros")) {
          optargs_s.creatoros = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_CREATOROS_BITMASK;
        }
        else if (STREQ (this_arg, "fstype")) {
          optargs_s.fstype = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FSTYPE_BITMASK;
        }
        else if (STREQ (this_arg, "usagetype")) {
          optargs_s.usagetype = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_USAGETYPE_BITMASK;
        }
        else if (STREQ (this_arg, "uuid")) {
          optargs_s.uuid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_UUID_BITMASK;
        }
        else if (STREQ (this_arg, "forcecreate")) {
          optargs_s.forcecreate = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FORCECREATE_BITMASK;
        }
        else if (STREQ (this_arg, "writesbandgrouponly")) {
          optargs_s.writesbandgrouponly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_WRITESBANDGROUPONLY_BITMASK;
        }
        else if (STREQ (this_arg, "lazyitableinit")) {
          optargs_s.lazyitableinit = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LAZYITABLEINIT_BITMASK;
        }
        else if (STREQ (this_arg, "lazyjournalinit")) {
          optargs_s.lazyjournalinit = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LAZYJOURNALINIT_BITMASK;
        }
        else if (STREQ (this_arg, "testfs")) {
          optargs_s.testfs = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_TESTFS_BITMASK;
        }
        else if (STREQ (this_arg, "discard")) {
          optargs_s.discard = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_DISCARD_BITMASK;
        }
        else if (STREQ (this_arg, "quotatype")) {
          optargs_s.quotatype = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_QUOTATYPE_BITMASK;
        }
        else if (STREQ (this_arg, "extent")) {
          optargs_s.extent = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_EXTENT_BITMASK;
        }
        else if (STREQ (this_arg, "filetype")) {
          optargs_s.filetype = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FILETYPE_BITMASK;
        }
        else if (STREQ (this_arg, "flexbg")) {
          optargs_s.flexbg = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_FLEXBG_BITMASK;
        }
        else if (STREQ (this_arg, "hasjournal")) {
          optargs_s.hasjournal = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_HASJOURNAL_BITMASK;
        }
        else if (STREQ (this_arg, "journaldev")) {
          optargs_s.journaldev = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_JOURNALDEV_BITMASK;
        }
        else if (STREQ (this_arg, "largefile")) {
          optargs_s.largefile = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_LARGEFILE_BITMASK;
        }
        else if (STREQ (this_arg, "quota")) {
          optargs_s.quota = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_QUOTA_BITMASK;
        }
        else if (STREQ (this_arg, "resizeinode")) {
          optargs_s.resizeinode = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_RESIZEINODE_BITMASK;
        }
        else if (STREQ (this_arg, "sparsesuper")) {
          optargs_s.sparsesuper = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_SPARSESUPER_BITMASK;
        }
        else if (STREQ (this_arg, "uninitbg")) {
          optargs_s.uninitbg = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKE2FS_UNINITBG_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mke2fs_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18272 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2fs_J); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs_J)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, fstype, blocksize, device, journal");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
	char *	journal = (char *)SvPV_nolen(ST(4));
#line 7317 "lib/Sys/Guestfs.xs"
      int r;
#line 18299 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs_J(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs_J(): g is not a blessed HV reference");
    };
#line 7319 "lib/Sys/Guestfs.xs"
      r = guestfs_mke2fs_J (g, fstype, blocksize, device, journal);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18316 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2fs_JL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs_JL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, fstype, blocksize, device, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
	char *	label = (char *)SvPV_nolen(ST(4));
#line 7331 "lib/Sys/Guestfs.xs"
      int r;
#line 18343 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs_JL(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs_JL(): g is not a blessed HV reference");
    };
#line 7333 "lib/Sys/Guestfs.xs"
      r = guestfs_mke2fs_JL (g, fstype, blocksize, device, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18360 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2fs_JU); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2fs_JU)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, fstype, blocksize, device, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
	char *	uuid = (char *)SvPV_nolen(ST(4));
#line 7345 "lib/Sys/Guestfs.xs"
      int r;
#line 18387 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2fs_JU(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2fs_JU(): g is not a blessed HV reference");
    };
#line 7347 "lib/Sys/Guestfs.xs"
      r = guestfs_mke2fs_JU (g, fstype, blocksize, device, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18404 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2journal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2journal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, blocksize, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	blocksize = (int)SvIV(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7357 "lib/Sys/Guestfs.xs"
      int r;
#line 18429 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2journal(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2journal(): g is not a blessed HV reference");
    };
#line 7359 "lib/Sys/Guestfs.xs"
      r = guestfs_mke2journal (g, blocksize, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18446 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2journal_L); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2journal_L)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, blocksize, label, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	blocksize = (int)SvIV(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
#line 7370 "lib/Sys/Guestfs.xs"
      int r;
#line 18472 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2journal_L(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2journal_L(): g is not a blessed HV reference");
    };
#line 7372 "lib/Sys/Guestfs.xs"
      r = guestfs_mke2journal_L (g, blocksize, label, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18489 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mke2journal_U); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mke2journal_U)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, blocksize, uuid, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	blocksize = (int)SvIV(ST(1));
	char *	uuid = (char *)SvPV_nolen(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
#line 7383 "lib/Sys/Guestfs.xs"
      int r;
#line 18515 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mke2journal_U(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mke2journal_U(): g is not a blessed HV reference");
    };
#line 7385 "lib/Sys/Guestfs.xs"
      r = guestfs_mke2journal_U (g, blocksize, uuid, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18532 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfifo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfifo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mode, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 7395 "lib/Sys/Guestfs.xs"
      int r;
#line 18557 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfifo(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfifo(): g is not a blessed HV reference");
    };
#line 7397 "lib/Sys/Guestfs.xs"
      r = guestfs_mkfifo (g, mode, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18574 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, fstype, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7407 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_mkfs_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mkfs_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 18602 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfs(): g is not a blessed HV reference");
    };
#line 7412 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "blocksize")) {
          optargs_s.blocksize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_BLOCKSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "features")) {
          optargs_s.features = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_FEATURES_BITMASK;
        }
        else if (STREQ (this_arg, "inode")) {
          optargs_s.inode = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_INODE_BITMASK;
        }
        else if (STREQ (this_arg, "sectorsize")) {
          optargs_s.sectorsize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_SECTORSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_OPTS_LABEL_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mkfs_opts_argv (g, fstype, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18653 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfs_b); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfs_b)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, fstype, blocksize, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	fstype = (char *)SvPV_nolen(ST(1));
	int	blocksize = (int)SvIV(ST(2));
	char *	device = (char *)SvPV_nolen(ST(3));
#line 7457 "lib/Sys/Guestfs.xs"
      int r;
#line 18679 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfs_b(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfs_b(): g is not a blessed HV reference");
    };
#line 7459 "lib/Sys/Guestfs.xs"
      r = guestfs_mkfs_b (g, fstype, blocksize, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18696 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkfs_btrfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkfs_btrfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, devices, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	devices = XS_unpack_charPtrPtr(ST(1));
#line 7468 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_mkfs_btrfs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mkfs_btrfs_argv *optargs = &optargs_s;
      size_t items_i;
#line 18723 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkfs_btrfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkfs_btrfs(): g is not a blessed HV reference");
    };
#line 7473 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "allocstart")) {
          optargs_s.allocstart = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_ALLOCSTART_BITMASK;
        }
        else if (STREQ (this_arg, "bytecount")) {
          optargs_s.bytecount = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_BYTECOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "datatype")) {
          optargs_s.datatype = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_DATATYPE_BITMASK;
        }
        else if (STREQ (this_arg, "leafsize")) {
          optargs_s.leafsize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_LEAFSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "metadata")) {
          optargs_s.metadata = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_METADATA_BITMASK;
        }
        else if (STREQ (this_arg, "nodesize")) {
          optargs_s.nodesize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_NODESIZE_BITMASK;
        }
        else if (STREQ (this_arg, "sectorsize")) {
          optargs_s.sectorsize = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MKFS_BTRFS_SECTORSIZE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mkfs_btrfs_argv (g, devices, optargs);
      free (devices);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18787 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mklost_and_found); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mklost_and_found)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 7529 "lib/Sys/Guestfs.xs"
      int r;
#line 18811 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mklost_and_found(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mklost_and_found(): g is not a blessed HV reference");
    };
#line 7531 "lib/Sys/Guestfs.xs"
      r = guestfs_mklost_and_found (g, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18828 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkmountpoint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkmountpoint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, exemptpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	exemptpath = (char *)SvPV_nolen(ST(1));
#line 7540 "lib/Sys/Guestfs.xs"
      int r;
#line 18852 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkmountpoint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkmountpoint(): g is not a blessed HV reference");
    };
#line 7542 "lib/Sys/Guestfs.xs"
      r = guestfs_mkmountpoint (g, exemptpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18869 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mknod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mknod)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, mode, devmajor, devminor, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	int	devmajor = (int)SvIV(ST(2));
	int	devminor = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 7554 "lib/Sys/Guestfs.xs"
      int r;
#line 18896 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mknod(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mknod(): g is not a blessed HV reference");
    };
#line 7556 "lib/Sys/Guestfs.xs"
      r = guestfs_mknod (g, mode, devmajor, devminor, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18913 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mknod_b); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mknod_b)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, mode, devmajor, devminor, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	int	devmajor = (int)SvIV(ST(2));
	int	devminor = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 7568 "lib/Sys/Guestfs.xs"
      int r;
#line 18940 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mknod_b(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mknod_b(): g is not a blessed HV reference");
    };
#line 7570 "lib/Sys/Guestfs.xs"
      r = guestfs_mknod_b (g, mode, devmajor, devminor, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 18957 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mknod_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mknod_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, mode, devmajor, devminor, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	mode = (int)SvIV(ST(1));
	int	devmajor = (int)SvIV(ST(2));
	int	devminor = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 7582 "lib/Sys/Guestfs.xs"
      int r;
#line 18984 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mknod_c(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mknod_c(): g is not a blessed HV reference");
    };
#line 7584 "lib/Sys/Guestfs.xs"
      r = guestfs_mknod_c (g, mode, devmajor, devminor, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19001 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 7593 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_mkswap_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mkswap_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 19028 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap(): g is not a blessed HV reference");
    };
#line 7598 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKSWAP_OPTS_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "uuid")) {
          optargs_s.uuid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKSWAP_OPTS_UUID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mkswap_opts_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19067 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap_L); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap_L)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, label, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7630 "lib/Sys/Guestfs.xs"
      int r;
#line 19092 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap_L(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap_L(): g is not a blessed HV reference");
    };
#line 7632 "lib/Sys/Guestfs.xs"
      r = guestfs_mkswap_L (g, label, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19109 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap_U); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap_U)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, uuid, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7642 "lib/Sys/Guestfs.xs"
      int r;
#line 19134 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap_U(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap_U(): g is not a blessed HV reference");
    };
#line 7644 "lib/Sys/Guestfs.xs"
      r = guestfs_mkswap_U (g, uuid, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19151 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mkswap_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mkswap_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 7653 "lib/Sys/Guestfs.xs"
      int r;
#line 19175 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mkswap_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mkswap_file(): g is not a blessed HV reference");
    };
#line 7655 "lib/Sys/Guestfs.xs"
      r = guestfs_mkswap_file (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19192 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mktemp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mktemp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, tmpl, ...");
    {
	guestfs_h *	g;
	char *	tmpl = (char *)SvPV_nolen(ST(1));
#line 7664 "lib/Sys/Guestfs.xs"
      char *r;
      struct guestfs_mktemp_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mktemp_argv *optargs = &optargs_s;
      size_t items_i;
#line 19217 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mktemp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mktemp(): g is not a blessed HV reference");
    };
#line 7669 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "suffix")) {
          optargs_s.suffix = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MKTEMP_SUFFIX_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mktemp_argv (g, tmpl, optargs);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 19255 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_modprobe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_modprobe)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, modulename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	modulename = (char *)SvPV_nolen(ST(1));
#line 7700 "lib/Sys/Guestfs.xs"
      int r;
#line 19280 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::modprobe(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::modprobe(): g is not a blessed HV reference");
    };
#line 7702 "lib/Sys/Guestfs.xs"
      r = guestfs_modprobe (g, modulename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19297 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7712 "lib/Sys/Guestfs.xs"
      int r;
#line 19322 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount(): g is not a blessed HV reference");
    };
#line 7714 "lib/Sys/Guestfs.xs"
      r = guestfs_mount (g, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19339 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_9p); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_9p)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, mounttag, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mounttag = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7724 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_mount_9p_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mount_9p_argv *optargs = &optargs_s;
      size_t items_i;
#line 19367 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_9p(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_9p(): g is not a blessed HV reference");
    };
#line 7729 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "options")) {
          optargs_s.options = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_9P_OPTIONS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mount_9p_argv (g, mounttag, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19402 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_local); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_local)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, localmountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	localmountpoint = (char *)SvPV_nolen(ST(1));
#line 7756 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_mount_local_argv optargs_s = { .bitmask = 0 };
      struct guestfs_mount_local_argv *optargs = &optargs_s;
      size_t items_i;
#line 19429 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_local(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_local(): g is not a blessed HV reference");
    };
#line 7761 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "readonly")) {
          optargs_s.readonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_READONLY_BITMASK;
        }
        else if (STREQ (this_arg, "options")) {
          optargs_s.options = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_OPTIONS_BITMASK;
        }
        else if (STREQ (this_arg, "cachetimeout")) {
          optargs_s.cachetimeout = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_CACHETIMEOUT_BITMASK;
        }
        else if (STREQ (this_arg, "debugcalls")) {
          optargs_s.debugcalls = SvIV (ST (items_i+1));
          this_mask = GUESTFS_MOUNT_LOCAL_DEBUGCALLS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_mount_local_argv (g, localmountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19476 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_local_run); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_local_run)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 7799 "lib/Sys/Guestfs.xs"
      int r;
#line 19499 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_local_run(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_local_run(): g is not a blessed HV reference");
    };
#line 7801 "lib/Sys/Guestfs.xs"
      r = guestfs_mount_local_run (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19516 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_loop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_loop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, file, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7811 "lib/Sys/Guestfs.xs"
      int r;
#line 19541 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_loop(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_loop(): g is not a blessed HV reference");
    };
#line 7813 "lib/Sys/Guestfs.xs"
      r = guestfs_mount_loop (g, file, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19558 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_options); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_options)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, options, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	options = (char *)SvPV_nolen(ST(1));
	char *	mountable = (char *)SvPV_nolen(ST(2));
	char *	mountpoint = (char *)SvPV_nolen(ST(3));
#line 7824 "lib/Sys/Guestfs.xs"
      int r;
#line 19584 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_options(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_options(): g is not a blessed HV reference");
    };
#line 7826 "lib/Sys/Guestfs.xs"
      r = guestfs_mount_options (g, options, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19601 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_ro); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_ro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
	char *	mountpoint = (char *)SvPV_nolen(ST(2));
#line 7836 "lib/Sys/Guestfs.xs"
      int r;
#line 19626 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_ro(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_ro(): g is not a blessed HV reference");
    };
#line 7838 "lib/Sys/Guestfs.xs"
      r = guestfs_mount_ro (g, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19643 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mount_vfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mount_vfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, options, vfstype, mountable, mountpoint");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	options = (char *)SvPV_nolen(ST(1));
	char *	vfstype = (char *)SvPV_nolen(ST(2));
	char *	mountable = (char *)SvPV_nolen(ST(3));
	char *	mountpoint = (char *)SvPV_nolen(ST(4));
#line 7850 "lib/Sys/Guestfs.xs"
      int r;
#line 19670 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mount_vfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mount_vfs(): g is not a blessed HV reference");
    };
#line 7852 "lib/Sys/Guestfs.xs"
      r = guestfs_mount_vfs (g, options, vfstype, mountable, mountpoint);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19687 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mountpoints); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mountpoints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 7860 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 19711 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mountpoints(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mountpoints(): g is not a blessed HV reference");
    };
#line 7863 "lib/Sys/Guestfs.xs"
      r = guestfs_mountpoints (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 19735 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mounts); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mounts)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 7878 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 19759 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mounts(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mounts(): g is not a blessed HV reference");
    };
#line 7881 "lib/Sys/Guestfs.xs"
      r = guestfs_mounts (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 19783 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_mv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_mv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, src, dest");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 7898 "lib/Sys/Guestfs.xs"
      int r;
#line 19808 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::mv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::mv(): g is not a blessed HV reference");
    };
#line 7900 "lib/Sys/Guestfs.xs"
      r = guestfs_mv (g, src, dest);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19825 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_nr_devices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_nr_devices)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	guestfs_h *	g;
#line 7908 "lib/Sys/Guestfs.xs"
      int r;
#line 19846 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::nr_devices(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::nr_devices(): g is not a blessed HV reference");
    };
#line 7910 "lib/Sys/Guestfs.xs"
      r = guestfs_nr_devices (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 19865 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ntfs_3g_probe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfs_3g_probe)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, rw, device");
    {
	guestfs_h *	g;
	int	rw = (int)SvIV(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7923 "lib/Sys/Guestfs.xs"
      int r;
#line 19889 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfs_3g_probe(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfs_3g_probe(): g is not a blessed HV reference");
    };
#line 7925 "lib/Sys/Guestfs.xs"
      r = guestfs_ntfs_3g_probe (g, rw, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 19908 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ntfsclone_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsclone_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, backupfile, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	backupfile = (char *)SvPV_nolen(ST(1));
	char *	device = (char *)SvPV_nolen(ST(2));
#line 7938 "lib/Sys/Guestfs.xs"
      int r;
#line 19934 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsclone_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsclone_in(): g is not a blessed HV reference");
    };
#line 7940 "lib/Sys/Guestfs.xs"
      r = guestfs_ntfsclone_in (g, backupfile, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 19951 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsclone_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsclone_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, device, backupfile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	backupfile = (char *)SvPV_nolen(ST(2));
#line 7950 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_ntfsclone_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_ntfsclone_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 19979 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsclone_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsclone_out(): g is not a blessed HV reference");
    };
#line 7955 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "metadataonly")) {
          optargs_s.metadataonly = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_METADATAONLY_BITMASK;
        }
        else if (STREQ (this_arg, "rescue")) {
          optargs_s.rescue = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_RESCUE_BITMASK;
        }
        else if (STREQ (this_arg, "ignorefscheck")) {
          optargs_s.ignorefscheck = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_IGNOREFSCHECK_BITMASK;
        }
        else if (STREQ (this_arg, "preservetimestamps")) {
          optargs_s.preservetimestamps = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_PRESERVETIMESTAMPS_BITMASK;
        }
        else if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSCLONE_OUT_FORCE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_ntfsclone_out_argv (g, device, backupfile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20030 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsfix); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsfix)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 7998 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_ntfsfix_argv optargs_s = { .bitmask = 0 };
      struct guestfs_ntfsfix_argv *optargs = &optargs_s;
      size_t items_i;
#line 20057 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsfix(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsfix(): g is not a blessed HV reference");
    };
#line 8003 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "clearbadsectors")) {
          optargs_s.clearbadsectors = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSFIX_CLEARBADSECTORS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_ntfsfix_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20092 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsresize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsresize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8030 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_ntfsresize_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_ntfsresize_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 20119 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsresize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsresize(): g is not a blessed HV reference");
    };
#line 8035 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "size")) {
          optargs_s.size = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_NTFSRESIZE_OPTS_SIZE_BITMASK;
        }
        else if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_NTFSRESIZE_OPTS_FORCE_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_ntfsresize_opts_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20158 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_ntfsresize_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ntfsresize_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 8067 "lib/Sys/Guestfs.xs"
      int r;
#line 20183 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ntfsresize_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ntfsresize_size(): g is not a blessed HV reference");
    };
#line 8069 "lib/Sys/Guestfs.xs"
      r = guestfs_ntfsresize_size (g, device, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20200 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_parse_environment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_parse_environment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8077 "lib/Sys/Guestfs.xs"
      int r;
#line 20223 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::parse_environment(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::parse_environment(): g is not a blessed HV reference");
    };
#line 8079 "lib/Sys/Guestfs.xs"
      r = guestfs_parse_environment (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20240 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_parse_environment_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_parse_environment_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, environment");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	environment = XS_unpack_charPtrPtr(ST(1));
#line 8088 "lib/Sys/Guestfs.xs"
      int r;
#line 20264 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::parse_environment_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::parse_environment_list(): g is not a blessed HV reference");
    };
#line 8090 "lib/Sys/Guestfs.xs"
      r = guestfs_parse_environment_list (g, environment);
      free (environment);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20282 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, device, prlogex, startsect, endsect");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	prlogex = (char *)SvPV_nolen(ST(2));
	int64_t    startsect = my_SvIV64 (ST(3));
	int64_t    endsect = my_SvIV64 (ST(4));
#line 8103 "lib/Sys/Guestfs.xs"
      int r;
#line 20309 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_add(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_add(): g is not a blessed HV reference");
    };
#line 8105 "lib/Sys/Guestfs.xs"
      r = guestfs_part_add (g, device, prlogex, startsect, endsect);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20326 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_del); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_del)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8115 "lib/Sys/Guestfs.xs"
      int r;
#line 20351 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_del(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_del(): g is not a blessed HV reference");
    };
#line 8117 "lib/Sys/Guestfs.xs"
      r = guestfs_part_del (g, device, partnum);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20368 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_disk); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_disk)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, parttype");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	parttype = (char *)SvPV_nolen(ST(2));
#line 8127 "lib/Sys/Guestfs.xs"
      int r;
#line 20393 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_disk(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_disk(): g is not a blessed HV reference");
    };
#line 8129 "lib/Sys/Guestfs.xs"
      r = guestfs_part_disk (g, device, parttype);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20410 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_get_bootable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_bootable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8139 "lib/Sys/Guestfs.xs"
      int r;
#line 20433 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_bootable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_bootable(): g is not a blessed HV reference");
    };
#line 8141 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_bootable (g, device, partnum);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 20452 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_gpt_guid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_gpt_guid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8154 "lib/Sys/Guestfs.xs"
      char *r;
#line 20476 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_gpt_guid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_gpt_guid(): g is not a blessed HV reference");
    };
#line 8156 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_gpt_guid (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20496 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_gpt_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_gpt_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8170 "lib/Sys/Guestfs.xs"
      char *r;
#line 20520 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_gpt_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_gpt_type(): g is not a blessed HV reference");
    };
#line 8172 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_gpt_type (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20540 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_mbr_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_mbr_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8186 "lib/Sys/Guestfs.xs"
      int r;
#line 20564 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_mbr_id(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_mbr_id(): g is not a blessed HV reference");
    };
#line 8188 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_mbr_id (g, device, partnum);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 20583 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_mbr_part_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_mbr_part_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8201 "lib/Sys/Guestfs.xs"
      char *r;
#line 20607 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_mbr_part_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_mbr_part_type(): g is not a blessed HV reference");
    };
#line 8203 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_mbr_part_type (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20627 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, partnum");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
#line 8217 "lib/Sys/Guestfs.xs"
      char *r;
#line 20651 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_name(): g is not a blessed HV reference");
    };
#line 8219 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_name (g, device, partnum);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20671 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_get_parttype); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_get_parttype)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8232 "lib/Sys/Guestfs.xs"
      char *r;
#line 20694 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_get_parttype(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_get_parttype(): g is not a blessed HV reference");
    };
#line 8234 "lib/Sys/Guestfs.xs"
      r = guestfs_part_get_parttype (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 20714 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, parttype");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	parttype = (char *)SvPV_nolen(ST(2));
#line 8248 "lib/Sys/Guestfs.xs"
      int r;
#line 20740 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_init(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_init(): g is not a blessed HV reference");
    };
#line 8250 "lib/Sys/Guestfs.xs"
      r = guestfs_part_init (g, device, parttype);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20757 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8259 "lib/Sys/Guestfs.xs"
      struct guestfs_partition_list *r;
      size_t i;
      HV *hv;
#line 20783 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_list(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_list(): g is not a blessed HV reference");
    };
#line 8263 "lib/Sys/Guestfs.xs"
      r = guestfs_part_list (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "part_num", 8, newSVnv (r->val[i].part_num), 0);
        (void) hv_store (hv, "part_start", 10, my_newSVull (r->val[i].part_start), 0);
        (void) hv_store (hv, "part_end", 8, my_newSVull (r->val[i].part_end), 0);
        (void) hv_store (hv, "part_size", 9, my_newSVull (r->val[i].part_size), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_partition_list (r);
#line 20810 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_bootable); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_bootable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, bootable");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	int	bootable = (int)SvIV(ST(3));
#line 8284 "lib/Sys/Guestfs.xs"
      int r;
#line 20836 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_bootable(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_bootable(): g is not a blessed HV reference");
    };
#line 8286 "lib/Sys/Guestfs.xs"
      r = guestfs_part_set_bootable (g, device, partnum, bootable);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20853 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_gpt_guid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_gpt_guid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, guid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	char *	guid = (char *)SvPV_nolen(ST(3));
#line 8297 "lib/Sys/Guestfs.xs"
      int r;
#line 20879 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_gpt_guid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_gpt_guid(): g is not a blessed HV reference");
    };
#line 8299 "lib/Sys/Guestfs.xs"
      r = guestfs_part_set_gpt_guid (g, device, partnum, guid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20896 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_gpt_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_gpt_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, guid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	char *	guid = (char *)SvPV_nolen(ST(3));
#line 8310 "lib/Sys/Guestfs.xs"
      int r;
#line 20922 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_gpt_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_gpt_type(): g is not a blessed HV reference");
    };
#line 8312 "lib/Sys/Guestfs.xs"
      r = guestfs_part_set_gpt_type (g, device, partnum, guid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20939 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_mbr_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_mbr_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, idbyte");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	int	idbyte = (int)SvIV(ST(3));
#line 8323 "lib/Sys/Guestfs.xs"
      int r;
#line 20965 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_mbr_id(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_mbr_id(): g is not a blessed HV reference");
    };
#line 8325 "lib/Sys/Guestfs.xs"
      r = guestfs_part_set_mbr_id (g, device, partnum, idbyte);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 20982 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_set_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_set_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, partnum, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	char *	name = (char *)SvPV_nolen(ST(3));
#line 8336 "lib/Sys/Guestfs.xs"
      int r;
#line 21008 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_set_name(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_set_name(): g is not a blessed HV reference");
    };
#line 8338 "lib/Sys/Guestfs.xs"
      r = guestfs_part_set_name (g, device, partnum, name);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21025 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_part_to_dev); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_to_dev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, partition");
    {
	guestfs_h *	g;
	char *	partition = (char *)SvPV_nolen(ST(1));
#line 8347 "lib/Sys/Guestfs.xs"
      char *r;
#line 21047 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_to_dev(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_to_dev(): g is not a blessed HV reference");
    };
#line 8349 "lib/Sys/Guestfs.xs"
      r = guestfs_part_to_dev (g, partition);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21067 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_part_to_partnum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_part_to_partnum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, partition");
    {
	guestfs_h *	g;
	char *	partition = (char *)SvPV_nolen(ST(1));
#line 8362 "lib/Sys/Guestfs.xs"
      int r;
#line 21090 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::part_to_partnum(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::part_to_partnum(): g is not a blessed HV reference");
    };
#line 8364 "lib/Sys/Guestfs.xs"
      r = guestfs_part_to_partnum (g, partition);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 21109 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_ping_daemon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_ping_daemon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8375 "lib/Sys/Guestfs.xs"
      int r;
#line 21133 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::ping_daemon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::ping_daemon(): g is not a blessed HV reference");
    };
#line 8377 "lib/Sys/Guestfs.xs"
      r = guestfs_ping_daemon (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21150 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pread); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pread)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, count, offset");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int	count = (int)SvIV(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8388 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 21175 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pread(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pread(): g is not a blessed HV reference");
    };
#line 8391 "lib/Sys/Guestfs.xs"
      r = guestfs_pread (g, path, count, offset, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 21195 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pread_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pread_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, count, offset");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	count = (int)SvIV(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8406 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 21221 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pread_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pread_device(): g is not a blessed HV reference");
    };
#line 8409 "lib/Sys/Guestfs.xs"
      r = guestfs_pread_device (g, device, count, offset, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 21241 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pvchange_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvchange_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8422 "lib/Sys/Guestfs.xs"
      int r;
#line 21266 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvchange_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvchange_uuid(): g is not a blessed HV reference");
    };
#line 8424 "lib/Sys/Guestfs.xs"
      r = guestfs_pvchange_uuid (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21283 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvchange_uuid_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvchange_uuid_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8432 "lib/Sys/Guestfs.xs"
      int r;
#line 21306 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvchange_uuid_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvchange_uuid_all(): g is not a blessed HV reference");
    };
#line 8434 "lib/Sys/Guestfs.xs"
      r = guestfs_pvchange_uuid_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21323 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvcreate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvcreate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8443 "lib/Sys/Guestfs.xs"
      int r;
#line 21347 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvcreate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvcreate(): g is not a blessed HV reference");
    };
#line 8445 "lib/Sys/Guestfs.xs"
      r = guestfs_pvcreate (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21364 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvremove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvremove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8454 "lib/Sys/Guestfs.xs"
      int r;
#line 21388 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvremove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvremove(): g is not a blessed HV reference");
    };
#line 8456 "lib/Sys/Guestfs.xs"
      r = guestfs_pvremove (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21405 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvresize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvresize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8465 "lib/Sys/Guestfs.xs"
      int r;
#line 21429 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvresize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvresize(): g is not a blessed HV reference");
    };
#line 8467 "lib/Sys/Guestfs.xs"
      r = guestfs_pvresize (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21446 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvresize_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvresize_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 8477 "lib/Sys/Guestfs.xs"
      int r;
#line 21471 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvresize_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvresize_size(): g is not a blessed HV reference");
    };
#line 8479 "lib/Sys/Guestfs.xs"
      r = guestfs_pvresize_size (g, device, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 21488 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8487 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 21512 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvs(): g is not a blessed HV reference");
    };
#line 8490 "lib/Sys/Guestfs.xs"
      r = guestfs_pvs (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 21536 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvs_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvs_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 8505 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_pv_list *r;
      size_t i;
      HV *hv;
#line 21561 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvs_full(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvs_full(): g is not a blessed HV reference");
    };
#line 8509 "lib/Sys/Guestfs.xs"
      r = guestfs_pvs_full (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "pv_name", 7, newSVpv (r->val[i].pv_name, 0), 0);
        (void) hv_store (hv, "pv_uuid", 7, newSVpv (r->val[i].pv_uuid, 32), 0);
        (void) hv_store (hv, "pv_fmt", 6, newSVpv (r->val[i].pv_fmt, 0), 0);
        (void) hv_store (hv, "pv_size", 7, my_newSVull (r->val[i].pv_size), 0);
        (void) hv_store (hv, "dev_size", 8, my_newSVull (r->val[i].dev_size), 0);
        (void) hv_store (hv, "pv_free", 7, my_newSVull (r->val[i].pv_free), 0);
        (void) hv_store (hv, "pv_used", 7, my_newSVull (r->val[i].pv_used), 0);
        (void) hv_store (hv, "pv_attr", 7, newSVpv (r->val[i].pv_attr, 0), 0);
        (void) hv_store (hv, "pv_pe_count", 11, my_newSVll (r->val[i].pv_pe_count), 0);
        (void) hv_store (hv, "pv_pe_alloc_count", 17, my_newSVll (r->val[i].pv_pe_alloc_count), 0);
        (void) hv_store (hv, "pv_tags", 7, newSVpv (r->val[i].pv_tags, 0), 0);
        (void) hv_store (hv, "pe_start", 8, my_newSVull (r->val[i].pe_start), 0);
        (void) hv_store (hv, "pv_mda_count", 12, my_newSVll (r->val[i].pv_mda_count), 0);
        (void) hv_store (hv, "pv_mda_free", 11, my_newSVull (r->val[i].pv_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_pv_list (r);
#line 21598 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_pvuuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pvuuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8538 "lib/Sys/Guestfs.xs"
      char *r;
#line 21620 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pvuuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pvuuid(): g is not a blessed HV reference");
    };
#line 8540 "lib/Sys/Guestfs.xs"
      r = guestfs_pvuuid (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21640 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pwrite); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pwrite)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, content, offset");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8556 "lib/Sys/Guestfs.xs"
      int r;
#line 21666 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pwrite(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pwrite(): g is not a blessed HV reference");
    };
#line 8558 "lib/Sys/Guestfs.xs"
      r = guestfs_pwrite (g, path, content, content_size, offset);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 21685 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_pwrite_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_pwrite_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, device, content, offset");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 8573 "lib/Sys/Guestfs.xs"
      int r;
#line 21711 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::pwrite_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::pwrite_device(): g is not a blessed HV reference");
    };
#line 8575 "lib/Sys/Guestfs.xs"
      r = guestfs_pwrite_device (g, device, content, content_size, offset);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 21730 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_read_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_read_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8587 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 21754 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::read_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::read_file(): g is not a blessed HV reference");
    };
#line 8590 "lib/Sys/Guestfs.xs"
      r = guestfs_read_file (g, path, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 21774 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_read_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_read_lines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8603 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 21800 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::read_lines(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::read_lines(): g is not a blessed HV reference");
    };
#line 8606 "lib/Sys/Guestfs.xs"
      r = guestfs_read_lines (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 21824 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_readdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_readdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
#line 8622 "lib/Sys/Guestfs.xs"
      struct guestfs_dirent_list *r;
      size_t i;
      HV *hv;
#line 21850 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::readdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::readdir(): g is not a blessed HV reference");
    };
#line 8626 "lib/Sys/Guestfs.xs"
      r = guestfs_readdir (g, dir);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "ino", 3, my_newSVll (r->val[i].ino), 0);
        (void) hv_store (hv, "ftyp", 4, newSVpv (&r->val[i].ftyp, 1), 0);
        (void) hv_store (hv, "name", 4, newSVpv (r->val[i].name, 0), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_dirent_list (r);
#line 21876 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_readlink); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_readlink)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8644 "lib/Sys/Guestfs.xs"
      char *r;
#line 21898 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::readlink(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::readlink(): g is not a blessed HV reference");
    };
#line 8646 "lib/Sys/Guestfs.xs"
      r = guestfs_readlink (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 21918 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_readlinklist); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_readlinklist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, names");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char **	names = XS_unpack_charPtrPtr(ST(2));
#line 8660 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 21945 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::readlinklist(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::readlinklist(): g is not a blessed HV reference");
    };
#line 8663 "lib/Sys/Guestfs.xs"
      r = guestfs_readlinklist (g, path, names);
      free (names);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 21970 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_realpath); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_realpath)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8680 "lib/Sys/Guestfs.xs"
      char *r;
#line 21992 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::realpath(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::realpath(): g is not a blessed HV reference");
    };
#line 8682 "lib/Sys/Guestfs.xs"
      r = guestfs_realpath (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 22012 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_remount); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_remount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, mountpoint, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountpoint = (char *)SvPV_nolen(ST(1));
#line 8695 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_remount_argv optargs_s = { .bitmask = 0 };
      struct guestfs_remount_argv *optargs = &optargs_s;
      size_t items_i;
#line 22040 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::remount(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::remount(): g is not a blessed HV reference");
    };
#line 8700 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "rw")) {
          optargs_s.rw = SvIV (ST (items_i+1));
          this_mask = GUESTFS_REMOUNT_RW_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_remount_argv (g, mountpoint, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22075 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_remove_drive); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_remove_drive)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 8727 "lib/Sys/Guestfs.xs"
      int r;
#line 22099 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::remove_drive(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::remove_drive(): g is not a blessed HV reference");
    };
#line 8729 "lib/Sys/Guestfs.xs"
      r = guestfs_remove_drive (g, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22116 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_removexattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_removexattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, xattr, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 8739 "lib/Sys/Guestfs.xs"
      int r;
#line 22141 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::removexattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::removexattr(): g is not a blessed HV reference");
    };
#line 8741 "lib/Sys/Guestfs.xs"
      r = guestfs_removexattr (g, xattr, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22158 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rename)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, oldpath, newpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	oldpath = (char *)SvPV_nolen(ST(1));
	char *	newpath = (char *)SvPV_nolen(ST(2));
#line 8751 "lib/Sys/Guestfs.xs"
      int r;
#line 22183 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rename(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rename(): g is not a blessed HV reference");
    };
#line 8753 "lib/Sys/Guestfs.xs"
      r = guestfs_rename (g, oldpath, newpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22200 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_resize2fs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_resize2fs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8762 "lib/Sys/Guestfs.xs"
      int r;
#line 22224 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::resize2fs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::resize2fs(): g is not a blessed HV reference");
    };
#line 8764 "lib/Sys/Guestfs.xs"
      r = guestfs_resize2fs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22241 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_resize2fs_M); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_resize2fs_M)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8773 "lib/Sys/Guestfs.xs"
      int r;
#line 22265 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::resize2fs_M(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::resize2fs_M(): g is not a blessed HV reference");
    };
#line 8775 "lib/Sys/Guestfs.xs"
      r = guestfs_resize2fs_M (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22282 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_resize2fs_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_resize2fs_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 8785 "lib/Sys/Guestfs.xs"
      int r;
#line 22307 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::resize2fs_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::resize2fs_size(): g is not a blessed HV reference");
    };
#line 8787 "lib/Sys/Guestfs.xs"
      r = guestfs_resize2fs_size (g, device, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22324 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8796 "lib/Sys/Guestfs.xs"
      int r;
#line 22348 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rm(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rm(): g is not a blessed HV reference");
    };
#line 8798 "lib/Sys/Guestfs.xs"
      r = guestfs_rm (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22365 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rm_f); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rm_f)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8807 "lib/Sys/Guestfs.xs"
      int r;
#line 22389 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rm_f(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rm_f(): g is not a blessed HV reference");
    };
#line 8809 "lib/Sys/Guestfs.xs"
      r = guestfs_rm_f (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22406 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rm_rf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rm_rf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8818 "lib/Sys/Guestfs.xs"
      int r;
#line 22430 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rm_rf(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rm_rf(): g is not a blessed HV reference");
    };
#line 8820 "lib/Sys/Guestfs.xs"
      r = guestfs_rm_rf (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22447 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rmdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rmdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 8829 "lib/Sys/Guestfs.xs"
      int r;
#line 22471 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rmdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rmdir(): g is not a blessed HV reference");
    };
#line 8831 "lib/Sys/Guestfs.xs"
      r = guestfs_rmdir (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22488 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rmmountpoint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rmmountpoint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, exemptpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	exemptpath = (char *)SvPV_nolen(ST(1));
#line 8840 "lib/Sys/Guestfs.xs"
      int r;
#line 22512 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rmmountpoint(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rmmountpoint(): g is not a blessed HV reference");
    };
#line 8842 "lib/Sys/Guestfs.xs"
      r = guestfs_rmmountpoint (g, exemptpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22529 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rsync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rsync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 8852 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_rsync_argv optargs_s = { .bitmask = 0 };
      struct guestfs_rsync_argv *optargs = &optargs_s;
      size_t items_i;
#line 22557 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rsync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rsync(): g is not a blessed HV reference");
    };
#line 8857 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "archive")) {
          optargs_s.archive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_ARCHIVE_BITMASK;
        }
        else if (STREQ (this_arg, "deletedest")) {
          optargs_s.deletedest = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_DELETEDEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_rsync_argv (g, src, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22596 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rsync_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rsync_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, remote, dest, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	remote = (char *)SvPV_nolen(ST(1));
	char *	dest = (char *)SvPV_nolen(ST(2));
#line 8889 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_rsync_in_argv optargs_s = { .bitmask = 0 };
      struct guestfs_rsync_in_argv *optargs = &optargs_s;
      size_t items_i;
#line 22624 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rsync_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rsync_in(): g is not a blessed HV reference");
    };
#line 8894 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "archive")) {
          optargs_s.archive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_IN_ARCHIVE_BITMASK;
        }
        else if (STREQ (this_arg, "deletedest")) {
          optargs_s.deletedest = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_IN_DELETEDEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_rsync_in_argv (g, remote, dest, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22663 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_rsync_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_rsync_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, src, remote, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	src = (char *)SvPV_nolen(ST(1));
	char *	remote = (char *)SvPV_nolen(ST(2));
#line 8926 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_rsync_out_argv optargs_s = { .bitmask = 0 };
      struct guestfs_rsync_out_argv *optargs = &optargs_s;
      size_t items_i;
#line 22691 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::rsync_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::rsync_out(): g is not a blessed HV reference");
    };
#line 8931 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "archive")) {
          optargs_s.archive = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_OUT_ARCHIVE_BITMASK;
        }
        else if (STREQ (this_arg, "deletedest")) {
          optargs_s.deletedest = SvIV (ST (items_i+1));
          this_mask = GUESTFS_RSYNC_OUT_DELETEDEST_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_rsync_out_argv (g, src, remote, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22730 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_scrub_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_scrub_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 8962 "lib/Sys/Guestfs.xs"
      int r;
#line 22754 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::scrub_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::scrub_device(): g is not a blessed HV reference");
    };
#line 8964 "lib/Sys/Guestfs.xs"
      r = guestfs_scrub_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22771 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_scrub_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_scrub_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 8973 "lib/Sys/Guestfs.xs"
      int r;
#line 22795 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::scrub_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::scrub_file(): g is not a blessed HV reference");
    };
#line 8975 "lib/Sys/Guestfs.xs"
      r = guestfs_scrub_file (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22812 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_scrub_freespace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_scrub_freespace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	dir = (char *)SvPV_nolen(ST(1));
#line 8984 "lib/Sys/Guestfs.xs"
      int r;
#line 22836 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::scrub_freespace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::scrub_freespace(): g is not a blessed HV reference");
    };
#line 8986 "lib/Sys/Guestfs.xs"
      r = guestfs_scrub_freespace (g, dir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22853 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, append");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	append = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 8995 "lib/Sys/Guestfs.xs"
      int r;
#line 22877 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_append(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_append(): g is not a blessed HV reference");
    };
#line 8997 "lib/Sys/Guestfs.xs"
      r = guestfs_set_append (g, append);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22894 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_attach_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_attach_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, backend");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	backend = (char *)SvPV_nolen(ST(1));
#line 9006 "lib/Sys/Guestfs.xs"
      int r;
#line 22918 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_attach_method(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_attach_method(): g is not a blessed HV reference");
    };
#line 9008 "lib/Sys/Guestfs.xs"
      r = guestfs_set_attach_method (g, backend);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22935 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_autosync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_autosync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, autosync");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	autosync = (int)SvIV(ST(1));
#line 9017 "lib/Sys/Guestfs.xs"
      int r;
#line 22959 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_autosync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_autosync(): g is not a blessed HV reference");
    };
#line 9019 "lib/Sys/Guestfs.xs"
      r = guestfs_set_autosync (g, autosync);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 22976 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_backend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_backend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, backend");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	backend = (char *)SvPV_nolen(ST(1));
#line 9028 "lib/Sys/Guestfs.xs"
      int r;
#line 23000 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_backend(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_backend(): g is not a blessed HV reference");
    };
#line 9030 "lib/Sys/Guestfs.xs"
      r = guestfs_set_backend (g, backend);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23017 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_backend_setting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_backend_setting)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, name, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	name = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
#line 9040 "lib/Sys/Guestfs.xs"
      int r;
#line 23042 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_backend_setting(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_backend_setting(): g is not a blessed HV reference");
    };
#line 9042 "lib/Sys/Guestfs.xs"
      r = guestfs_set_backend_setting (g, name, val);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23059 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_backend_settings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_backend_settings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, settings");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	settings = XS_unpack_charPtrPtr(ST(1));
#line 9051 "lib/Sys/Guestfs.xs"
      int r;
#line 23083 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_backend_settings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_backend_settings(): g is not a blessed HV reference");
    };
#line 9053 "lib/Sys/Guestfs.xs"
      r = guestfs_set_backend_settings (g, settings);
      free (settings);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23101 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_cachedir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_cachedir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, cachedir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	cachedir = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9063 "lib/Sys/Guestfs.xs"
      int r;
#line 23125 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_cachedir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_cachedir(): g is not a blessed HV reference");
    };
#line 9065 "lib/Sys/Guestfs.xs"
      r = guestfs_set_cachedir (g, cachedir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23142 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_direct); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_direct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, direct");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	direct = (int)SvIV(ST(1));
#line 9074 "lib/Sys/Guestfs.xs"
      int r;
#line 23166 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_direct(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_direct(): g is not a blessed HV reference");
    };
#line 9076 "lib/Sys/Guestfs.xs"
      r = guestfs_set_direct (g, direct);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23183 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2attrs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2attrs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, file, attrs, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
	char *	attrs = (char *)SvPV_nolen(ST(2));
#line 9086 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_set_e2attrs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_set_e2attrs_argv *optargs = &optargs_s;
      size_t items_i;
#line 23211 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2attrs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2attrs(): g is not a blessed HV reference");
    };
#line 9091 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "clear")) {
          optargs_s.clear = SvIV (ST (items_i+1));
          this_mask = GUESTFS_SET_E2ATTRS_CLEAR_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_set_e2attrs_argv (g, file, attrs, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23246 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, file, generation");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
	int64_t    generation = my_SvIV64 (ST(2));
#line 9119 "lib/Sys/Guestfs.xs"
      int r;
#line 23271 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2generation(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2generation(): g is not a blessed HV reference");
    };
#line 9121 "lib/Sys/Guestfs.xs"
      r = guestfs_set_e2generation (g, file, generation);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23288 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
#line 9131 "lib/Sys/Guestfs.xs"
      int r;
#line 23313 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2label(): g is not a blessed HV reference");
    };
#line 9133 "lib/Sys/Guestfs.xs"
      r = guestfs_set_e2label (g, device, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23330 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_e2uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_e2uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	uuid = (char *)SvPV_nolen(ST(2));
#line 9143 "lib/Sys/Guestfs.xs"
      int r;
#line 23355 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_e2uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_e2uuid(): g is not a blessed HV reference");
    };
#line 9145 "lib/Sys/Guestfs.xs"
      r = guestfs_set_e2uuid (g, device, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23372 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_hv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_hv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	hv = (char *)SvPV_nolen(ST(1));
#line 9154 "lib/Sys/Guestfs.xs"
      int r;
#line 23396 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_hv(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_hv(): g is not a blessed HV reference");
    };
#line 9156 "lib/Sys/Guestfs.xs"
      r = guestfs_set_hv (g, hv);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23413 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_identifier); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_identifier)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, identifier");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	identifier = (char *)SvPV_nolen(ST(1));
#line 9165 "lib/Sys/Guestfs.xs"
      int r;
#line 23437 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_identifier(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_identifier(): g is not a blessed HV reference");
    };
#line 9167 "lib/Sys/Guestfs.xs"
      r = guestfs_set_identifier (g, identifier);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23454 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, mountable, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
#line 9177 "lib/Sys/Guestfs.xs"
      int r;
#line 23479 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_label(): g is not a blessed HV reference");
    };
#line 9179 "lib/Sys/Guestfs.xs"
      r = guestfs_set_label (g, mountable, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23496 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_libvirt_requested_credential); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_libvirt_requested_credential)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, index, cred");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	index = (int)SvIV(ST(1));
	char *	cred = (char *)SvPV_nolen(ST(2));
	size_t	cred_size = SvCUR (ST(2));
#line 9190 "lib/Sys/Guestfs.xs"
      int r;
#line 23522 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_libvirt_requested_credential(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_libvirt_requested_credential(): g is not a blessed HV reference");
    };
#line 9192 "lib/Sys/Guestfs.xs"
      r = guestfs_set_libvirt_requested_credential (g, index, cred, cred_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23539 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_libvirt_supported_credentials); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_libvirt_supported_credentials)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, creds");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char **	creds = XS_unpack_charPtrPtr(ST(1));
#line 9201 "lib/Sys/Guestfs.xs"
      int r;
#line 23563 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_libvirt_supported_credentials(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_libvirt_supported_credentials(): g is not a blessed HV reference");
    };
#line 9203 "lib/Sys/Guestfs.xs"
      r = guestfs_set_libvirt_supported_credentials (g, creds);
      free (creds);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23581 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_memsize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_memsize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, memsize");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	memsize = (int)SvIV(ST(1));
#line 9213 "lib/Sys/Guestfs.xs"
      int r;
#line 23605 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_memsize(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_memsize(): g is not a blessed HV reference");
    };
#line 9215 "lib/Sys/Guestfs.xs"
      r = guestfs_set_memsize (g, memsize);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23622 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_network); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_network)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, network");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	network = (int)SvIV(ST(1));
#line 9224 "lib/Sys/Guestfs.xs"
      int r;
#line 23646 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_network(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_network(): g is not a blessed HV reference");
    };
#line 9226 "lib/Sys/Guestfs.xs"
      r = guestfs_set_network (g, network);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23663 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, searchpath");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	searchpath = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9235 "lib/Sys/Guestfs.xs"
      int r;
#line 23687 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_path(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_path(): g is not a blessed HV reference");
    };
#line 9237 "lib/Sys/Guestfs.xs"
      r = guestfs_set_path (g, searchpath);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23704 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_pgroup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_pgroup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, pgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	pgroup = (int)SvIV(ST(1));
#line 9246 "lib/Sys/Guestfs.xs"
      int r;
#line 23728 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_pgroup(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_pgroup(): g is not a blessed HV reference");
    };
#line 9248 "lib/Sys/Guestfs.xs"
      r = guestfs_set_pgroup (g, pgroup);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23745 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_program); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_program)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, program");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	program = (char *)SvPV_nolen(ST(1));
#line 9257 "lib/Sys/Guestfs.xs"
      int r;
#line 23769 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_program(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_program(): g is not a blessed HV reference");
    };
#line 9259 "lib/Sys/Guestfs.xs"
      r = guestfs_set_program (g, program);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23786 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_qemu); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_qemu)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	hv = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9268 "lib/Sys/Guestfs.xs"
      int r;
#line 23810 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_qemu(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_qemu(): g is not a blessed HV reference");
    };
#line 9270 "lib/Sys/Guestfs.xs"
      r = guestfs_set_qemu (g, hv);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23827 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_recovery_proc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_recovery_proc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, recoveryproc");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	recoveryproc = (int)SvIV(ST(1));
#line 9279 "lib/Sys/Guestfs.xs"
      int r;
#line 23851 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_recovery_proc(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_recovery_proc(): g is not a blessed HV reference");
    };
#line 9281 "lib/Sys/Guestfs.xs"
      r = guestfs_set_recovery_proc (g, recoveryproc);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23868 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_selinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_selinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, selinux");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	selinux = (int)SvIV(ST(1));
#line 9290 "lib/Sys/Guestfs.xs"
      int r;
#line 23892 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_selinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_selinux(): g is not a blessed HV reference");
    };
#line 9292 "lib/Sys/Guestfs.xs"
      r = guestfs_set_selinux (g, selinux);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23909 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_smp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_smp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, smp");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	smp = (int)SvIV(ST(1));
#line 9301 "lib/Sys/Guestfs.xs"
      int r;
#line 23933 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_smp(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_smp(): g is not a blessed HV reference");
    };
#line 9303 "lib/Sys/Guestfs.xs"
      r = guestfs_set_smp (g, smp);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23950 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_tmpdir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_tmpdir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, tmpdir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tmpdir = SvOK(ST(1)) ? SvPV_nolen(ST(1)) : NULL;
#line 9312 "lib/Sys/Guestfs.xs"
      int r;
#line 23974 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_tmpdir(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_tmpdir(): g is not a blessed HV reference");
    };
#line 9314 "lib/Sys/Guestfs.xs"
      r = guestfs_set_tmpdir (g, tmpdir);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 23991 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_trace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_trace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, trace");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	trace = (int)SvIV(ST(1));
#line 9323 "lib/Sys/Guestfs.xs"
      int r;
#line 24015 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_trace(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_trace(): g is not a blessed HV reference");
    };
#line 9325 "lib/Sys/Guestfs.xs"
      r = guestfs_set_trace (g, trace);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24032 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char *	uuid = (char *)SvPV_nolen(ST(2));
#line 9335 "lib/Sys/Guestfs.xs"
      int r;
#line 24057 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_uuid(): g is not a blessed HV reference");
    };
#line 9337 "lib/Sys/Guestfs.xs"
      r = guestfs_set_uuid (g, device, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24074 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_uuid_random); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_uuid_random)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9346 "lib/Sys/Guestfs.xs"
      int r;
#line 24098 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_uuid_random(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_uuid_random(): g is not a blessed HV reference");
    };
#line 9348 "lib/Sys/Guestfs.xs"
      r = guestfs_set_uuid_random (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24115 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_set_verbose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_set_verbose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, verbose");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	verbose = (int)SvIV(ST(1));
#line 9357 "lib/Sys/Guestfs.xs"
      int r;
#line 24139 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::set_verbose(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::set_verbose(): g is not a blessed HV reference");
    };
#line 9359 "lib/Sys/Guestfs.xs"
      r = guestfs_set_verbose (g, verbose);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24156 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_setcon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_setcon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, context");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	context = (char *)SvPV_nolen(ST(1));
#line 9368 "lib/Sys/Guestfs.xs"
      int r;
#line 24180 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::setcon(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::setcon(): g is not a blessed HV reference");
    };
#line 9370 "lib/Sys/Guestfs.xs"
      r = guestfs_setcon (g, context);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24197 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_setxattr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_setxattr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "g, xattr, val, vallen, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	xattr = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
	int	vallen = (int)SvIV(ST(3));
	char *	path = (char *)SvPV_nolen(ST(4));
#line 9382 "lib/Sys/Guestfs.xs"
      int r;
#line 24224 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::setxattr(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::setxattr(): g is not a blessed HV reference");
    };
#line 9384 "lib/Sys/Guestfs.xs"
      r = guestfs_setxattr (g, xattr, val, vallen, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24241 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdisk); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "g, device, cyls, heads, sectors, lines");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	cyls = (int)SvIV(ST(2));
	int	heads = (int)SvIV(ST(3));
	int	sectors = (int)SvIV(ST(4));
	char **	lines = XS_unpack_charPtrPtr(ST(5));
#line 9397 "lib/Sys/Guestfs.xs"
      int r;
#line 24269 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk(): g is not a blessed HV reference");
    };
#line 9399 "lib/Sys/Guestfs.xs"
      r = guestfs_sfdisk (g, device, cyls, heads, sectors, lines);
      free (lines);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24287 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdiskM); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdiskM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, device, lines");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	char **	lines = XS_unpack_charPtrPtr(ST(2));
#line 9410 "lib/Sys/Guestfs.xs"
      int r;
#line 24312 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdiskM(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdiskM(): g is not a blessed HV reference");
    };
#line 9412 "lib/Sys/Guestfs.xs"
      r = guestfs_sfdiskM (g, device, lines);
      free (lines);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24330 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdisk_N); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_N)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "g, device, partnum, cyls, heads, sectors, line");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
	int	partnum = (int)SvIV(ST(2));
	int	cyls = (int)SvIV(ST(3));
	int	heads = (int)SvIV(ST(4));
	int	sectors = (int)SvIV(ST(5));
	char *	line = (char *)SvPV_nolen(ST(6));
#line 9427 "lib/Sys/Guestfs.xs"
      int r;
#line 24359 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_N(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_N(): g is not a blessed HV reference");
    };
#line 9429 "lib/Sys/Guestfs.xs"
      r = guestfs_sfdisk_N (g, device, partnum, cyls, heads, sectors, line);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24376 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sfdisk_disk_geometry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_disk_geometry)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9438 "lib/Sys/Guestfs.xs"
      char *r;
#line 24398 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_disk_geometry(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_disk_geometry(): g is not a blessed HV reference");
    };
#line 9440 "lib/Sys/Guestfs.xs"
      r = guestfs_sfdisk_disk_geometry (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24418 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sfdisk_kernel_geometry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_kernel_geometry)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9453 "lib/Sys/Guestfs.xs"
      char *r;
#line 24441 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_kernel_geometry(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_kernel_geometry(): g is not a blessed HV reference");
    };
#line 9455 "lib/Sys/Guestfs.xs"
      r = guestfs_sfdisk_kernel_geometry (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24461 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sfdisk_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sfdisk_l)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9468 "lib/Sys/Guestfs.xs"
      char *r;
#line 24484 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sfdisk_l(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sfdisk_l(): g is not a blessed HV reference");
    };
#line 9470 "lib/Sys/Guestfs.xs"
      r = guestfs_sfdisk_l (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24504 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, command");
    {
	guestfs_h *	g;
	char *	command = (char *)SvPV_nolen(ST(1));
#line 9483 "lib/Sys/Guestfs.xs"
      char *r;
#line 24527 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sh(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sh(): g is not a blessed HV reference");
    };
#line 9485 "lib/Sys/Guestfs.xs"
      r = guestfs_sh (g, command);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 24547 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_sh_lines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sh_lines)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, command");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	command = (char *)SvPV_nolen(ST(1));
#line 9498 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 24573 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sh_lines(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sh_lines(): g is not a blessed HV reference");
    };
#line 9501 "lib/Sys/Guestfs.xs"
      r = guestfs_sh_lines (g, command);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 24597 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 9516 "lib/Sys/Guestfs.xs"
      int r;
#line 24620 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::shutdown(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::shutdown(): g is not a blessed HV reference");
    };
#line 9518 "lib/Sys/Guestfs.xs"
      r = guestfs_shutdown (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24637 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sleep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sleep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, secs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	secs = (int)SvIV(ST(1));
#line 9527 "lib/Sys/Guestfs.xs"
      int r;
#line 24661 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sleep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sleep(): g is not a blessed HV reference");
    };
#line 9529 "lib/Sys/Guestfs.xs"
      r = guestfs_sleep (g, secs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 24678 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_stat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_stat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9538 "lib/Sys/Guestfs.xs"
      struct guestfs_stat *r;
#line 24702 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::stat(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::stat(): g is not a blessed HV reference");
    };
#line 9540 "lib/Sys/Guestfs.xs"
      r = guestfs_stat (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 13);
      PUSHs (sv_2mortal (newSVpv ("dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->dev)));
      PUSHs (sv_2mortal (newSVpv ("ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ino)));
      PUSHs (sv_2mortal (newSVpv ("mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mode)));
      PUSHs (sv_2mortal (newSVpv ("nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->nlink)));
      PUSHs (sv_2mortal (newSVpv ("uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->uid)));
      PUSHs (sv_2mortal (newSVpv ("gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->gid)));
      PUSHs (sv_2mortal (newSVpv ("rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->rdev)));
      PUSHs (sv_2mortal (newSVpv ("size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->size)));
      PUSHs (sv_2mortal (newSVpv ("blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blksize)));
      PUSHs (sv_2mortal (newSVpv ("blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blocks)));
      PUSHs (sv_2mortal (newSVpv ("atime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->atime)));
      PUSHs (sv_2mortal (newSVpv ("mtime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->mtime)));
      PUSHs (sv_2mortal (newSVpv ("ctime", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ctime)));
      free (r);
#line 24747 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_statns); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_statns)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9577 "lib/Sys/Guestfs.xs"
      struct guestfs_statns *r;
#line 24771 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::statns(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::statns(): g is not a blessed HV reference");
    };
#line 9579 "lib/Sys/Guestfs.xs"
      r = guestfs_statns (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 22);
      PUSHs (sv_2mortal (newSVpv ("st_dev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_dev)));
      PUSHs (sv_2mortal (newSVpv ("st_ino", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ino)));
      PUSHs (sv_2mortal (newSVpv ("st_mode", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mode)));
      PUSHs (sv_2mortal (newSVpv ("st_nlink", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_nlink)));
      PUSHs (sv_2mortal (newSVpv ("st_uid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_uid)));
      PUSHs (sv_2mortal (newSVpv ("st_gid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_gid)));
      PUSHs (sv_2mortal (newSVpv ("st_rdev", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_rdev)));
      PUSHs (sv_2mortal (newSVpv ("st_size", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_size)));
      PUSHs (sv_2mortal (newSVpv ("st_blksize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blksize)));
      PUSHs (sv_2mortal (newSVpv ("st_blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_blocks)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_atime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_atime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_mtime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_mtime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_sec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_sec)));
      PUSHs (sv_2mortal (newSVpv ("st_ctime_nsec", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_ctime_nsec)));
      PUSHs (sv_2mortal (newSVpv ("st_spare1", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare1)));
      PUSHs (sv_2mortal (newSVpv ("st_spare2", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare2)));
      PUSHs (sv_2mortal (newSVpv ("st_spare3", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare3)));
      PUSHs (sv_2mortal (newSVpv ("st_spare4", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare4)));
      PUSHs (sv_2mortal (newSVpv ("st_spare5", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare5)));
      PUSHs (sv_2mortal (newSVpv ("st_spare6", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->st_spare6)));
      free (r);
#line 24834 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_statvfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_statvfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9634 "lib/Sys/Guestfs.xs"
      struct guestfs_statvfs *r;
#line 24858 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::statvfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::statvfs(): g is not a blessed HV reference");
    };
#line 9636 "lib/Sys/Guestfs.xs"
      r = guestfs_statvfs (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 11);
      PUSHs (sv_2mortal (newSVpv ("bsize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->bsize)));
      PUSHs (sv_2mortal (newSVpv ("frsize", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->frsize)));
      PUSHs (sv_2mortal (newSVpv ("blocks", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->blocks)));
      PUSHs (sv_2mortal (newSVpv ("bfree", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->bfree)));
      PUSHs (sv_2mortal (newSVpv ("bavail", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->bavail)));
      PUSHs (sv_2mortal (newSVpv ("files", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->files)));
      PUSHs (sv_2mortal (newSVpv ("ffree", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->ffree)));
      PUSHs (sv_2mortal (newSVpv ("favail", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->favail)));
      PUSHs (sv_2mortal (newSVpv ("fsid", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->fsid)));
      PUSHs (sv_2mortal (newSVpv ("flag", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->flag)));
      PUSHs (sv_2mortal (newSVpv ("namemax", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->namemax)));
      free (r);
#line 24899 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_strings); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_strings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9669 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 24924 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::strings(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::strings(): g is not a blessed HV reference");
    };
#line 9672 "lib/Sys/Guestfs.xs"
      r = guestfs_strings (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 24948 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_strings_e); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_strings_e)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, encoding, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	encoding = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 9689 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 24974 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::strings_e(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::strings_e(): g is not a blessed HV reference");
    };
#line 9692 "lib/Sys/Guestfs.xs"
      r = guestfs_strings_e (g, encoding, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 24998 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9708 "lib/Sys/Guestfs.xs"
      int r;
#line 25022 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_device(): g is not a blessed HV reference");
    };
#line 9710 "lib/Sys/Guestfs.xs"
      r = guestfs_swapoff_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25039 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 9719 "lib/Sys/Guestfs.xs"
      int r;
#line 25063 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_file(): g is not a blessed HV reference");
    };
#line 9721 "lib/Sys/Guestfs.xs"
      r = guestfs_swapoff_file (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25080 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 9730 "lib/Sys/Guestfs.xs"
      int r;
#line 25104 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_label(): g is not a blessed HV reference");
    };
#line 9732 "lib/Sys/Guestfs.xs"
      r = guestfs_swapoff_label (g, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25121 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapoff_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapoff_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
#line 9741 "lib/Sys/Guestfs.xs"
      int r;
#line 25145 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapoff_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapoff_uuid(): g is not a blessed HV reference");
    };
#line 9743 "lib/Sys/Guestfs.xs"
      r = guestfs_swapoff_uuid (g, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25162 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9752 "lib/Sys/Guestfs.xs"
      int r;
#line 25186 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_device(): g is not a blessed HV reference");
    };
#line 9754 "lib/Sys/Guestfs.xs"
      r = guestfs_swapon_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25203 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	file = (char *)SvPV_nolen(ST(1));
#line 9763 "lib/Sys/Guestfs.xs"
      int r;
#line 25227 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_file(): g is not a blessed HV reference");
    };
#line 9765 "lib/Sys/Guestfs.xs"
      r = guestfs_swapon_file (g, file);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25244 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, label");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	label = (char *)SvPV_nolen(ST(1));
#line 9774 "lib/Sys/Guestfs.xs"
      int r;
#line 25268 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_label(): g is not a blessed HV reference");
    };
#line 9776 "lib/Sys/Guestfs.xs"
      r = guestfs_swapon_label (g, label);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25285 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_swapon_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_swapon_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, uuid");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	uuid = (char *)SvPV_nolen(ST(1));
#line 9785 "lib/Sys/Guestfs.xs"
      int r;
#line 25309 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::swapon_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::swapon_uuid(): g is not a blessed HV reference");
    };
#line 9787 "lib/Sys/Guestfs.xs"
      r = guestfs_swapon_uuid (g, uuid);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25326 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_sync); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_sync)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 9795 "lib/Sys/Guestfs.xs"
      int r;
#line 25349 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::sync(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::sync(): g is not a blessed HV reference");
    };
#line 9797 "lib/Sys/Guestfs.xs"
      r = guestfs_sync (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25366 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_syslinux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_syslinux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 9806 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_syslinux_argv optargs_s = { .bitmask = 0 };
      struct guestfs_syslinux_argv *optargs = &optargs_s;
      size_t items_i;
#line 25393 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::syslinux(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::syslinux(): g is not a blessed HV reference");
    };
#line 9811 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "directory")) {
          optargs_s.directory = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_SYSLINUX_DIRECTORY_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_syslinux_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25428 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tail); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 9838 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 25453 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tail(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tail(): g is not a blessed HV reference");
    };
#line 9841 "lib/Sys/Guestfs.xs"
      r = guestfs_tail (g, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 25477 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tail_n); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tail_n)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, nrlines, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	nrlines = (int)SvIV(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 9858 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 25503 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tail_n(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tail_n(): g is not a blessed HV reference");
    };
#line 9861 "lib/Sys/Guestfs.xs"
      r = guestfs_tail_n (g, nrlines, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 25527 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tar_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tar_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, tarfile, directory, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tarfile = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
#line 9878 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_tar_in_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_tar_in_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 25555 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tar_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tar_in(): g is not a blessed HV reference");
    };
#line 9883 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "compress")) {
          optargs_s.compress = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TAR_IN_OPTS_COMPRESS_BITMASK;
        }
        else if (STREQ (this_arg, "xattrs")) {
          optargs_s.xattrs = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_IN_OPTS_XATTRS_BITMASK;
        }
        else if (STREQ (this_arg, "selinux")) {
          optargs_s.selinux = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_IN_OPTS_SELINUX_BITMASK;
        }
        else if (STREQ (this_arg, "acls")) {
          optargs_s.acls = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_IN_OPTS_ACLS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_tar_in_opts_argv (g, tarfile, directory, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25602 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tar_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tar_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "g, directory, tarfile, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	tarfile = (char *)SvPV_nolen(ST(2));
#line 9923 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_tar_out_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_tar_out_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 25630 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tar_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tar_out(): g is not a blessed HV reference");
    };
#line 9928 "lib/Sys/Guestfs.xs"
      if (((items - 3) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 3; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "compress")) {
          optargs_s.compress = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_COMPRESS_BITMASK;
        }
        else if (STREQ (this_arg, "numericowner")) {
          optargs_s.numericowner = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_NUMERICOWNER_BITMASK;
        }
        else if (STREQ (this_arg, "excludes")) {
          size_t i, len;
          char **r;
          SV *arg;
          AV *av;
          SV **svp;

          arg = ST (items_i+1);
          if (!SvROK (arg) || SvTYPE (SvRV (arg)) != SVt_PVAV)
            croak ("array reference expected for '%s' argument", "excludes");
          av = (AV *) SvRV (ST (items_i+1));

          /* Note av_len returns index of final element. */
          len = av_len (av) + 1;

          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));
          for (i = 0; i < len; ++i) {
            svp = av_fetch (av, i, 0);
            r[i] = SvPV_nolen (*svp);
          }
          r[i] = NULL;
          optargs_s.excludes = r;
          this_mask = GUESTFS_TAR_OUT_OPTS_EXCLUDES_BITMASK;
        }
        else if (STREQ (this_arg, "xattrs")) {
          optargs_s.xattrs = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_XATTRS_BITMASK;
        }
        else if (STREQ (this_arg, "selinux")) {
          optargs_s.selinux = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_SELINUX_BITMASK;
        }
        else if (STREQ (this_arg, "acls")) {
          optargs_s.acls = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TAR_OUT_OPTS_ACLS_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_tar_out_opts_argv (g, directory, tarfile, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25705 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tgz_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tgz_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, tarball, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tarball = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
#line 9996 "lib/Sys/Guestfs.xs"
      int r;
#line 25730 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tgz_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tgz_in(): g is not a blessed HV reference");
    };
#line 9998 "lib/Sys/Guestfs.xs"
      r = guestfs_tgz_in (g, tarball, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25747 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tgz_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tgz_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, directory, tarball");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	tarball = (char *)SvPV_nolen(ST(2));
#line 10008 "lib/Sys/Guestfs.xs"
      int r;
#line 25772 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tgz_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tgz_out(): g is not a blessed HV reference");
    };
#line 10010 "lib/Sys/Guestfs.xs"
      r = guestfs_tgz_out (g, directory, tarball);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25789 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_touch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_touch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10019 "lib/Sys/Guestfs.xs"
      int r;
#line 25813 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::touch(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::touch(): g is not a blessed HV reference");
    };
#line 10021 "lib/Sys/Guestfs.xs"
      r = guestfs_touch (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25830 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_truncate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_truncate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10030 "lib/Sys/Guestfs.xs"
      int r;
#line 25854 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::truncate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::truncate(): g is not a blessed HV reference");
    };
#line 10032 "lib/Sys/Guestfs.xs"
      r = guestfs_truncate (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25871 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_truncate_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_truncate_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int64_t    size = my_SvIV64 (ST(2));
#line 10042 "lib/Sys/Guestfs.xs"
      int r;
#line 25896 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::truncate_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::truncate_size(): g is not a blessed HV reference");
    };
#line 10044 "lib/Sys/Guestfs.xs"
      r = guestfs_truncate_size (g, path, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 25913 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tune2fs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tune2fs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10053 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_tune2fs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_tune2fs_argv *optargs = &optargs_s;
      size_t items_i;
#line 25940 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tune2fs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tune2fs(): g is not a blessed HV reference");
    };
#line 10058 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_FORCE_BITMASK;
        }
        else if (STREQ (this_arg, "maxmountcount")) {
          optargs_s.maxmountcount = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_MAXMOUNTCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "mountcount")) {
          optargs_s.mountcount = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_MOUNTCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "errorbehavior")) {
          optargs_s.errorbehavior = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_ERRORBEHAVIOR_BITMASK;
        }
        else if (STREQ (this_arg, "group")) {
          optargs_s.group = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_GROUP_BITMASK;
        }
        else if (STREQ (this_arg, "intervalbetweenchecks")) {
          optargs_s.intervalbetweenchecks = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS_BITMASK;
        }
        else if (STREQ (this_arg, "reservedblockspercentage")) {
          optargs_s.reservedblockspercentage = SvIV (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE_BITMASK;
        }
        else if (STREQ (this_arg, "lastmounteddirectory")) {
          optargs_s.lastmounteddirectory = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY_BITMASK;
        }
        else if (STREQ (this_arg, "reservedblockscount")) {
          optargs_s.reservedblockscount = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT_BITMASK;
        }
        else if (STREQ (this_arg, "user")) {
          optargs_s.user = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_TUNE2FS_USER_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_tune2fs_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26011 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_tune2fs_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_tune2fs_l)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10121 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 26036 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::tune2fs_l(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::tune2fs_l(): g is not a blessed HV reference");
    };
#line 10124 "lib/Sys/Guestfs.xs"
      r = guestfs_tune2fs_l (g, device);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 26060 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_txz_in); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_txz_in)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, tarball, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	tarball = (char *)SvPV_nolen(ST(1));
	char *	directory = (char *)SvPV_nolen(ST(2));
#line 10141 "lib/Sys/Guestfs.xs"
      int r;
#line 26085 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::txz_in(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::txz_in(): g is not a blessed HV reference");
    };
#line 10143 "lib/Sys/Guestfs.xs"
      r = guestfs_txz_in (g, tarball, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26102 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_txz_out); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_txz_out)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, directory, tarball");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
	char *	tarball = (char *)SvPV_nolen(ST(2));
#line 10153 "lib/Sys/Guestfs.xs"
      int r;
#line 26127 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::txz_out(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::txz_out(): g is not a blessed HV reference");
    };
#line 10155 "lib/Sys/Guestfs.xs"
      r = guestfs_txz_out (g, directory, tarball);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26144 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_umask); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umask)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mask");
    {
	guestfs_h *	g;
	int	mask = (int)SvIV(ST(1));
#line 10164 "lib/Sys/Guestfs.xs"
      int r;
#line 26166 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umask(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umask(): g is not a blessed HV reference");
    };
#line 10166 "lib/Sys/Guestfs.xs"
      r = guestfs_umask (g, mask);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 26185 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_umount); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, pathordevice, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pathordevice = (char *)SvPV_nolen(ST(1));
#line 10178 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_umount_opts_argv optargs_s = { .bitmask = 0 };
      struct guestfs_umount_opts_argv *optargs = &optargs_s;
      size_t items_i;
#line 26213 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umount(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umount(): g is not a blessed HV reference");
    };
#line 10183 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "force")) {
          optargs_s.force = SvIV (ST (items_i+1));
          this_mask = GUESTFS_UMOUNT_OPTS_FORCE_BITMASK;
        }
        else if (STREQ (this_arg, "lazyunmount")) {
          optargs_s.lazyunmount = SvIV (ST (items_i+1));
          this_mask = GUESTFS_UMOUNT_OPTS_LAZYUNMOUNT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_umount_opts_argv (g, pathordevice, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26252 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_umount_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umount_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10213 "lib/Sys/Guestfs.xs"
      int r;
#line 26275 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umount_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umount_all(): g is not a blessed HV reference");
    };
#line 10215 "lib/Sys/Guestfs.xs"
      r = guestfs_umount_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26292 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_umount_local); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_umount_local)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "g, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10223 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_umount_local_argv optargs_s = { .bitmask = 0 };
      struct guestfs_umount_local_argv *optargs = &optargs_s;
      size_t items_i;
#line 26318 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::umount_local(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::umount_local(): g is not a blessed HV reference");
    };
#line 10228 "lib/Sys/Guestfs.xs"
      if (((items - 1) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 1; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "retry")) {
          optargs_s.retry = SvIV (ST (items_i+1));
          this_mask = GUESTFS_UMOUNT_LOCAL_RETRY_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_umount_local_argv (g, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26353 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_upload); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_upload)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, filename, remotefilename");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	remotefilename = (char *)SvPV_nolen(ST(2));
#line 10256 "lib/Sys/Guestfs.xs"
      int r;
#line 26378 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::upload(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::upload(): g is not a blessed HV reference");
    };
#line 10258 "lib/Sys/Guestfs.xs"
      r = guestfs_upload (g, filename, remotefilename);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26395 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_upload_offset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_upload_offset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, filename, remotefilename, offset");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	remotefilename = (char *)SvPV_nolen(ST(2));
	int64_t    offset = my_SvIV64 (ST(3));
#line 10269 "lib/Sys/Guestfs.xs"
      int r;
#line 26421 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::upload_offset(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::upload_offset(): g is not a blessed HV reference");
    };
#line 10271 "lib/Sys/Guestfs.xs"
      r = guestfs_upload_offset (g, filename, remotefilename, offset);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26438 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_user_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_user_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10279 "lib/Sys/Guestfs.xs"
      int r;
#line 26461 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::user_cancel(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::user_cancel(): g is not a blessed HV reference");
    };
#line 10281 "lib/Sys/Guestfs.xs"
      r = guestfs_user_cancel (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26478 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_utimens); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_utimens)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "g, path, atsecs, atnsecs, mtsecs, mtnsecs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	int64_t    atsecs = my_SvIV64 (ST(2));
	int64_t    atnsecs = my_SvIV64 (ST(3));
	int64_t    mtsecs = my_SvIV64 (ST(4));
	int64_t    mtnsecs = my_SvIV64 (ST(5));
#line 10294 "lib/Sys/Guestfs.xs"
      int r;
#line 26506 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::utimens(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::utimens(): g is not a blessed HV reference");
    };
#line 10296 "lib/Sys/Guestfs.xs"
      r = guestfs_utimens (g, path, atsecs, atnsecs, mtsecs, mtnsecs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26523 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_utsname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_utsname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10304 "lib/Sys/Guestfs.xs"
      struct guestfs_utsname *r;
#line 26546 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::utsname(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::utsname(): g is not a blessed HV reference");
    };
#line 10306 "lib/Sys/Guestfs.xs"
      r = guestfs_utsname (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 4);
      PUSHs (sv_2mortal (newSVpv ("uts_sysname", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_sysname, 0)));
      PUSHs (sv_2mortal (newSVpv ("uts_release", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_release, 0)));
      PUSHs (sv_2mortal (newSVpv ("uts_version", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_version, 0)));
      PUSHs (sv_2mortal (newSVpv ("uts_machine", 0)));
      PUSHs (sv_2mortal (newSVpv (r->uts_machine, 0)));
      free (r);
#line 26573 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10324 "lib/Sys/Guestfs.xs"
      struct guestfs_version *r;
#line 26596 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::version(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::version(): g is not a blessed HV reference");
    };
#line 10326 "lib/Sys/Guestfs.xs"
      r = guestfs_version (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 4);
      PUSHs (sv_2mortal (newSVpv ("major", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->major)));
      PUSHs (sv_2mortal (newSVpv ("minor", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->minor)));
      PUSHs (sv_2mortal (newSVpv ("release", 0)));
      PUSHs (sv_2mortal (my_newSVll (r->release)));
      PUSHs (sv_2mortal (newSVpv ("extra", 0)));
      PUSHs (sv_2mortal (newSVpv (r->extra, 0)));
      free (r);
#line 26623 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vfs_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10345 "lib/Sys/Guestfs.xs"
      char *r;
#line 26645 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_label(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_label(): g is not a blessed HV reference");
    };
#line 10347 "lib/Sys/Guestfs.xs"
      r = guestfs_vfs_label (g, mountable);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 26665 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vfs_minimum_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_minimum_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10360 "lib/Sys/Guestfs.xs"
      int64_t r;
#line 26688 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_minimum_size(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_minimum_size(): g is not a blessed HV reference");
    };
#line 10362 "lib/Sys/Guestfs.xs"
      r = guestfs_vfs_minimum_size (g, mountable);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = my_newSVll (r);
#line 26707 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vfs_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10374 "lib/Sys/Guestfs.xs"
      char *r;
#line 26730 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_type(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_type(): g is not a blessed HV reference");
    };
#line 10376 "lib/Sys/Guestfs.xs"
      r = guestfs_vfs_type (g, mountable);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 26750 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vfs_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vfs_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, mountable");
    {
	guestfs_h *	g;
	char *	mountable = (char *)SvPV_nolen(ST(1));
#line 10389 "lib/Sys/Guestfs.xs"
      char *r;
#line 26773 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vfs_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vfs_uuid(): g is not a blessed HV reference");
    };
#line 10391 "lib/Sys/Guestfs.xs"
      r = guestfs_vfs_uuid (g, mountable);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 26793 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vg_activate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vg_activate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, activate, volgroups");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	activate = (int)SvIV(ST(1));
	char **	volgroups = XS_unpack_charPtrPtr(ST(2));
#line 10405 "lib/Sys/Guestfs.xs"
      int r;
#line 26819 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vg_activate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vg_activate(): g is not a blessed HV reference");
    };
#line 10407 "lib/Sys/Guestfs.xs"
      r = guestfs_vg_activate (g, activate, volgroups);
      free (volgroups);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26837 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vg_activate_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vg_activate_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, activate");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	int	activate = (int)SvIV(ST(1));
#line 10417 "lib/Sys/Guestfs.xs"
      int r;
#line 26861 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vg_activate_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vg_activate_all(): g is not a blessed HV reference");
    };
#line 10419 "lib/Sys/Guestfs.xs"
      r = guestfs_vg_activate_all (g, activate);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26878 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgchange_uuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgchange_uuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vg");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vg = (char *)SvPV_nolen(ST(1));
#line 10428 "lib/Sys/Guestfs.xs"
      int r;
#line 26902 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgchange_uuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgchange_uuid(): g is not a blessed HV reference");
    };
#line 10430 "lib/Sys/Guestfs.xs"
      r = guestfs_vgchange_uuid (g, vg);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26919 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgchange_uuid_all); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgchange_uuid_all)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10438 "lib/Sys/Guestfs.xs"
      int r;
#line 26942 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgchange_uuid_all(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgchange_uuid_all(): g is not a blessed HV reference");
    };
#line 10440 "lib/Sys/Guestfs.xs"
      r = guestfs_vgchange_uuid_all (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 26959 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgcreate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgcreate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, volgroup, physvols");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	volgroup = (char *)SvPV_nolen(ST(1));
	char **	physvols = XS_unpack_charPtrPtr(ST(2));
#line 10450 "lib/Sys/Guestfs.xs"
      int r;
#line 26984 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgcreate(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgcreate(): g is not a blessed HV reference");
    };
#line 10452 "lib/Sys/Guestfs.xs"
      r = guestfs_vgcreate (g, volgroup, physvols);
      free (physvols);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27002 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vglvuuids); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vglvuuids)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10462 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 27027 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vglvuuids(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vglvuuids(): g is not a blessed HV reference");
    };
#line 10465 "lib/Sys/Guestfs.xs"
      r = guestfs_vglvuuids (g, vgname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 27051 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgmeta); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgmeta)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10481 "lib/Sys/Guestfs.xs"
      char *r;
      size_t size;
#line 27074 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgmeta(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgmeta(): g is not a blessed HV reference");
    };
#line 10484 "lib/Sys/Guestfs.xs"
      r = guestfs_vgmeta (g, vgname, &size);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpvn (r, size);
      free (r);
#line 27094 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_vgpvuuids); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgpvuuids)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10497 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 27120 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgpvuuids(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgpvuuids(): g is not a blessed HV reference");
    };
#line 10500 "lib/Sys/Guestfs.xs"
      r = guestfs_vgpvuuids (g, vgname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 27144 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgremove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgremove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10516 "lib/Sys/Guestfs.xs"
      int r;
#line 27168 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgremove(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgremove(): g is not a blessed HV reference");
    };
#line 10518 "lib/Sys/Guestfs.xs"
      r = guestfs_vgremove (g, vgname);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27185 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgrename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgrename)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, volgroup, newvolgroup");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	volgroup = (char *)SvPV_nolen(ST(1));
	char *	newvolgroup = (char *)SvPV_nolen(ST(2));
#line 10528 "lib/Sys/Guestfs.xs"
      int r;
#line 27210 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgrename(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgrename(): g is not a blessed HV reference");
    };
#line 10530 "lib/Sys/Guestfs.xs"
      r = guestfs_vgrename (g, volgroup, newvolgroup);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27227 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10538 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 27251 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgs(): g is not a blessed HV reference");
    };
#line 10541 "lib/Sys/Guestfs.xs"
      r = guestfs_vgs (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 27275 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgs_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgs_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10556 "lib/Sys/Guestfs.xs"
      struct guestfs_lvm_vg_list *r;
      size_t i;
      HV *hv;
#line 27300 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgs_full(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgs_full(): g is not a blessed HV reference");
    };
#line 10560 "lib/Sys/Guestfs.xs"
      r = guestfs_vgs_full (g);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, r->len);
      for (i = 0; i < r->len; ++i) {
        hv = newHV ();
        (void) hv_store (hv, "vg_name", 7, newSVpv (r->val[i].vg_name, 0), 0);
        (void) hv_store (hv, "vg_uuid", 7, newSVpv (r->val[i].vg_uuid, 32), 0);
        (void) hv_store (hv, "vg_fmt", 6, newSVpv (r->val[i].vg_fmt, 0), 0);
        (void) hv_store (hv, "vg_attr", 7, newSVpv (r->val[i].vg_attr, 0), 0);
        (void) hv_store (hv, "vg_size", 7, my_newSVull (r->val[i].vg_size), 0);
        (void) hv_store (hv, "vg_free", 7, my_newSVull (r->val[i].vg_free), 0);
        (void) hv_store (hv, "vg_sysid", 8, newSVpv (r->val[i].vg_sysid, 0), 0);
        (void) hv_store (hv, "vg_extent_size", 14, my_newSVull (r->val[i].vg_extent_size), 0);
        (void) hv_store (hv, "vg_extent_count", 15, my_newSVll (r->val[i].vg_extent_count), 0);
        (void) hv_store (hv, "vg_free_count", 13, my_newSVll (r->val[i].vg_free_count), 0);
        (void) hv_store (hv, "max_lv", 6, my_newSVll (r->val[i].max_lv), 0);
        (void) hv_store (hv, "max_pv", 6, my_newSVll (r->val[i].max_pv), 0);
        (void) hv_store (hv, "pv_count", 8, my_newSVll (r->val[i].pv_count), 0);
        (void) hv_store (hv, "lv_count", 8, my_newSVll (r->val[i].lv_count), 0);
        (void) hv_store (hv, "snap_count", 10, my_newSVll (r->val[i].snap_count), 0);
        (void) hv_store (hv, "vg_seqno", 8, my_newSVll (r->val[i].vg_seqno), 0);
        (void) hv_store (hv, "vg_tags", 7, newSVpv (r->val[i].vg_tags, 0), 0);
        (void) hv_store (hv, "vg_mda_count", 12, my_newSVll (r->val[i].vg_mda_count), 0);
        (void) hv_store (hv, "vg_mda_free", 11, my_newSVull (r->val[i].vg_mda_free), 0);
        PUSHs (sv_2mortal (newRV ((SV *) hv)));
      }
      guestfs_free_lvm_vg_list (r);
#line 27342 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vgscan); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vgscan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10593 "lib/Sys/Guestfs.xs"
      int r;
#line 27365 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vgscan(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vgscan(): g is not a blessed HV reference");
    };
#line 10595 "lib/Sys/Guestfs.xs"
      r = guestfs_vgscan (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27382 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_vguuid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_vguuid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, vgname");
    {
	guestfs_h *	g;
	char *	vgname = (char *)SvPV_nolen(ST(1));
#line 10604 "lib/Sys/Guestfs.xs"
      char *r;
#line 27404 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::vguuid(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::vguuid(): g is not a blessed HV reference");
    };
#line 10606 "lib/Sys/Guestfs.xs"
      r = guestfs_vguuid (g, vgname);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 27424 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wait_ready); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wait_ready)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
#line 10618 "lib/Sys/Guestfs.xs"
      int r;
#line 27448 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wait_ready(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wait_ready(): g is not a blessed HV reference");
    };
#line 10620 "lib/Sys/Guestfs.xs"
      r = guestfs_wait_ready (g);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27465 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_wc_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wc_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10629 "lib/Sys/Guestfs.xs"
      int r;
#line 27487 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wc_c(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wc_c(): g is not a blessed HV reference");
    };
#line 10631 "lib/Sys/Guestfs.xs"
      r = guestfs_wc_c (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27506 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wc_l); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wc_l)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10643 "lib/Sys/Guestfs.xs"
      int r;
#line 27529 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wc_l(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wc_l(): g is not a blessed HV reference");
    };
#line 10645 "lib/Sys/Guestfs.xs"
      r = guestfs_wc_l (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27548 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wc_w); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wc_w)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, path");
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10657 "lib/Sys/Guestfs.xs"
      int r;
#line 27571 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wc_w(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wc_w(): g is not a blessed HV reference");
    };
#line 10659 "lib/Sys/Guestfs.xs"
      r = guestfs_wc_w (g, path);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 27590 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_wipefs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_wipefs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10671 "lib/Sys/Guestfs.xs"
      int r;
#line 27615 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::wipefs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::wipefs(): g is not a blessed HV reference");
    };
#line 10673 "lib/Sys/Guestfs.xs"
      r = guestfs_wipefs (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27632 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, content");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
#line 10684 "lib/Sys/Guestfs.xs"
      int r;
#line 27658 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::write(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::write(): g is not a blessed HV reference");
    };
#line 10686 "lib/Sys/Guestfs.xs"
      r = guestfs_write (g, path, content, content_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27675 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_write_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_write_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, path, content");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	size_t	content_size = SvCUR (ST(2));
#line 10697 "lib/Sys/Guestfs.xs"
      int r;
#line 27701 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::write_append(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::write_append(): g is not a blessed HV reference");
    };
#line 10699 "lib/Sys/Guestfs.xs"
      r = guestfs_write_append (g, path, content, content_size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27718 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_write_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_write_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "g, path, content, size");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
	char *	content = (char *)SvPV_nolen(ST(2));
	int	size = (int)SvIV(ST(3));
#line 10710 "lib/Sys/Guestfs.xs"
      int r;
#line 27744 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::write_file(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::write_file(): g is not a blessed HV reference");
    };
#line 10712 "lib/Sys/Guestfs.xs"
      r = guestfs_write_file (g, path, content, size);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27761 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_admin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_admin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10721 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_xfs_admin_argv optargs_s = { .bitmask = 0 };
      struct guestfs_xfs_admin_argv *optargs = &optargs_s;
      size_t items_i;
#line 27788 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_admin(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_admin(): g is not a blessed HV reference");
    };
#line 10726 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "extunwritten")) {
          optargs_s.extunwritten = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_EXTUNWRITTEN_BITMASK;
        }
        else if (STREQ (this_arg, "imgfile")) {
          optargs_s.imgfile = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_IMGFILE_BITMASK;
        }
        else if (STREQ (this_arg, "v2log")) {
          optargs_s.v2log = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_V2LOG_BITMASK;
        }
        else if (STREQ (this_arg, "projid32bit")) {
          optargs_s.projid32bit = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_PROJID32BIT_BITMASK;
        }
        else if (STREQ (this_arg, "lazycounter")) {
          optargs_s.lazycounter = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_LAZYCOUNTER_BITMASK;
        }
        else if (STREQ (this_arg, "label")) {
          optargs_s.label = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_LABEL_BITMASK;
        }
        else if (STREQ (this_arg, "uuid")) {
          optargs_s.uuid = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_ADMIN_UUID_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_xfs_admin_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27847 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_growfs); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_growfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, path, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	path = (char *)SvPV_nolen(ST(1));
#line 10777 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_xfs_growfs_argv optargs_s = { .bitmask = 0 };
      struct guestfs_xfs_growfs_argv *optargs = &optargs_s;
      size_t items_i;
#line 27874 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_growfs(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_growfs(): g is not a blessed HV reference");
    };
#line 10782 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "datasec")) {
          optargs_s.datasec = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_DATASEC_BITMASK;
        }
        else if (STREQ (this_arg, "logsec")) {
          optargs_s.logsec = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_LOGSEC_BITMASK;
        }
        else if (STREQ (this_arg, "rtsec")) {
          optargs_s.rtsec = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_RTSEC_BITMASK;
        }
        else if (STREQ (this_arg, "datasize")) {
          optargs_s.datasize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_DATASIZE_BITMASK;
        }
        else if (STREQ (this_arg, "logsize")) {
          optargs_s.logsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_LOGSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "rtsize")) {
          optargs_s.rtsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_RTSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "rtextsize")) {
          optargs_s.rtextsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_RTEXTSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "maxpct")) {
          optargs_s.maxpct = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_GROWFS_MAXPCT_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_xfs_growfs_argv (g, path, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 27937 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, pathordevice");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pathordevice = (char *)SvPV_nolen(ST(1));
#line 10837 "lib/Sys/Guestfs.xs"
      struct guestfs_xfsinfo *r;
#line 27961 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_info(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_info(): g is not a blessed HV reference");
    };
#line 10839 "lib/Sys/Guestfs.xs"
      r = guestfs_xfs_info (g, pathordevice);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      EXTEND (SP, 2 * 25);
      PUSHs (sv_2mortal (newSVpv ("xfs_mntpoint", 0)));
      PUSHs (sv_2mortal (newSVpv (r->xfs_mntpoint, 0)));
      PUSHs (sv_2mortal (newSVpv ("xfs_inodesize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_inodesize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_agcount", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_agcount)));
      PUSHs (sv_2mortal (newSVpv ("xfs_agsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_agsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_sectsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_sectsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_attr", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_attr)));
      PUSHs (sv_2mortal (newSVpv ("xfs_blocksize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_blocksize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_datablocks", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->xfs_datablocks)));
      PUSHs (sv_2mortal (newSVpv ("xfs_imaxpct", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_imaxpct)));
      PUSHs (sv_2mortal (newSVpv ("xfs_sunit", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_sunit)));
      PUSHs (sv_2mortal (newSVpv ("xfs_swidth", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_swidth)));
      PUSHs (sv_2mortal (newSVpv ("xfs_dirversion", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_dirversion)));
      PUSHs (sv_2mortal (newSVpv ("xfs_dirblocksize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_dirblocksize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_cimode", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_cimode)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logname", 0)));
      PUSHs (sv_2mortal (newSVpv (r->xfs_logname, 0)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logblocksize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logblocksize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logblocks", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logblocks)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logversion", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logversion)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logsectsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logsectsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_logsunit", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_logsunit)));
      PUSHs (sv_2mortal (newSVpv ("xfs_lazycount", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_lazycount)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtname", 0)));
      PUSHs (sv_2mortal (newSVpv (r->xfs_rtname, 0)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtextsize", 0)));
      PUSHs (sv_2mortal (newSVnv (r->xfs_rtextsize)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtblocks", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->xfs_rtblocks)));
      PUSHs (sv_2mortal (newSVpv ("xfs_rtextents", 0)));
      PUSHs (sv_2mortal (my_newSVull (r->xfs_rtextents)));
      free (r);
#line 28030 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_xfs_repair); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_xfs_repair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "g, device, ...");
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 10900 "lib/Sys/Guestfs.xs"
      int r;
      struct guestfs_xfs_repair_argv optargs_s = { .bitmask = 0 };
      struct guestfs_xfs_repair_argv *optargs = &optargs_s;
      size_t items_i;
#line 28055 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::xfs_repair(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::xfs_repair(): g is not a blessed HV reference");
    };
#line 10905 "lib/Sys/Guestfs.xs"
      if (((items - 2) & 1) != 0)
        croak ("expecting an even number of extra parameters");
      for (items_i = 2; items_i < items; items_i += 2) {
        uint64_t this_mask;
        const char *this_arg;

        this_arg = SvPV_nolen (ST (items_i));
        if (STREQ (this_arg, "forcelogzero")) {
          optargs_s.forcelogzero = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_FORCELOGZERO_BITMASK;
        }
        else if (STREQ (this_arg, "nomodify")) {
          optargs_s.nomodify = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_NOMODIFY_BITMASK;
        }
        else if (STREQ (this_arg, "noprefetch")) {
          optargs_s.noprefetch = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_NOPREFETCH_BITMASK;
        }
        else if (STREQ (this_arg, "forcegeometry")) {
          optargs_s.forcegeometry = SvIV (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_FORCEGEOMETRY_BITMASK;
        }
        else if (STREQ (this_arg, "maxmem")) {
          optargs_s.maxmem = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_MAXMEM_BITMASK;
        }
        else if (STREQ (this_arg, "ihashsize")) {
          optargs_s.ihashsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_IHASHSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "bhashsize")) {
          optargs_s.bhashsize = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_BHASHSIZE_BITMASK;
        }
        else if (STREQ (this_arg, "agstride")) {
          optargs_s.agstride = my_SvIV64 (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_AGSTRIDE_BITMASK;
        }
        else if (STREQ (this_arg, "logdev")) {
          optargs_s.logdev = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_LOGDEV_BITMASK;
        }
        else if (STREQ (this_arg, "rtdev")) {
          optargs_s.rtdev = SvPV_nolen (ST (items_i+1));
          this_mask = GUESTFS_XFS_REPAIR_RTDEV_BITMASK;
        }
        else croak ("unknown optional argument '%s'", this_arg);
        if (optargs_s.bitmask & this_mask)
          croak ("optional argument '%s' given twice",
                 this_arg);
        optargs_s.bitmask |= this_mask;
      }

      r = guestfs_xfs_repair_argv (g, device, optargs);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSViv (r);
#line 28128 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_zegrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zegrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 10972 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 28155 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zegrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zegrep(): g is not a blessed HV reference");
    };
#line 10975 "lib/Sys/Guestfs.xs"
      r = guestfs_zegrep (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28179 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zegrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zegrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 10992 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 28205 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zegrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zegrepi(): g is not a blessed HV reference");
    };
#line 10995 "lib/Sys/Guestfs.xs"
      r = guestfs_zegrepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28229 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zero); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zero)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 11011 "lib/Sys/Guestfs.xs"
      int r;
#line 28253 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zero(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zero(): g is not a blessed HV reference");
    };
#line 11013 "lib/Sys/Guestfs.xs"
      r = guestfs_zero (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28270 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zero_device); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zero_device)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 11022 "lib/Sys/Guestfs.xs"
      int r;
#line 28294 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zero_device(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zero_device(): g is not a blessed HV reference");
    };
#line 11024 "lib/Sys/Guestfs.xs"
      r = guestfs_zero_device (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28311 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zero_free_space); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zero_free_space)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, directory");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	directory = (char *)SvPV_nolen(ST(1));
#line 11033 "lib/Sys/Guestfs.xs"
      int r;
#line 28335 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zero_free_space(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zero_free_space(): g is not a blessed HV reference");
    };
#line 11035 "lib/Sys/Guestfs.xs"
      r = guestfs_zero_free_space (g, directory);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28352 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zerofree); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zerofree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, device");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	device = (char *)SvPV_nolen(ST(1));
#line 11044 "lib/Sys/Guestfs.xs"
      int r;
#line 28376 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zerofree(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zerofree(): g is not a blessed HV reference");
    };
#line 11046 "lib/Sys/Guestfs.xs"
      r = guestfs_zerofree (g, device);
      if (r == -1)
        croak ("%s", guestfs_last_error (g));
#line 28393 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zfgrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zfgrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11056 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 28419 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zfgrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zfgrep(): g is not a blessed HV reference");
    };
#line 11059 "lib/Sys/Guestfs.xs"
      r = guestfs_zfgrep (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28443 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zfgrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zfgrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, pattern, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	pattern = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11076 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 28469 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zfgrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zfgrepi(): g is not a blessed HV reference");
    };
#line 11079 "lib/Sys/Guestfs.xs"
      r = guestfs_zfgrepi (g, pattern, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28493 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zfile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zfile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, meth, path");
    {
	guestfs_h *	g;
	char *	meth = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11096 "lib/Sys/Guestfs.xs"
      char *r;
#line 28516 "lib/Sys/Guestfs.c"
	SV *	RETVAL;

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zfile(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zfile(): g is not a blessed HV reference");
    };
#line 11098 "lib/Sys/Guestfs.xs"
      r = guestfs_zfile (g, meth, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      RETVAL = newSVpv (r, 0);
      free (r);
#line 28536 "lib/Sys/Guestfs.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Sys__Guestfs_zgrep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zgrep)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11112 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 28563 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zgrep(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zgrep(): g is not a blessed HV reference");
    };
#line 11115 "lib/Sys/Guestfs.xs"
      r = guestfs_zgrep (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28587 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}


XS(XS_Sys__Guestfs_zgrepi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sys__Guestfs_zgrepi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "g, regex, path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	guestfs_h *	g;
	char *	regex = (char *)SvPV_nolen(ST(1));
	char *	path = (char *)SvPV_nolen(ST(2));
#line 11132 "lib/Sys/Guestfs.xs"
      char **r;
      size_t i, n;
#line 28613 "lib/Sys/Guestfs.c"

    if (sv_isobject (ST(0)) && sv_derived_from (ST(0), "Sys::Guestfs") &&
        SvTYPE (ST(0)) == SVt_RV &&
        SvTYPE (SvRV (ST(0))) == SVt_PVHV) {
        HV *hv = (HV *) SvRV (ST(0));
        SV **svp = hv_fetch (hv, "_g", 2, 0);
        if (svp == NULL)
            croak ("Sys::Guestfs::zgrepi(): called on a closed handle");
        g = (guestfs_h *) SvIV (*svp);
    } else {
        croak ("Sys::Guestfs::zgrepi(): g is not a blessed HV reference");
    };
#line 11135 "lib/Sys/Guestfs.xs"
      r = guestfs_zgrepi (g, regex, path);
      if (r == NULL)
        croak ("%s", guestfs_last_error (g));
      for (n = 0; r[n] != NULL; ++n) /**/;
      EXTEND (SP, n);
      for (i = 0; i < n; ++i) {
        PUSHs (sv_2mortal (newSVpv (r[i], 0)));
        free (r[i]);
      }
      free (r);
#line 28637 "lib/Sys/Guestfs.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Sys__Guestfs); /* prototype to pass -Wmissing-prototypes */
XS(boot_Sys__Guestfs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Sys::Guestfs::_create", XS_Sys__Guestfs__create, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::DESTROY", XS_Sys__Guestfs_DESTROY, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::close", XS_Sys__Guestfs_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::set_event_callback", XS_Sys__Guestfs_set_event_callback, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::delete_event_callback", XS_Sys__Guestfs_delete_event_callback, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::event_to_string", XS_Sys__Guestfs_event_to_string, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::last_errno", XS_Sys__Guestfs_last_errno, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::acl_delete_def_file", XS_Sys__Guestfs_acl_delete_def_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::acl_get_file", XS_Sys__Guestfs_acl_get_file, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::acl_set_file", XS_Sys__Guestfs_acl_set_file, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::add_cdrom", XS_Sys__Guestfs_add_cdrom, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::add_domain", XS_Sys__Guestfs_add_domain, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::add_drive", XS_Sys__Guestfs_add_drive, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_ro", XS_Sys__Guestfs_add_drive_ro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_ro_with_if", XS_Sys__Guestfs_add_drive_ro_with_if, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_scratch", XS_Sys__Guestfs_add_drive_scratch, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::add_drive_with_if", XS_Sys__Guestfs_add_drive_with_if, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::add_libvirt_dom", XS_Sys__Guestfs_add_libvirt_dom, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::aug_clear", XS_Sys__Guestfs_aug_clear, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_close", XS_Sys__Guestfs_aug_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::aug_defnode", XS_Sys__Guestfs_aug_defnode, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_defvar", XS_Sys__Guestfs_aug_defvar, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_get", XS_Sys__Guestfs_aug_get, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_init", XS_Sys__Guestfs_aug_init, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_insert", XS_Sys__Guestfs_aug_insert, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_label", XS_Sys__Guestfs_aug_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_load", XS_Sys__Guestfs_aug_load, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::aug_ls", XS_Sys__Guestfs_aug_ls, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_match", XS_Sys__Guestfs_aug_match, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_mv", XS_Sys__Guestfs_aug_mv, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_rm", XS_Sys__Guestfs_aug_rm, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_save", XS_Sys__Guestfs_aug_save, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::aug_set", XS_Sys__Guestfs_aug_set, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::aug_setm", XS_Sys__Guestfs_aug_setm, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::available", XS_Sys__Guestfs_available, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::available_all_groups", XS_Sys__Guestfs_available_all_groups, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::base64_in", XS_Sys__Guestfs_base64_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::base64_out", XS_Sys__Guestfs_base64_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::blkdiscard", XS_Sys__Guestfs_blkdiscard, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blkdiscardzeroes", XS_Sys__Guestfs_blkdiscardzeroes, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blkid", XS_Sys__Guestfs_blkid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_flushbufs", XS_Sys__Guestfs_blockdev_flushbufs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getbsz", XS_Sys__Guestfs_blockdev_getbsz, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getro", XS_Sys__Guestfs_blockdev_getro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getsize64", XS_Sys__Guestfs_blockdev_getsize64, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getss", XS_Sys__Guestfs_blockdev_getss, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_getsz", XS_Sys__Guestfs_blockdev_getsz, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_rereadpt", XS_Sys__Guestfs_blockdev_rereadpt, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setbsz", XS_Sys__Guestfs_blockdev_setbsz, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setra", XS_Sys__Guestfs_blockdev_setra, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setro", XS_Sys__Guestfs_blockdev_setro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::blockdev_setrw", XS_Sys__Guestfs_blockdev_setrw, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_cancel", XS_Sys__Guestfs_btrfs_balance_cancel, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_pause", XS_Sys__Guestfs_btrfs_balance_pause, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_resume", XS_Sys__Guestfs_btrfs_balance_resume, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_balance_status", XS_Sys__Guestfs_btrfs_balance_status, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_device_add", XS_Sys__Guestfs_btrfs_device_add, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_device_delete", XS_Sys__Guestfs_btrfs_device_delete, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_balance", XS_Sys__Guestfs_btrfs_filesystem_balance, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_defragment", XS_Sys__Guestfs_btrfs_filesystem_defragment, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_resize", XS_Sys__Guestfs_btrfs_filesystem_resize, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_filesystem_sync", XS_Sys__Guestfs_btrfs_filesystem_sync, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_fsck", XS_Sys__Guestfs_btrfs_fsck, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_image", XS_Sys__Guestfs_btrfs_image, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_assign", XS_Sys__Guestfs_btrfs_qgroup_assign, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_create", XS_Sys__Guestfs_btrfs_qgroup_create, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_destroy", XS_Sys__Guestfs_btrfs_qgroup_destroy, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_limit", XS_Sys__Guestfs_btrfs_qgroup_limit, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_remove", XS_Sys__Guestfs_btrfs_qgroup_remove, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_qgroup_show", XS_Sys__Guestfs_btrfs_qgroup_show, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_quota_enable", XS_Sys__Guestfs_btrfs_quota_enable, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_quota_rescan", XS_Sys__Guestfs_btrfs_quota_rescan, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_replace", XS_Sys__Guestfs_btrfs_replace, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_rescue_chunk_recover", XS_Sys__Guestfs_btrfs_rescue_chunk_recover, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_rescue_super_recover", XS_Sys__Guestfs_btrfs_rescue_super_recover, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_cancel", XS_Sys__Guestfs_btrfs_scrub_cancel, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_resume", XS_Sys__Guestfs_btrfs_scrub_resume, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_start", XS_Sys__Guestfs_btrfs_scrub_start, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_scrub_status", XS_Sys__Guestfs_btrfs_scrub_status, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_set_seeding", XS_Sys__Guestfs_btrfs_set_seeding, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_create", XS_Sys__Guestfs_btrfs_subvolume_create, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_delete", XS_Sys__Guestfs_btrfs_subvolume_delete, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_get_default", XS_Sys__Guestfs_btrfs_subvolume_get_default, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_list", XS_Sys__Guestfs_btrfs_subvolume_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_set_default", XS_Sys__Guestfs_btrfs_subvolume_set_default, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_show", XS_Sys__Guestfs_btrfs_subvolume_show, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfs_subvolume_snapshot", XS_Sys__Guestfs_btrfs_subvolume_snapshot, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::btrfstune_enable_extended_inode_refs", XS_Sys__Guestfs_btrfstune_enable_extended_inode_refs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfstune_enable_skinny_metadata_extent_refs", XS_Sys__Guestfs_btrfstune_enable_skinny_metadata_extent_refs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::btrfstune_seeding", XS_Sys__Guestfs_btrfstune_seeding, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::c_pointer", XS_Sys__Guestfs_c_pointer, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::canonical_device_name", XS_Sys__Guestfs_canonical_device_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::cap_get_file", XS_Sys__Guestfs_cap_get_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::cap_set_file", XS_Sys__Guestfs_cap_set_file, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::case_sensitive_path", XS_Sys__Guestfs_case_sensitive_path, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::cat", XS_Sys__Guestfs_cat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::checksum", XS_Sys__Guestfs_checksum, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::checksum_device", XS_Sys__Guestfs_checksum_device, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::checksums_out", XS_Sys__Guestfs_checksums_out, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::chmod", XS_Sys__Guestfs_chmod, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::chown", XS_Sys__Guestfs_chown, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::clear_backend_setting", XS_Sys__Guestfs_clear_backend_setting, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::command", XS_Sys__Guestfs_command, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::command_lines", XS_Sys__Guestfs_command_lines, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::compress_device_out", XS_Sys__Guestfs_compress_device_out, file, "$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::compress_out", XS_Sys__Guestfs_compress_out, file, "$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::config", XS_Sys__Guestfs_config, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::copy_attributes", XS_Sys__Guestfs_copy_attributes, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_device_to_device", XS_Sys__Guestfs_copy_device_to_device, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_device_to_file", XS_Sys__Guestfs_copy_device_to_file, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_file_to_device", XS_Sys__Guestfs_copy_file_to_device, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_file_to_file", XS_Sys__Guestfs_copy_file_to_file, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::copy_in", XS_Sys__Guestfs_copy_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::copy_out", XS_Sys__Guestfs_copy_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::copy_size", XS_Sys__Guestfs_copy_size, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::cp", XS_Sys__Guestfs_cp, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::cp_a", XS_Sys__Guestfs_cp_a, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::cp_r", XS_Sys__Guestfs_cp_r, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::cpio_out", XS_Sys__Guestfs_cpio_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::dd", XS_Sys__Guestfs_dd, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::debug", XS_Sys__Guestfs_debug, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::debug_drives", XS_Sys__Guestfs_debug_drives, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::debug_upload", XS_Sys__Guestfs_debug_upload, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::device_index", XS_Sys__Guestfs_device_index, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::df", XS_Sys__Guestfs_df, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::df_h", XS_Sys__Guestfs_df_h, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::disk_create", XS_Sys__Guestfs_disk_create, file, "$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::disk_format", XS_Sys__Guestfs_disk_format, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::disk_has_backing_file", XS_Sys__Guestfs_disk_has_backing_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::disk_virtual_size", XS_Sys__Guestfs_disk_virtual_size, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::dmesg", XS_Sys__Guestfs_dmesg, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::download", XS_Sys__Guestfs_download, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::download_offset", XS_Sys__Guestfs_download_offset, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::drop_caches", XS_Sys__Guestfs_drop_caches, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::du", XS_Sys__Guestfs_du, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::e2fsck", XS_Sys__Guestfs_e2fsck, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::e2fsck_f", XS_Sys__Guestfs_e2fsck_f, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::echo_daemon", XS_Sys__Guestfs_echo_daemon, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::egrep", XS_Sys__Guestfs_egrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::egrepi", XS_Sys__Guestfs_egrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::equal", XS_Sys__Guestfs_equal, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::exists", XS_Sys__Guestfs_exists, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::extlinux", XS_Sys__Guestfs_extlinux, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fallocate", XS_Sys__Guestfs_fallocate, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fallocate64", XS_Sys__Guestfs_fallocate64, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::feature_available", XS_Sys__Guestfs_feature_available, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fgrep", XS_Sys__Guestfs_fgrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fgrepi", XS_Sys__Guestfs_fgrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::file", XS_Sys__Guestfs_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::file_architecture", XS_Sys__Guestfs_file_architecture, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::filesize", XS_Sys__Guestfs_filesize, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::filesystem_available", XS_Sys__Guestfs_filesystem_available, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fill", XS_Sys__Guestfs_fill, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::fill_dir", XS_Sys__Guestfs_fill_dir, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fill_pattern", XS_Sys__Guestfs_fill_pattern, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::find", XS_Sys__Guestfs_find, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::find0", XS_Sys__Guestfs_find0, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::findfs_label", XS_Sys__Guestfs_findfs_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::findfs_uuid", XS_Sys__Guestfs_findfs_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::fsck", XS_Sys__Guestfs_fsck, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::fstrim", XS_Sys__Guestfs_fstrim, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::get_append", XS_Sys__Guestfs_get_append, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_attach_method", XS_Sys__Guestfs_get_attach_method, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_autosync", XS_Sys__Guestfs_get_autosync, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_backend", XS_Sys__Guestfs_get_backend, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_backend_setting", XS_Sys__Guestfs_get_backend_setting, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_backend_settings", XS_Sys__Guestfs_get_backend_settings, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_cachedir", XS_Sys__Guestfs_get_cachedir, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_direct", XS_Sys__Guestfs_get_direct, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2attrs", XS_Sys__Guestfs_get_e2attrs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2generation", XS_Sys__Guestfs_get_e2generation, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2label", XS_Sys__Guestfs_get_e2label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_e2uuid", XS_Sys__Guestfs_get_e2uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_hv", XS_Sys__Guestfs_get_hv, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_identifier", XS_Sys__Guestfs_get_identifier, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credential_challenge", XS_Sys__Guestfs_get_libvirt_requested_credential_challenge, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credential_defresult", XS_Sys__Guestfs_get_libvirt_requested_credential_defresult, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credential_prompt", XS_Sys__Guestfs_get_libvirt_requested_credential_prompt, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::get_libvirt_requested_credentials", XS_Sys__Guestfs_get_libvirt_requested_credentials, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_memsize", XS_Sys__Guestfs_get_memsize, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_network", XS_Sys__Guestfs_get_network, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_path", XS_Sys__Guestfs_get_path, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_pgroup", XS_Sys__Guestfs_get_pgroup, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_pid", XS_Sys__Guestfs_get_pid, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_program", XS_Sys__Guestfs_get_program, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_qemu", XS_Sys__Guestfs_get_qemu, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_recovery_proc", XS_Sys__Guestfs_get_recovery_proc, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_selinux", XS_Sys__Guestfs_get_selinux, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_smp", XS_Sys__Guestfs_get_smp, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_state", XS_Sys__Guestfs_get_state, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_tmpdir", XS_Sys__Guestfs_get_tmpdir, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_trace", XS_Sys__Guestfs_get_trace, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_umask", XS_Sys__Guestfs_get_umask, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::get_verbose", XS_Sys__Guestfs_get_verbose, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::getcon", XS_Sys__Guestfs_getcon, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::getxattr", XS_Sys__Guestfs_getxattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::getxattrs", XS_Sys__Guestfs_getxattrs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::glob_expand", XS_Sys__Guestfs_glob_expand, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::grep", XS_Sys__Guestfs_grep, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::grepi", XS_Sys__Guestfs_grepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::grub_install", XS_Sys__Guestfs_grub_install, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::head", XS_Sys__Guestfs_head, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::head_n", XS_Sys__Guestfs_head_n, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hexdump", XS_Sys__Guestfs_hexdump, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_close", XS_Sys__Guestfs_hivex_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_commit", XS_Sys__Guestfs_hivex_commit, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_add_child", XS_Sys__Guestfs_hivex_node_add_child, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_children", XS_Sys__Guestfs_hivex_node_children, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_delete_child", XS_Sys__Guestfs_hivex_node_delete_child, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_get_child", XS_Sys__Guestfs_hivex_node_get_child, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_get_value", XS_Sys__Guestfs_hivex_node_get_value, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_name", XS_Sys__Guestfs_hivex_node_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_parent", XS_Sys__Guestfs_hivex_node_parent, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_set_value", XS_Sys__Guestfs_hivex_node_set_value, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_node_values", XS_Sys__Guestfs_hivex_node_values, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_open", XS_Sys__Guestfs_hivex_open, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::hivex_root", XS_Sys__Guestfs_hivex_root, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_key", XS_Sys__Guestfs_hivex_value_key, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_type", XS_Sys__Guestfs_hivex_value_type, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_utf8", XS_Sys__Guestfs_hivex_value_utf8, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::hivex_value_value", XS_Sys__Guestfs_hivex_value_value, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::initrd_cat", XS_Sys__Guestfs_initrd_cat, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::initrd_list", XS_Sys__Guestfs_initrd_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_add_watch", XS_Sys__Guestfs_inotify_add_watch, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_close", XS_Sys__Guestfs_inotify_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_files", XS_Sys__Guestfs_inotify_files, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_init", XS_Sys__Guestfs_inotify_init, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_read", XS_Sys__Guestfs_inotify_read, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inotify_rm_watch", XS_Sys__Guestfs_inotify_rm_watch, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_arch", XS_Sys__Guestfs_inspect_get_arch, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_distro", XS_Sys__Guestfs_inspect_get_distro, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_drive_mappings", XS_Sys__Guestfs_inspect_get_drive_mappings, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_filesystems", XS_Sys__Guestfs_inspect_get_filesystems, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_format", XS_Sys__Guestfs_inspect_get_format, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_hostname", XS_Sys__Guestfs_inspect_get_hostname, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_icon", XS_Sys__Guestfs_inspect_get_icon, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_major_version", XS_Sys__Guestfs_inspect_get_major_version, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_minor_version", XS_Sys__Guestfs_inspect_get_minor_version, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_mountpoints", XS_Sys__Guestfs_inspect_get_mountpoints, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_package_format", XS_Sys__Guestfs_inspect_get_package_format, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_package_management", XS_Sys__Guestfs_inspect_get_package_management, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_product_name", XS_Sys__Guestfs_inspect_get_product_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_product_variant", XS_Sys__Guestfs_inspect_get_product_variant, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_roots", XS_Sys__Guestfs_inspect_get_roots, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_type", XS_Sys__Guestfs_inspect_get_type, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_windows_current_control_set", XS_Sys__Guestfs_inspect_get_windows_current_control_set, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_get_windows_systemroot", XS_Sys__Guestfs_inspect_get_windows_systemroot, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_is_live", XS_Sys__Guestfs_inspect_is_live, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_is_multipart", XS_Sys__Guestfs_inspect_is_multipart, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_is_netinst", XS_Sys__Guestfs_inspect_is_netinst, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_list_applications", XS_Sys__Guestfs_inspect_list_applications, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_list_applications2", XS_Sys__Guestfs_inspect_list_applications2, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::inspect_os", XS_Sys__Guestfs_inspect_os, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_exit", XS_Sys__Guestfs_internal_exit, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test", XS_Sys__Guestfs_internal_test, file, "$$$$$$$$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_63_optargs", XS_Sys__Guestfs_internal_test_63_optargs, file, "$;@");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_close_output", XS_Sys__Guestfs_internal_test_close_output, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_only_optargs", XS_Sys__Guestfs_internal_test_only_optargs, file, "$;@");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rbool", XS_Sys__Guestfs_internal_test_rbool, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rboolerr", XS_Sys__Guestfs_internal_test_rboolerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rbufferout", XS_Sys__Guestfs_internal_test_rbufferout, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rbufferouterr", XS_Sys__Guestfs_internal_test_rbufferouterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconstoptstring", XS_Sys__Guestfs_internal_test_rconstoptstring, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconstoptstringerr", XS_Sys__Guestfs_internal_test_rconstoptstringerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconststring", XS_Sys__Guestfs_internal_test_rconststring, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rconststringerr", XS_Sys__Guestfs_internal_test_rconststringerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rhashtable", XS_Sys__Guestfs_internal_test_rhashtable, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rhashtableerr", XS_Sys__Guestfs_internal_test_rhashtableerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rint", XS_Sys__Guestfs_internal_test_rint, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rint64", XS_Sys__Guestfs_internal_test_rint64, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rint64err", XS_Sys__Guestfs_internal_test_rint64err, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rinterr", XS_Sys__Guestfs_internal_test_rinterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstring", XS_Sys__Guestfs_internal_test_rstring, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstringerr", XS_Sys__Guestfs_internal_test_rstringerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstringlist", XS_Sys__Guestfs_internal_test_rstringlist, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstringlisterr", XS_Sys__Guestfs_internal_test_rstringlisterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstruct", XS_Sys__Guestfs_internal_test_rstruct, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstructerr", XS_Sys__Guestfs_internal_test_rstructerr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstructlist", XS_Sys__Guestfs_internal_test_rstructlist, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_rstructlisterr", XS_Sys__Guestfs_internal_test_rstructlisterr, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::internal_test_set_output", XS_Sys__Guestfs_internal_test_set_output, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_blockdev", XS_Sys__Guestfs_is_blockdev, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_busy", XS_Sys__Guestfs_is_busy, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_chardev", XS_Sys__Guestfs_is_chardev, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_config", XS_Sys__Guestfs_is_config, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_dir", XS_Sys__Guestfs_is_dir, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_fifo", XS_Sys__Guestfs_is_fifo, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_file", XS_Sys__Guestfs_is_file, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_launching", XS_Sys__Guestfs_is_launching, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_lv", XS_Sys__Guestfs_is_lv, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_ready", XS_Sys__Guestfs_is_ready, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::is_socket", XS_Sys__Guestfs_is_socket, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::is_symlink", XS_Sys__Guestfs_is_symlink, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_whole_device", XS_Sys__Guestfs_is_whole_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_zero", XS_Sys__Guestfs_is_zero, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::is_zero_device", XS_Sys__Guestfs_is_zero_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::isoinfo", XS_Sys__Guestfs_isoinfo, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::isoinfo_device", XS_Sys__Guestfs_isoinfo_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::journal_close", XS_Sys__Guestfs_journal_close, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_get", XS_Sys__Guestfs_journal_get, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_get_data_threshold", XS_Sys__Guestfs_journal_get_data_threshold, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_get_realtime_usec", XS_Sys__Guestfs_journal_get_realtime_usec, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_next", XS_Sys__Guestfs_journal_next, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::journal_open", XS_Sys__Guestfs_journal_open, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::journal_set_data_threshold", XS_Sys__Guestfs_journal_set_data_threshold, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::journal_skip", XS_Sys__Guestfs_journal_skip, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::kill_subprocess", XS_Sys__Guestfs_kill_subprocess, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::launch", XS_Sys__Guestfs_launch, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lchown", XS_Sys__Guestfs_lchown, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_create_all", XS_Sys__Guestfs_ldmtool_create_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_diskgroup_disks", XS_Sys__Guestfs_ldmtool_diskgroup_disks, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_diskgroup_name", XS_Sys__Guestfs_ldmtool_diskgroup_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_diskgroup_volumes", XS_Sys__Guestfs_ldmtool_diskgroup_volumes, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_remove_all", XS_Sys__Guestfs_ldmtool_remove_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_scan", XS_Sys__Guestfs_ldmtool_scan, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_scan_devices", XS_Sys__Guestfs_ldmtool_scan_devices, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_volume_hint", XS_Sys__Guestfs_ldmtool_volume_hint, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_volume_partitions", XS_Sys__Guestfs_ldmtool_volume_partitions, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ldmtool_volume_type", XS_Sys__Guestfs_ldmtool_volume_type, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lgetxattr", XS_Sys__Guestfs_lgetxattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lgetxattrs", XS_Sys__Guestfs_lgetxattrs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::list_9p", XS_Sys__Guestfs_list_9p, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_devices", XS_Sys__Guestfs_list_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_disk_labels", XS_Sys__Guestfs_list_disk_labels, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_dm_devices", XS_Sys__Guestfs_list_dm_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_filesystems", XS_Sys__Guestfs_list_filesystems, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_ldm_partitions", XS_Sys__Guestfs_list_ldm_partitions, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_ldm_volumes", XS_Sys__Guestfs_list_ldm_volumes, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_md_devices", XS_Sys__Guestfs_list_md_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::list_partitions", XS_Sys__Guestfs_list_partitions, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ll", XS_Sys__Guestfs_ll, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::llz", XS_Sys__Guestfs_llz, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ln", XS_Sys__Guestfs_ln, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ln_f", XS_Sys__Guestfs_ln_f, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ln_s", XS_Sys__Guestfs_ln_s, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ln_sf", XS_Sys__Guestfs_ln_sf, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lremovexattr", XS_Sys__Guestfs_lremovexattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ls", XS_Sys__Guestfs_ls, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ls0", XS_Sys__Guestfs_ls0, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lsetxattr", XS_Sys__Guestfs_lsetxattr, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lstat", XS_Sys__Guestfs_lstat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lstatlist", XS_Sys__Guestfs_lstatlist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lstatns", XS_Sys__Guestfs_lstatns, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lstatnslist", XS_Sys__Guestfs_lstatnslist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_add_key", XS_Sys__Guestfs_luks_add_key, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_close", XS_Sys__Guestfs_luks_close, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_format", XS_Sys__Guestfs_luks_format, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_format_cipher", XS_Sys__Guestfs_luks_format_cipher, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_kill_slot", XS_Sys__Guestfs_luks_kill_slot, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_open", XS_Sys__Guestfs_luks_open, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::luks_open_ro", XS_Sys__Guestfs_luks_open_ro, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvcreate", XS_Sys__Guestfs_lvcreate, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvcreate_free", XS_Sys__Guestfs_lvcreate_free, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_canonical_lv_name", XS_Sys__Guestfs_lvm_canonical_lv_name, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_clear_filter", XS_Sys__Guestfs_lvm_clear_filter, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_remove_all", XS_Sys__Guestfs_lvm_remove_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvm_set_filter", XS_Sys__Guestfs_lvm_set_filter, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lvremove", XS_Sys__Guestfs_lvremove, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lvrename", XS_Sys__Guestfs_lvrename, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvresize", XS_Sys__Guestfs_lvresize, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvresize_free", XS_Sys__Guestfs_lvresize_free, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::lvs", XS_Sys__Guestfs_lvs, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvs_full", XS_Sys__Guestfs_lvs_full, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::lvuuid", XS_Sys__Guestfs_lvuuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::lxattrlist", XS_Sys__Guestfs_lxattrlist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::max_disks", XS_Sys__Guestfs_max_disks, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::md_create", XS_Sys__Guestfs_md_create, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::md_detail", XS_Sys__Guestfs_md_detail, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::md_stat", XS_Sys__Guestfs_md_stat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::md_stop", XS_Sys__Guestfs_md_stop, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdir", XS_Sys__Guestfs_mkdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdir_mode", XS_Sys__Guestfs_mkdir_mode, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdir_p", XS_Sys__Guestfs_mkdir_p, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkdtemp", XS_Sys__Guestfs_mkdtemp, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs", XS_Sys__Guestfs_mke2fs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs_J", XS_Sys__Guestfs_mke2fs_J, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs_JL", XS_Sys__Guestfs_mke2fs_JL, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2fs_JU", XS_Sys__Guestfs_mke2fs_JU, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2journal", XS_Sys__Guestfs_mke2journal, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2journal_L", XS_Sys__Guestfs_mke2journal_L, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mke2journal_U", XS_Sys__Guestfs_mke2journal_U, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkfifo", XS_Sys__Guestfs_mkfifo, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkfs", XS_Sys__Guestfs_mkfs, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mkfs_b", XS_Sys__Guestfs_mkfs_b, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkfs_btrfs", XS_Sys__Guestfs_mkfs_btrfs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mklost_and_found", XS_Sys__Guestfs_mklost_and_found, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mkmountpoint", XS_Sys__Guestfs_mkmountpoint, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mknod", XS_Sys__Guestfs_mknod, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mknod_b", XS_Sys__Guestfs_mknod_b, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mknod_c", XS_Sys__Guestfs_mknod_c, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkswap", XS_Sys__Guestfs_mkswap, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mkswap_L", XS_Sys__Guestfs_mkswap_L, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkswap_U", XS_Sys__Guestfs_mkswap_U, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mkswap_file", XS_Sys__Guestfs_mkswap_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mktemp", XS_Sys__Guestfs_mktemp, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::modprobe", XS_Sys__Guestfs_modprobe, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::mount", XS_Sys__Guestfs_mount, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_9p", XS_Sys__Guestfs_mount_9p, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mount_local", XS_Sys__Guestfs_mount_local, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::mount_local_run", XS_Sys__Guestfs_mount_local_run, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::mount_loop", XS_Sys__Guestfs_mount_loop, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_options", XS_Sys__Guestfs_mount_options, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_ro", XS_Sys__Guestfs_mount_ro, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::mount_vfs", XS_Sys__Guestfs_mount_vfs, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::mountpoints", XS_Sys__Guestfs_mountpoints, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::mounts", XS_Sys__Guestfs_mounts, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::mv", XS_Sys__Guestfs_mv, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::nr_devices", XS_Sys__Guestfs_nr_devices, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::ntfs_3g_probe", XS_Sys__Guestfs_ntfs_3g_probe, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ntfsclone_in", XS_Sys__Guestfs_ntfsclone_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::ntfsclone_out", XS_Sys__Guestfs_ntfsclone_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::ntfsfix", XS_Sys__Guestfs_ntfsfix, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::ntfsresize", XS_Sys__Guestfs_ntfsresize, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::ntfsresize_size", XS_Sys__Guestfs_ntfsresize_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::parse_environment", XS_Sys__Guestfs_parse_environment, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::parse_environment_list", XS_Sys__Guestfs_parse_environment_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_add", XS_Sys__Guestfs_part_add, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_del", XS_Sys__Guestfs_part_del, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_disk", XS_Sys__Guestfs_part_disk, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_bootable", XS_Sys__Guestfs_part_get_bootable, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_gpt_guid", XS_Sys__Guestfs_part_get_gpt_guid, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_gpt_type", XS_Sys__Guestfs_part_get_gpt_type, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_mbr_id", XS_Sys__Guestfs_part_get_mbr_id, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_mbr_part_type", XS_Sys__Guestfs_part_get_mbr_part_type, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_name", XS_Sys__Guestfs_part_get_name, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_get_parttype", XS_Sys__Guestfs_part_get_parttype, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_init", XS_Sys__Guestfs_part_init, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_list", XS_Sys__Guestfs_part_list, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_bootable", XS_Sys__Guestfs_part_set_bootable, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_gpt_guid", XS_Sys__Guestfs_part_set_gpt_guid, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_gpt_type", XS_Sys__Guestfs_part_set_gpt_type, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_mbr_id", XS_Sys__Guestfs_part_set_mbr_id, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_set_name", XS_Sys__Guestfs_part_set_name, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::part_to_dev", XS_Sys__Guestfs_part_to_dev, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::part_to_partnum", XS_Sys__Guestfs_part_to_partnum, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::ping_daemon", XS_Sys__Guestfs_ping_daemon, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pread", XS_Sys__Guestfs_pread, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::pread_device", XS_Sys__Guestfs_pread_device, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::pvchange_uuid", XS_Sys__Guestfs_pvchange_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvchange_uuid_all", XS_Sys__Guestfs_pvchange_uuid_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pvcreate", XS_Sys__Guestfs_pvcreate, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvremove", XS_Sys__Guestfs_pvremove, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvresize", XS_Sys__Guestfs_pvresize, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pvresize_size", XS_Sys__Guestfs_pvresize_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::pvs", XS_Sys__Guestfs_pvs, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pvs_full", XS_Sys__Guestfs_pvs_full, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::pvuuid", XS_Sys__Guestfs_pvuuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::pwrite", XS_Sys__Guestfs_pwrite, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::pwrite_device", XS_Sys__Guestfs_pwrite_device, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::read_file", XS_Sys__Guestfs_read_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::read_lines", XS_Sys__Guestfs_read_lines, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::readdir", XS_Sys__Guestfs_readdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::readlink", XS_Sys__Guestfs_readlink, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::readlinklist", XS_Sys__Guestfs_readlinklist, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::realpath", XS_Sys__Guestfs_realpath, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::remount", XS_Sys__Guestfs_remount, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::remove_drive", XS_Sys__Guestfs_remove_drive, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::removexattr", XS_Sys__Guestfs_removexattr, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::rename", XS_Sys__Guestfs_rename, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::resize2fs", XS_Sys__Guestfs_resize2fs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::resize2fs_M", XS_Sys__Guestfs_resize2fs_M, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::resize2fs_size", XS_Sys__Guestfs_resize2fs_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::rm", XS_Sys__Guestfs_rm, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rm_f", XS_Sys__Guestfs_rm_f, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rm_rf", XS_Sys__Guestfs_rm_rf, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rmdir", XS_Sys__Guestfs_rmdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rmmountpoint", XS_Sys__Guestfs_rmmountpoint, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::rsync", XS_Sys__Guestfs_rsync, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::rsync_in", XS_Sys__Guestfs_rsync_in, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::rsync_out", XS_Sys__Guestfs_rsync_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::scrub_device", XS_Sys__Guestfs_scrub_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::scrub_file", XS_Sys__Guestfs_scrub_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::scrub_freespace", XS_Sys__Guestfs_scrub_freespace, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_append", XS_Sys__Guestfs_set_append, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_attach_method", XS_Sys__Guestfs_set_attach_method, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_autosync", XS_Sys__Guestfs_set_autosync, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_backend", XS_Sys__Guestfs_set_backend, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_backend_setting", XS_Sys__Guestfs_set_backend_setting, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_backend_settings", XS_Sys__Guestfs_set_backend_settings, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_cachedir", XS_Sys__Guestfs_set_cachedir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_direct", XS_Sys__Guestfs_set_direct, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_e2attrs", XS_Sys__Guestfs_set_e2attrs, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::set_e2generation", XS_Sys__Guestfs_set_e2generation, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_e2label", XS_Sys__Guestfs_set_e2label, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_e2uuid", XS_Sys__Guestfs_set_e2uuid, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_hv", XS_Sys__Guestfs_set_hv, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_identifier", XS_Sys__Guestfs_set_identifier, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_label", XS_Sys__Guestfs_set_label, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_libvirt_requested_credential", XS_Sys__Guestfs_set_libvirt_requested_credential, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_libvirt_supported_credentials", XS_Sys__Guestfs_set_libvirt_supported_credentials, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_memsize", XS_Sys__Guestfs_set_memsize, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_network", XS_Sys__Guestfs_set_network, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_path", XS_Sys__Guestfs_set_path, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_pgroup", XS_Sys__Guestfs_set_pgroup, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_program", XS_Sys__Guestfs_set_program, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_qemu", XS_Sys__Guestfs_set_qemu, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_recovery_proc", XS_Sys__Guestfs_set_recovery_proc, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_selinux", XS_Sys__Guestfs_set_selinux, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_smp", XS_Sys__Guestfs_set_smp, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_tmpdir", XS_Sys__Guestfs_set_tmpdir, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_trace", XS_Sys__Guestfs_set_trace, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_uuid", XS_Sys__Guestfs_set_uuid, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::set_uuid_random", XS_Sys__Guestfs_set_uuid_random, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::set_verbose", XS_Sys__Guestfs_set_verbose, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::setcon", XS_Sys__Guestfs_setcon, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::setxattr", XS_Sys__Guestfs_setxattr, file, "$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk", XS_Sys__Guestfs_sfdisk, file, "$$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdiskM", XS_Sys__Guestfs_sfdiskM, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_N", XS_Sys__Guestfs_sfdisk_N, file, "$$$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_disk_geometry", XS_Sys__Guestfs_sfdisk_disk_geometry, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_kernel_geometry", XS_Sys__Guestfs_sfdisk_kernel_geometry, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sfdisk_l", XS_Sys__Guestfs_sfdisk_l, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sh", XS_Sys__Guestfs_sh, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sh_lines", XS_Sys__Guestfs_sh_lines, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::shutdown", XS_Sys__Guestfs_shutdown, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::sleep", XS_Sys__Guestfs_sleep, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::stat", XS_Sys__Guestfs_stat, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::statns", XS_Sys__Guestfs_statns, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::statvfs", XS_Sys__Guestfs_statvfs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::strings", XS_Sys__Guestfs_strings, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::strings_e", XS_Sys__Guestfs_strings_e, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_device", XS_Sys__Guestfs_swapoff_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_file", XS_Sys__Guestfs_swapoff_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_label", XS_Sys__Guestfs_swapoff_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapoff_uuid", XS_Sys__Guestfs_swapoff_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_device", XS_Sys__Guestfs_swapon_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_file", XS_Sys__Guestfs_swapon_file, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_label", XS_Sys__Guestfs_swapon_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::swapon_uuid", XS_Sys__Guestfs_swapon_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::sync", XS_Sys__Guestfs_sync, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::syslinux", XS_Sys__Guestfs_syslinux, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tail", XS_Sys__Guestfs_tail, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::tail_n", XS_Sys__Guestfs_tail_n, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::tar_in", XS_Sys__Guestfs_tar_in, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tar_out", XS_Sys__Guestfs_tar_out, file, "$$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tgz_in", XS_Sys__Guestfs_tgz_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::tgz_out", XS_Sys__Guestfs_tgz_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::touch", XS_Sys__Guestfs_touch, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::truncate", XS_Sys__Guestfs_truncate, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::truncate_size", XS_Sys__Guestfs_truncate_size, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::tune2fs", XS_Sys__Guestfs_tune2fs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::tune2fs_l", XS_Sys__Guestfs_tune2fs_l, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::txz_in", XS_Sys__Guestfs_txz_in, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::txz_out", XS_Sys__Guestfs_txz_out, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::umask", XS_Sys__Guestfs_umask, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::umount", XS_Sys__Guestfs_umount, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::umount_all", XS_Sys__Guestfs_umount_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::umount_local", XS_Sys__Guestfs_umount_local, file, "$;@");
        (void)newXSproto_portable("Sys::Guestfs::upload", XS_Sys__Guestfs_upload, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::upload_offset", XS_Sys__Guestfs_upload_offset, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::user_cancel", XS_Sys__Guestfs_user_cancel, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::utimens", XS_Sys__Guestfs_utimens, file, "$$$$$$");
        (void)newXSproto_portable("Sys::Guestfs::utsname", XS_Sys__Guestfs_utsname, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::version", XS_Sys__Guestfs_version, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_label", XS_Sys__Guestfs_vfs_label, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_minimum_size", XS_Sys__Guestfs_vfs_minimum_size, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_type", XS_Sys__Guestfs_vfs_type, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vfs_uuid", XS_Sys__Guestfs_vfs_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vg_activate", XS_Sys__Guestfs_vg_activate, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::vg_activate_all", XS_Sys__Guestfs_vg_activate_all, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgchange_uuid", XS_Sys__Guestfs_vgchange_uuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgchange_uuid_all", XS_Sys__Guestfs_vgchange_uuid_all, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vgcreate", XS_Sys__Guestfs_vgcreate, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::vglvuuids", XS_Sys__Guestfs_vglvuuids, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgmeta", XS_Sys__Guestfs_vgmeta, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgpvuuids", XS_Sys__Guestfs_vgpvuuids, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgremove", XS_Sys__Guestfs_vgremove, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::vgrename", XS_Sys__Guestfs_vgrename, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::vgs", XS_Sys__Guestfs_vgs, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vgs_full", XS_Sys__Guestfs_vgs_full, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vgscan", XS_Sys__Guestfs_vgscan, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::vguuid", XS_Sys__Guestfs_vguuid, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wait_ready", XS_Sys__Guestfs_wait_ready, file, "$");
        (void)newXSproto_portable("Sys::Guestfs::wc_c", XS_Sys__Guestfs_wc_c, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wc_l", XS_Sys__Guestfs_wc_l, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wc_w", XS_Sys__Guestfs_wc_w, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::wipefs", XS_Sys__Guestfs_wipefs, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::write", XS_Sys__Guestfs_write, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::write_append", XS_Sys__Guestfs_write_append, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::write_file", XS_Sys__Guestfs_write_file, file, "$$$$");
        (void)newXSproto_portable("Sys::Guestfs::xfs_admin", XS_Sys__Guestfs_xfs_admin, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::xfs_growfs", XS_Sys__Guestfs_xfs_growfs, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::xfs_info", XS_Sys__Guestfs_xfs_info, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::xfs_repair", XS_Sys__Guestfs_xfs_repair, file, "$$;@");
        (void)newXSproto_portable("Sys::Guestfs::zegrep", XS_Sys__Guestfs_zegrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zegrepi", XS_Sys__Guestfs_zegrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zero", XS_Sys__Guestfs_zero, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zero_device", XS_Sys__Guestfs_zero_device, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zero_free_space", XS_Sys__Guestfs_zero_free_space, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zerofree", XS_Sys__Guestfs_zerofree, file, "$$");
        (void)newXSproto_portable("Sys::Guestfs::zfgrep", XS_Sys__Guestfs_zfgrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zfgrepi", XS_Sys__Guestfs_zfgrepi, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zfile", XS_Sys__Guestfs_zfile, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zgrep", XS_Sys__Guestfs_zgrep, file, "$$$");
        (void)newXSproto_portable("Sys::Guestfs::zgrepi", XS_Sys__Guestfs_zgrepi, file, "$$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

